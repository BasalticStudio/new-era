# typed: true

# DO NOT EDIT MANUALLY
# This is an autogenerated file for types exported from the `annotate` gem.
# Please instead update this file by running `bin/tapioca gem annotate`.

module Annotate
  class << self
    def bootstrap_rake; end
    def eager_load(options); end
    def load_tasks; end

    # Set default values that can be overridden via environment variables.
    def set_defaults(options = T.unsafe(nil)); end

    # TODO: what is the difference between this and set_defaults?
    def setup_options(options = T.unsafe(nil)); end

    def version; end

    private

    def load_requires(options); end
  end
end

module Annotate::Constants; end
Annotate::Constants::ALL_ANNOTATE_OPTIONS = T.let(T.unsafe(nil), Array)
Annotate::Constants::FLAG_OPTIONS = T.let(T.unsafe(nil), Array)
Annotate::Constants::OTHER_OPTIONS = T.let(T.unsafe(nil), Array)
Annotate::Constants::PATH_OPTIONS = T.let(T.unsafe(nil), Array)

# The set of available options to customize the behavior of Annotate.
Annotate::Constants::POSITION_OPTIONS = T.let(T.unsafe(nil), Array)

Annotate::Constants::TRUE_RE = T.let(T.unsafe(nil), Regexp)

# Class for holding helper methods. Done to make lib/annotate.rb less bloated.
class Annotate::Helpers
  class << self
    def fallback(*args); end

    # @return [Boolean]
    def include_models?; end

    # @return [Boolean]
    def include_routes?; end

    def reset_options(options); end

    # @return [Boolean]
    def skip_on_migration?; end

    # @return [Boolean]
    def true?(val); end
  end
end

module AnnotateModels
  class << self
    # Given the name of an ActiveRecord class, create a schema
    # info block (basically a comment containing information
    # on the columns and their types) and put it at the front
    # of the model and fixture source files.
    #
    # === Options (opts)
    #  :position_in_class<Symbol>:: where to place the annotated section in model file
    #  :position_in_test<Symbol>:: where to place the annotated section in test/spec file(s)
    #  :position_in_fixture<Symbol>:: where to place the annotated section in fixture file
    #  :position_in_factory<Symbol>:: where to place the annotated section in factory file
    #  :position_in_serializer<Symbol>:: where to place the annotated section in serializer file
    #  :exclude_tests<Symbol>:: whether to skip modification of test/spec files
    #  :exclude_fixtures<Symbol>:: whether to skip modification of fixture files
    #  :exclude_factories<Symbol>:: whether to skip modification of factory files
    #  :exclude_serializers<Symbol>:: whether to skip modification of serializer files
    #  :exclude_scaffolds<Symbol>:: whether to skip modification of scaffold files
    #  :exclude_controllers<Symbol>:: whether to skip modification of controller files
    #  :exclude_helpers<Symbol>:: whether to skip modification of helper files
    #  :exclude_sti_subclasses<Symbol>:: whether to skip modification of files for STI subclasses
    #
    # == Returns:
    # an array of file names that were annotated.
    def annotate(klass, file, header, options = T.unsafe(nil)); end

    def annotate_model_file(annotated, file, header, options); end

    # Add a schema block to a file. If the file already contains
    # a schema info block (a comment starting with "== Schema Information"),
    # check if it matches the block that is already there. If so, leave it be.
    # If not, remove the old info block and write a new one.
    #
    # == Returns:
    # true or false depending on whether the file was modified.
    #
    # === Options (opts)
    #  :force<Symbol>:: whether to update the file even if it doesn't seem to need it.
    #  :position_in_*<Symbol>:: where to place the annotated section in fixture or model file,
    #                           :before, :top, :after or :bottom. Default is :before.
    def annotate_one_file(file_name, info_block, position, options = T.unsafe(nil)); end

    def annotate_pattern(options = T.unsafe(nil)); end
    def classified_sort(cols); end

    # We're passed a name of things that might be
    # ActiveRecord models. If we can find the class, and
    # if its a subclass of ActiveRecord::Base,
    # then pass it to the associated block
    def do_annotations(options = T.unsafe(nil)); end

    def expand_glob_into_files(glob); end
    def final_index_string(index, max_size); end
    def final_index_string_in_markdown(index); end
    def get_col_type(col); end
    def get_foreign_key_info(klass, options = T.unsafe(nil)); end
    def get_index_info(klass, options = T.unsafe(nil)); end

    # Retrieve loaded model class
    def get_loaded_model(model_path, file); end

    # Retrieve loaded model class by path to the file where it's supposed to be defined.
    def get_loaded_model_by_path(model_path); end

    # Retrieve the classes belonging to the model names we're asked to process
    # Check for namespaced models in subdirectories as well as models
    # in subdirectories without namespacing.
    def get_model_class(file); end

    # Return a list of the model files to annotate.
    # If we have command line arguments, they're assumed to the path
    # of model files from root dir. Otherwise we take all the model files
    # in the model_dir directory.
    def get_model_files(options); end

    def get_patterns(options, pattern_types = T.unsafe(nil)); end
    def get_schema_footer_text(_klass, options = T.unsafe(nil)); end
    def get_schema_header_text(klass, options = T.unsafe(nil)); end

    # Use the column information in an ActiveRecord class
    # to create a comment block containing a line for
    # each column. The line contains the column name,
    # the type (and length), and any optional attributes
    def get_schema_info(klass, header, options = T.unsafe(nil)); end

    # @return [Boolean]
    def hide_default?(col_type, options); end

    # @return [Boolean]
    def hide_limit?(col_type, options); end

    def index_columns_info(index); end
    def index_unique_info(index, format = T.unsafe(nil)); end
    def index_using_info(index, format = T.unsafe(nil)); end
    def index_where_info(index, format = T.unsafe(nil)); end
    def magic_comments_as_string(content); end
    def matched_types(options); end
    def model_dir; end

    # Sets the attribute model_dir
    #
    # @param value the value to set the attribute model_dir to.
    def model_dir=(_arg0); end

    # position = :position_in_fixture or :position_in_class
    def options_with_position(options, position_in); end

    def parse_options(options = T.unsafe(nil)); end

    # Simple quoting for the default column value
    def quote(value); end

    def remove_annotation_of_file(file_name, options = T.unsafe(nil)); end
    def remove_annotations(options = T.unsafe(nil)); end
    def resolve_filename(filename_template, model_name, table_name); end
    def retrieve_indexes_from_table(klass); end
    def root_dir; end

    # Sets the attribute root_dir
    #
    # @param value the value to set the attribute root_dir to.
    def root_dir=(_arg0); end

    def schema_default(klass, column); end
    def skip_subdirectory_model_load; end

    # Sets the attribute skip_subdirectory_model_load
    #
    # @param value the value to set the attribute skip_subdirectory_model_load to.
    def skip_subdirectory_model_load=(_arg0); end

    def split_model_dir(option_value); end

    private

    def columns(klass, options); end
    def format_default(col_name, max_size, col_type, bare_type_allowance, attrs); end

    # Get the list of attributes that should be included in the annotation for
    # a given column.
    def get_attributes(column, column_type, klass, options); end

    # These are the columns that the globalize gem needs to work but
    # are not necessary for the models to be displayed as annotations.
    def ignored_translation_table_colums(klass); end

    def list_model_files_from_argument; end
    def map_col_type_to_ruby_classes(col_type); end
    def max_schema_info_width(klass, options); end
    def mb_chars_ljust(string, length); end
    def non_ascii_length(string); end

    # Add columns managed by the globalize gem if this gem is being used.
    def translated_columns(klass); end

    def width(string); end

    # @return [Boolean]
    def with_comments?(klass, options); end
  end
end

class AnnotateModels::BadModelFileError < ::LoadError
  def to_s; end
end

# Annotate Models plugin use this header
AnnotateModels::COMPAT_PREFIX = T.let(T.unsafe(nil), String)

AnnotateModels::COMPAT_PREFIX_MD = T.let(T.unsafe(nil), String)
AnnotateModels::END_MARK = T.let(T.unsafe(nil), String)

# This module provides module method to get file paths.
module AnnotateModels::FilePatterns
  class << self
    def generate(root_directory, pattern_type, options); end

    private

    def factory_files(root_directory); end
    def fixture_files(root_directory); end
    def scaffold_files(root_directory); end
    def serialize_files(root_directory); end
    def test_files(root_directory); end
  end
end

# Active admin registry files
AnnotateModels::FilePatterns::ACTIVEADMIN_DIR = T.let(T.unsafe(nil), String)

AnnotateModels::FilePatterns::BLUEPRINTS_SPEC_DIR = T.let(T.unsafe(nil), String)

# Machinist http://github.com/notahat/machinist
AnnotateModels::FilePatterns::BLUEPRINTS_TEST_DIR = T.let(T.unsafe(nil), String)

# Controller files
AnnotateModels::FilePatterns::CONTROLLER_DIR = T.let(T.unsafe(nil), String)

AnnotateModels::FilePatterns::CONTROLLER_SPEC_DIR = T.let(T.unsafe(nil), String)

# Other test files
AnnotateModels::FilePatterns::CONTROLLER_TEST_DIR = T.let(T.unsafe(nil), String)

AnnotateModels::FilePatterns::EXEMPLARS_SPEC_DIR = T.let(T.unsafe(nil), String)

# Object Daddy http://github.com/flogic/object_daddy/tree/master
AnnotateModels::FilePatterns::EXEMPLARS_TEST_DIR = T.let(T.unsafe(nil), String)

AnnotateModels::FilePatterns::FABRICATORS_SPEC_DIR = T.let(T.unsafe(nil), String)

# Fabrication https://github.com/paulelliott/fabrication.git
AnnotateModels::FilePatterns::FABRICATORS_TEST_DIR = T.let(T.unsafe(nil), String)

AnnotateModels::FilePatterns::FACTORY_BOT_SPEC_DIR = T.let(T.unsafe(nil), String)

# Factory Bot https://github.com/thoughtbot/factory_bot
AnnotateModels::FilePatterns::FACTORY_BOT_TEST_DIR = T.let(T.unsafe(nil), String)

AnnotateModels::FilePatterns::FIXTURE_SPEC_DIR = T.let(T.unsafe(nil), String)
AnnotateModels::FilePatterns::FIXTURE_TEST_DIR = T.let(T.unsafe(nil), String)

# Helper files
AnnotateModels::FilePatterns::HELPER_DIR = T.let(T.unsafe(nil), String)

# since rails 4.0
AnnotateModels::FilePatterns::MODEL_TEST_DIR = T.let(T.unsafe(nil), String)

AnnotateModels::FilePatterns::REQUEST_SPEC_DIR = T.let(T.unsafe(nil), String)
AnnotateModels::FilePatterns::ROUTING_SPEC_DIR = T.let(T.unsafe(nil), String)

# Serializers https://github.com/rails-api/active_model_serializers
AnnotateModels::FilePatterns::SERIALIZERS_DIR = T.let(T.unsafe(nil), String)

AnnotateModels::FilePatterns::SERIALIZERS_SPEC_DIR = T.let(T.unsafe(nil), String)
AnnotateModels::FilePatterns::SERIALIZERS_TEST_DIR = T.let(T.unsafe(nil), String)
AnnotateModels::FilePatterns::SPEC_MODEL_DIR = T.let(T.unsafe(nil), String)

# File.join for windows reverse bar compat?
# I dont use windows, can`t test
AnnotateModels::FilePatterns::UNIT_TEST_DIR = T.let(T.unsafe(nil), String)

AnnotateModels::INDEX_CLAUSES = T.let(T.unsafe(nil), Hash)
AnnotateModels::MAGIC_COMMENT_MATCHER = T.let(T.unsafe(nil), Regexp)
AnnotateModels::MATCHED_TYPES = T.let(T.unsafe(nil), Array)

# Don't show default value for these column types
AnnotateModels::NO_DEFAULT_COL_TYPES = T.let(T.unsafe(nil), Array)

# Don't show limit (#) on these column types
# Example: show "integer" instead of "integer(4)"
AnnotateModels::NO_LIMIT_COL_TYPES = T.let(T.unsafe(nil), Array)

AnnotateModels::PREFIX = T.let(T.unsafe(nil), String)
AnnotateModels::PREFIX_MD = T.let(T.unsafe(nil), String)
AnnotateModels::SKIP_ANNOTATION_PREFIX = T.let(T.unsafe(nil), String)

module AnnotateRoutes
  class << self
    def do_annotations(options = T.unsafe(nil)); end
    def remove_annotations(_options = T.unsafe(nil)); end

    private

    def annotate_routes(header, content, header_position, options = T.unsafe(nil)); end
    def rewrite_contents(existing_text, new_text); end
    def routes_file; end

    # @return [Boolean]
    def routes_file_exist?; end

    def strip_on_removal(content, header_position); end
  end
end

class AnnotateRoutes::HeaderGenerator
  # @return [HeaderGenerator] a new instance of HeaderGenerator
  def initialize(options, routes_map); end

  def generate; end

  private

  def comment(row = T.unsafe(nil)); end
  def content(line, maxs); end
  def format_line_element(elem, maxs, index); end

  # @return [Boolean]
  def markdown?; end

  # Returns the value of attribute options.
  def options; end

  # Returns the value of attribute routes_map.
  def routes_map; end

  def timestamp_if_required(time = T.unsafe(nil)); end

  class << self
    def generate(options = T.unsafe(nil)); end

    private

    def routes_map(options); end
  end
end

AnnotateRoutes::HeaderGenerator::HEADER_ROW = T.let(T.unsafe(nil), Array)
AnnotateRoutes::HeaderGenerator::PREFIX = T.let(T.unsafe(nil), String)
AnnotateRoutes::HeaderGenerator::PREFIX_MD = T.let(T.unsafe(nil), String)

module AnnotateRoutes::Helpers
  class << self
    # @param content [Array<String>]
    # @return [Array<String>] all found magic comments
    # @return [Array<String>] content without magic comments
    def extract_magic_comments_from_array(content_array); end

    # TODO: write the method doc using ruby rdoc formats
    # This method returns an array of 'real_content' and 'header_position'.
    # 'header_position' will either be :before, :after, or
    # a number.  If the number is > 0, the
    # annotation was found somewhere in the
    # middle of the file.  If the number is
    # zero, no annotation was found.
    def strip_annotations(content); end

    private

    def real_content_and_header_position(real_content, header_position); end
  end
end

AnnotateRoutes::Helpers::MAGIC_COMMENT_MATCHER = T.let(T.unsafe(nil), Regexp)
