# typed: true

# DO NOT EDIT MANUALLY
# This is an autogenerated file for types exported from the `representable` gem.
# Please instead update this file by running `bin/tapioca gem representable`.

# NOTE: this might become a separate class, that's why it's in a separate file.
module Representable
  mixes_in_class_methods ::Representable::Declarative
  mixes_in_class_methods ::Declarative::Heritage::Included
  mixes_in_class_methods ::Declarative::Heritage::Inherited
  mixes_in_class_methods ::Representable::ModuleExtensions
  mixes_in_class_methods ::Representable::ClassMethods
  mixes_in_class_methods ::Representable::ForCollection
  mixes_in_class_methods ::Representable::Represent

  # Sets the attribute representable_attrs
  #
  # @param value the value to set the attribute representable_attrs to.
  def representable_attrs=(_arg0); end

  private

  # Compiles the document going through all properties.
  def create_representation_with(doc, options, format); end

  def normalize_options(user_options: T.unsafe(nil), **options); end
  def representable_attrs; end
  def representable_bindings_for(format, options); end
  def representable_map(options, format); end
  def representable_map!(doc, options, format, method); end
  def representation_wrap(options = T.unsafe(nil)); end
  def represented; end

  # Reads values from +doc+ and sets properties accordingly.
  def update_properties_from(doc, options, format); end

  class << self
    def Option(value); end

    # @private
    def included(base); end
  end
end

Representable::As = T.let(T.unsafe(nil), Proc)

# Warning: don't rely on AssignAs/AssignName, i am not sure if i leave that as functions.
Representable::AssignAs = T.let(T.unsafe(nil), Proc)

# Deprecation strategy:
# binding.evaluate_option_with_deprecation(:reader, options, :doc)
#   => binding.evaluate_option(:reader, options) # always pass in options.
Representable::AssignFragment = T.let(T.unsafe(nil), Proc)

Representable::AssignName = T.let(T.unsafe(nil), Proc)

# The Binding provides methods to read/write the fragment for one property.
#
# Actually parsing the fragment from the document happens in Binding#read, everything after that is generic.
class Representable::Binding
  include ::Representable::Binding::Deprecatable
  include ::Representable::Binding::EvaluateOption
  include ::Representable::Binding::Factories
  extend ::Uber::Delegates

  # @return [Binding] a new instance of Binding
  def initialize(definition); end

  def [](name); end

  # Returns the value of attribute cached_representer.
  def cached_representer; end

  # Sets the attribute cached_representer
  #
  # @param value the value to set the attribute cached_representer to.
  def cached_representer=(_arg0); end

  def default_for(value); end

  # Returns the value of attribute getter.
  def getter; end

  # Returns the value of attribute name.
  def name; end

  # Returns the value of attribute setter.
  def setter; end

  # @return [Boolean]
  def skipable_empty_value?(value); end

  private

  def exec_context(options); end
  def parse_pipeline(input, options); end
  def render_pipeline(input, options); end
  def setup_exec_context!; end

  class << self
    def build(definition); end
  end
end

# generics for collection bindings.
module Representable::Binding::Collection
  # @return [Boolean]
  def skipable_empty_value?(value); end
end

# Single entry points for rendering and parsing a property are #compile_fragment
# and #uncompile_fragment in Mapper.
module Representable::Binding::Deprecatable
  # Retrieve value and write fragment to the doc.
  def compile_fragment(options); end

  # Parse value from doc and update the model property.
  def uncompile_fragment(options); end
end

module Representable::Binding::EvaluateOption
  def evaluate_option(name, input, options); end
end

module Representable::Binding::Factories
  # i decided not to use polymorphism here for the sake of clarity.
  def collect_for(item_functions); end

  def default_parse_fragment_functions; end
  def default_parse_init_functions; end
  def default_post_functions; end
  def default_render_fragment_functions; end
  def default_render_init_functions; end
  def parse_functions; end
  def pipeline_for(name, input, options); end

  # DISCUSS: StopOnNil, before collect
  def render_functions; end
end

class Representable::Binding::FragmentNotFound; end

class Representable::Binding::Map < ::Array
  # TODO: Merge with Definitions.
  def <<(binding); end

  def call(method, options); end
end

# Using this module only makes sense with Decorator representers.
module Representable::Cached
  mixes_in_class_methods ::Representable::Cached::BuildDefinition

  def representable_map(*_arg0); end

  class << self
    # @private
    def included(includer); end
  end
end

module Representable::Cached::BuildDefinition
  def build_definition(*_arg0); end
end

module Representable::ClassMethods
  def prepare(represented); end
end

# Collect applies a pipeline to each element of input.
class Representable::Collect < ::Representable::Pipeline
  # when stop, the element is skipped. (should that be Skip then?)
  def call(input, options); end
end

class Representable::Collect::Hash < ::Representable::Pipeline
  def call(input, options); end
end

# Stores Definitions from ::property. It preserves the adding order (1.9+).
# Same-named properties get overridden, just like in a Hash.
#
# Overwrite definition_class if you need a custom Definition object (helpful when using
# representable in other gems).
class Representable::Config < ::Declarative::Definitions
  # @return [Config] a new instance of Config
  def initialize(*_arg0); end

  # FIXME: this is not inherited.
  def options; end

  def remove(name); end
  def wrap=(value); end

  # Computes the wrap string or returns false.
  def wrap_for(represented, options = T.unsafe(nil), &block); end

  private

  def infer_name_for(name); end
end

module Representable::CreateObject; end
Representable::CreateObject::Class = T.let(T.unsafe(nil), Proc)
Representable::CreateObject::Instance = T.let(T.unsafe(nil), Proc)

# FIXME: no additional args passed here, yet.
Representable::CreateObject::Populator = T.let(T.unsafe(nil), Proc)

module Representable::Declarative
  include ::Declarative::Schema::DSL
  include ::Declarative::Schema::Feature
  include ::Declarative::Heritage::DSL

  def collection(name, options = T.unsafe(nil), &block); end
  def default_nested_class; end
  def definitions; end
  def hash(name = T.unsafe(nil), options = T.unsafe(nil), &block); end

  # Allows you to nest a block of properties in a separate section while still mapping
  # them to the original object.
  def nested(name, options = T.unsafe(nil), &block); end

  def nested_builder; end
  def representable_attrs; end
  def representation_wrap=(name); end
end

Representable::Declarative::NestedBuilder = T.let(T.unsafe(nil), Proc)
Representable::Decorate = T.let(T.unsafe(nil), Representable::Function::Decorate)

class Representable::Decorator
  include ::Representable
  include ::Representable::Cached
  extend ::Declarative::Schema::DSL
  extend ::Declarative::Schema::Feature
  extend ::Declarative::Heritage::DSL
  extend ::Representable::Declarative
  extend ::Declarative::Heritage::Included
  extend ::Declarative::Heritage::Inherited
  extend ::Representable::ModuleExtensions
  extend ::Representable::ClassMethods
  extend ::Representable::ForCollection
  extend ::Representable::Represent
  extend ::Representable::Cached::BuildDefinition
  extend ::Uber::InheritableAttr

  # @return [Decorator] a new instance of Decorator
  def initialize(represented); end

  # Returns the value of attribute represented.
  def decorated; end

  # Returns the value of attribute represented.
  def represented; end

  class << self
    # This is called from inheritable_attr when inheriting a decorator class to a subclass.
    # Explicitly subclassing the Decorator makes sure representable_attrs is a clean version.
    def clone; end

    # FIXME. SHOULD we move that into NestedBuilder?
    def default_nested_class; end

    def map; end
    def map=(v); end
    def nested_builder; end

    # TODO: when moving all class methods into ClassMethods, i get a segfault.
    def prepare(represented); end
  end
end

Representable::Default = T.let(T.unsafe(nil), Proc)

# Created at class compile time. Keeps configuration options for one property.
class Representable::Definition < ::Declarative::Definitions::Definition
  # @return [Definition] a new instance of Definition
  def initialize(sym, options = T.unsafe(nil), &block); end

  def [](name); end

  # @return [Boolean]
  def array?; end

  def create_binding(*args); end
  def delete!(name); end
  def getter; end

  # @return [Boolean]
  def has_default?; end

  # @return [Boolean]
  def hash?; end

  def inspect; end
  def merge!(options, &block); end
  def name; end

  # @return [Boolean]
  def representable?; end

  def representer_module; end
  def setter; end

  # TODO: remove.
  #
  # @return [Boolean]
  def typed?; end

  private

  def dynamic_options; end
  def handle_as!(options); end
  def handle_extend!(options); end

  # wrapping dynamic options in Value does save runtime, as this is used very frequently (and totally unnecessary to wrap an option
  # at runtime, its value never changes).
  def runtime_options!(options); end

  # @yield [options]
  def setup!(options, &block); end
end

Representable::Deserialize = T.let(T.unsafe(nil), Proc)
class Representable::DeserializeError < ::RuntimeError; end
Representable::Deserializer = T.let(T.unsafe(nil), Proc)
Representable::FindOrInstantiate = T.let(T.unsafe(nil), Proc)

# Gives us Representer::for_collection and its configuration directive
# ::collection_representer.
module Representable::ForCollection
  def for_collection; end

  private

  def collection_representer(options = T.unsafe(nil)); end
  def collection_representer!(options); end
end

module Representable::Function; end

class Representable::Function::Decorate
  def call(object, options); end
  def prepare_for(mod, object, binding); end
end

class Representable::Function::Prepare
  def call(input, options); end
end

Representable::GetValue = T.let(T.unsafe(nil), Proc)
Representable::Getter = T.let(T.unsafe(nil), Proc)

# The generic representer. Brings #to_hash and #from_hash to your object.
# If you plan to write your own representer for a new media type, try to use this module (e.g., check how JSON reuses Hash's internal
# architecture).
module Representable::Hash
  include ::Representable

  mixes_in_class_methods ::Representable::Declarative
  mixes_in_class_methods ::Declarative::Heritage::Included
  mixes_in_class_methods ::Declarative::Heritage::Inherited
  mixes_in_class_methods ::Representable::ModuleExtensions
  mixes_in_class_methods ::Representable::ClassMethods
  mixes_in_class_methods ::Representable::ForCollection
  mixes_in_class_methods ::Representable::Represent
  mixes_in_class_methods ::Representable::Hash::ClassMethods

  def from_hash(data, options = T.unsafe(nil), binding_builder = T.unsafe(nil)); end
  def parse(data, options = T.unsafe(nil), binding_builder = T.unsafe(nil)); end
  def render(options = T.unsafe(nil), binding_builder = T.unsafe(nil)); end
  def to_hash(options = T.unsafe(nil), binding_builder = T.unsafe(nil)); end

  private

  def filter_wrap(data, options); end
  def filter_wrap_for(data, wrap); end

  class << self
    # @private
    def included(base); end
  end
end

module Representable::Hash::AllowSymbols
  private

  def filter_wrap_for(data, *args); end
  def update_properties_from(data, *args); end
end

class Representable::Hash::Binding < ::Representable::Binding
  def deserialize_method; end
  def read(hash, as); end
  def serialize_method; end
  def write(hash, fragment, as); end

  class << self
    def build_for(definition); end
  end
end

class Representable::Hash::Binding::Collection < ::Representable::Hash::Binding
  include ::Representable::Binding::Collection
end

module Representable::Hash::ClassMethods
  def collection_representer_class; end
  def format_engine; end
end

module Representable::Hash::Collection
  include ::Representable::Hash
  include ::Representable
  extend ::Declarative::Schema::DSL
  extend ::Declarative::Schema::Feature
  extend ::Declarative::Heritage::DSL
  extend ::Representable::Declarative
  extend ::Declarative::Heritage::Included
  extend ::Declarative::Heritage::Inherited
  extend ::Representable::ModuleExtensions
  extend ::Representable::ClassMethods
  extend ::Representable::ForCollection
  extend ::Representable::Represent
  extend ::Representable::Hash::ClassMethods
  include ::Representable
  include ::Representable::Hash

  mixes_in_class_methods ::Representable::Declarative
  mixes_in_class_methods ::Declarative::Heritage::Included
  mixes_in_class_methods ::Declarative::Heritage::Inherited
  mixes_in_class_methods ::Representable::ModuleExtensions
  mixes_in_class_methods ::Representable::ClassMethods
  mixes_in_class_methods ::Representable::ForCollection
  mixes_in_class_methods ::Representable::Represent
  mixes_in_class_methods ::Representable::Hash::ClassMethods
  mixes_in_class_methods ::Representable::Hash::Collection::ClassMethods

  # TODO: revise lonely collection and build separate pipeline where we just use Serialize, etc.
  def create_representation_with(doc, options, format); end

  def update_properties_from(doc, options, format); end

  class << self
    # @private
    def included(base); end
  end
end

module Representable::Hash::Collection::ClassMethods
  def items(options = T.unsafe(nil), &block); end
end

module Representable::Hash::Conversion
  class << self
    def stringify_keys(hash); end
  end
end

module Representable::HashMethods
  def create_representation_with(doc, options, format); end
  def update_properties_from(doc, options, format); end

  private

  def filter_keys_for!(hash, options); end
end

Representable::If = T.let(T.unsafe(nil), Proc)

# Brings #to_json and #from_json to your object.
module Representable::JSON
  include ::Representable::Hash
  include ::Representable
  extend ::Representable::Hash::ClassMethods
  extend ::Declarative::Schema::DSL
  extend ::Declarative::Schema::Feature
  extend ::Declarative::Heritage::DSL
  extend ::Representable::Declarative
  extend ::Declarative::Heritage::Included
  extend ::Declarative::Heritage::Inherited
  extend ::Representable::ModuleExtensions
  extend ::Representable::ClassMethods
  extend ::Representable::ForCollection
  extend ::Representable::Represent
  include ::Representable

  mixes_in_class_methods ::Representable::Declarative
  mixes_in_class_methods ::Declarative::Heritage::Included
  mixes_in_class_methods ::Declarative::Heritage::Inherited
  mixes_in_class_methods ::Representable::ModuleExtensions
  mixes_in_class_methods ::Representable::ClassMethods
  mixes_in_class_methods ::Representable::ForCollection
  mixes_in_class_methods ::Representable::Represent
  mixes_in_class_methods ::Representable::JSON::ClassMethods

  # Parses the body as JSON and delegates to #from_hash.
  def from_json(data, *args); end

  # Parses the body as JSON and delegates to #from_hash.
  def parse(data, *args); end

  # Returns a JSON string representing this object.
  def render(*args); end

  # Returns a JSON string representing this object.
  def to_json(*args); end

  class << self
    # @private
    def included(base); end
  end
end

module Representable::JSON::ClassMethods
  def collection_representer_class; end
  def format_engine; end
end

module Representable::JSON::Collection
  include ::Representable::Hash
  include ::Representable
  include ::Representable::JSON
  extend ::Declarative::Schema::DSL
  extend ::Declarative::Schema::Feature
  extend ::Declarative::Heritage::DSL
  extend ::Representable::Declarative
  extend ::Declarative::Heritage::Included
  extend ::Declarative::Heritage::Inherited
  extend ::Representable::ModuleExtensions
  extend ::Representable::ClassMethods
  extend ::Representable::ForCollection
  extend ::Representable::Represent
  extend ::Representable::JSON::ClassMethods
  include ::Representable
  include ::Representable::Hash
  include ::Representable::Hash::Collection

  mixes_in_class_methods ::Representable::Declarative
  mixes_in_class_methods ::Declarative::Heritage::Included
  mixes_in_class_methods ::Declarative::Heritage::Inherited
  mixes_in_class_methods ::Representable::ModuleExtensions
  mixes_in_class_methods ::Representable::ClassMethods
  mixes_in_class_methods ::Representable::ForCollection
  mixes_in_class_methods ::Representable::Represent
  mixes_in_class_methods ::Representable::Hash::ClassMethods
  mixes_in_class_methods ::Representable::Hash::Collection::ClassMethods

  class << self
    # @private
    def included(base); end
  end
end

# "Lonely Hash" support.
module Representable::JSON::Hash
  include ::Representable
  include ::Representable::JSON
  include ::Representable::HashMethods

  mixes_in_class_methods ::Representable::Declarative
  mixes_in_class_methods ::Declarative::Heritage::Included
  mixes_in_class_methods ::Declarative::Heritage::Inherited
  mixes_in_class_methods ::Representable::ModuleExtensions
  mixes_in_class_methods ::Representable::ClassMethods
  mixes_in_class_methods ::Representable::ForCollection
  mixes_in_class_methods ::Representable::Represent
  mixes_in_class_methods ::Representable::JSON::Hash::ClassMethods
  mixes_in_class_methods ::Representable::JSON::ClassMethods

  class << self
    # @private
    def included(base); end
  end
end

module Representable::JSON::Hash::ClassMethods
  def values(options, &block); end
end

module Representable::ModuleExtensions
  # Copies the representable_attrs reference to the extended object.
  # Note that changing attrs in the instance will affect the class configuration.
  def extended(object); end
end

module Representable::Object
  include ::Representable

  mixes_in_class_methods ::Representable::Declarative
  mixes_in_class_methods ::Declarative::Heritage::Included
  mixes_in_class_methods ::Declarative::Heritage::Inherited
  mixes_in_class_methods ::Representable::ModuleExtensions
  mixes_in_class_methods ::Representable::ClassMethods
  mixes_in_class_methods ::Representable::ForCollection
  mixes_in_class_methods ::Representable::Represent
  mixes_in_class_methods ::Representable::Object::ClassMethods

  def from_object(data, options = T.unsafe(nil), binding_builder = T.unsafe(nil)); end
  def to_object(options = T.unsafe(nil), binding_builder = T.unsafe(nil)); end

  class << self
    # @private
    def included(base); end
  end
end

class Representable::Object::Binding < ::Representable::Binding
  def deserialize_method; end
  def read(hash, as); end
  def serialize_method; end
  def write(hash, fragment, as); end

  class << self
    # TODO: remove default arg.
    def build_for(definition); end
  end
end

class Representable::Object::Binding::Collection < ::Representable::Object::Binding
  include ::Representable::Binding::Collection
end

module Representable::Object::ClassMethods
  def collection_representer_class; end
end

# Extend `Trailblazer::Option` to support static values as callables too.
class Representable::Option < ::Trailblazer::Option
  class << self
    def build(value); end

    # @return [Boolean]
    def callable?(value); end
  end
end

# Prepares options for a particular nested representer.
# This is used in Serializer and Deserializer.
Representable::OptionsForNested = T.let(T.unsafe(nil), Proc)

Representable::OverwriteOnNil = T.let(T.unsafe(nil), Proc)
Representable::ParseFilter = T.let(T.unsafe(nil), Proc)

# Allows to implement a pipeline of filters where a value gets passed in and the result gets
# passed to the next callable object.
class Representable::Pipeline < ::Array
  extend ::Representable::Pipeline::Macros

  # options is mutable.
  def call(input, options); end

  private

  def evaluate(block, input, options); end
end

module Representable::Pipeline::Function; end

class Representable::Pipeline::Function::Insert
  def call(arr, func, options); end

  private

  def delete!(arr, removed_func); end
  def replace!(arr, old_func, new_func); end
end

Representable::Pipeline::Insert = T.let(T.unsafe(nil), Representable::Pipeline::Function::Insert)

# TODO: explicit test.
module Representable::Pipeline::Macros
  # Macro to quickly modify an array of functions via Pipeline::Insert and return a
  # Pipeline instance.
  def insert(functions, new_function, options); end
end

class Representable::Pipeline::Stop; end

class Representable::Populator
  class << self
    # pipeline: [StopOnExcluded, AssignName, ReadFragment, StopOnNotFound, OverwriteOnNil, AssignFragment, #<Representable::Function::CreateObject:0x9805a44>, #<Representable::Function::Decorate:0x9805a1c>, Deserialize, Set]
    def apply!(options); end
  end
end

Representable::Populator::FindOrInstantiate = T.let(T.unsafe(nil), Proc)

# CreateObject = Function::CreateObject.new
Representable::Prepare = T.let(T.unsafe(nil), Representable::Function::Prepare)

Representable::ReadFragment = T.let(T.unsafe(nil), Proc)
Representable::Reader = T.let(T.unsafe(nil), Proc)

# TODO: evaluate this, if we need this.
Representable::RenderDefault = T.let(T.unsafe(nil), Proc)

Representable::RenderFilter = T.let(T.unsafe(nil), Proc)

module Representable::Represent
  def represent(represented, array_class = T.unsafe(nil)); end
end

Representable::Serialize = T.let(T.unsafe(nil), Proc)
Representable::Serializer = T.let(T.unsafe(nil), Proc)
Representable::SetValue = T.let(T.unsafe(nil), Proc)
Representable::Setter = T.let(T.unsafe(nil), Proc)
Representable::SkipParse = T.let(T.unsafe(nil), Proc)
Representable::SkipRender = T.let(T.unsafe(nil), Proc)
Representable::Stop = T.let(T.unsafe(nil), Proc)
Representable::StopOnExcluded = T.let(T.unsafe(nil), Proc)

# DISCUSS: Not tested/used, yet.
Representable::StopOnNil = T.let(T.unsafe(nil), Proc)

Representable::StopOnNotFound = T.let(T.unsafe(nil), Proc)
Representable::StopOnSkipable = T.let(T.unsafe(nil), Proc)
Representable::WriteFragment = T.let(T.unsafe(nil), Proc)
Representable::Writer = T.let(T.unsafe(nil), Proc)

module Representable::XML
  include ::Representable

  mixes_in_class_methods ::Representable::Declarative
  mixes_in_class_methods ::Declarative::Heritage::Included
  mixes_in_class_methods ::Declarative::Heritage::Inherited
  mixes_in_class_methods ::Representable::ModuleExtensions
  mixes_in_class_methods ::Representable::ClassMethods
  mixes_in_class_methods ::Representable::ForCollection
  mixes_in_class_methods ::Representable::Represent
  mixes_in_class_methods ::Representable::XML::ClassMethods

  def from_node(node, options = T.unsafe(nil)); end
  def from_xml(doc, *args); end
  def parse(doc, *args); end
  def render(*args); end

  # Returns a Nokogiri::XML object representing this object.
  def to_node(options = T.unsafe(nil)); end

  def to_xml(*args); end

  private

  def Node(document, name, attributes = T.unsafe(nil)); end
  def parse_xml(doc, *args); end

  # @return [Boolean]
  def remove_namespaces?; end

  class << self
    def Node(document, name, attributes = T.unsafe(nil)); end

    # @private
    def included(base); end
  end
end

class Representable::XML::Binding < ::Representable::Binding
  def deserialize_from(nodes); end
  def deserialize_method; end
  def read(node, as); end

  # Creates wrapped node for the property.
  def serialize_for(value, parent, as); end

  # DISCUSS: why is this public?
  def serialize_method; end

  def serialize_node(node, value, as); end
  def write(parent, fragments, as); end

  private

  # TODO: move this into a ScalarDecorator.
  def content_for(node); end

  def find_nodes(doc, as); end

  class << self
    def build_for(definition); end
  end
end

# Represents a tag attribute. Currently this only works on the top-level tag.
class Representable::XML::Binding::Attribute < ::Representable::XML::Binding
  def read(node, as); end
  def serialize_for(value, parent, as); end
  def write(parent, value, as); end
end

class Representable::XML::Binding::AttributeHash < ::Representable::XML::Binding::Collection
  # FIXME: this is not tested!
  def deserialize_from(node); end

  # DISCUSS: use AttributeBinding here?
  def write(parent, value, as); end
end

class Representable::XML::Binding::Collection < ::Representable::XML::Binding
  include ::Representable::Binding::Collection

  def deserialize_from(nodes); end
  def serialize_for(value, parent, as); end

  private

  def set_for(parent, nodes); end
end

# Represents tag content.
class Representable::XML::Binding::Content < ::Representable::XML::Binding
  def read(node, as); end
  def serialize_for(value, parent); end
  def write(parent, value, as); end
end

class Representable::XML::Binding::Hash < ::Representable::XML::Binding::Collection
  def deserialize_from(nodes); end
  def serialize_for(value, parent, as); end
end

module Representable::XML::ClassMethods
  def collection_representer_class; end
  def format_engine; end
  def remove_namespaces!; end
end

module Representable::XML::Collection
  include ::Representable
  include ::Representable::XML
  include ::Representable::Hash
  include ::Representable::Hash::Collection
  include ::Representable::XML::Collection::Methods

  mixes_in_class_methods ::Representable::Declarative
  mixes_in_class_methods ::Declarative::Heritage::Included
  mixes_in_class_methods ::Declarative::Heritage::Inherited
  mixes_in_class_methods ::Representable::ModuleExtensions
  mixes_in_class_methods ::Representable::ClassMethods
  mixes_in_class_methods ::Representable::ForCollection
  mixes_in_class_methods ::Representable::Represent
  mixes_in_class_methods ::Representable::XML::ClassMethods
  mixes_in_class_methods ::Representable::Hash::ClassMethods
  mixes_in_class_methods ::Representable::Hash::Collection::ClassMethods

  class << self
    # @private
    def included(base); end
  end
end

module Representable::XML::Collection::Methods
  def create_representation_with(doc, options, format); end
  def update_properties_from(doc, *args); end
end

# Experimental!
# Best explanation so far: http://books.xmlschemata.org/relaxng/relax-CHP-11-SECT-1.html
#
# Note: This module doesn't work with JRuby because Nokogiri uses a completely
# different implementation in Java which has other requirements that we couldn't fulfil.
# Please wait for Representable 4 where we replace Nokogiri with Oga.
module Representable::XML::Namespace
  mixes_in_class_methods ::Representable::XML::Namespace::DSL

  # "Physically" add `xmlns` attributes to `node`.
  def add_namespace_definitions!(node, namespaces); end

  # FIXME: some "bug" in Representable's XML doesn't consider the container tag, so we could theoretically pick the
  # wrong namespaced tag here :O
  def from_node(node, options = T.unsafe(nil)); end

  # FIXME: this is a PoC, we need a better API to inject code.
  def representable_map(options, format); end

  def to_node(options = T.unsafe(nil)); end

  class << self
    def Namespaced(prefix, name); end

    # @private
    def included(includer); end
  end
end

module Representable::XML::Namespace::AsWithNamespace
  # FIXME: this is shit, the NestedOptions is executed too late here!
  def read(node, as); end

  def write(doc, fragment, as); end

  private

  def prefixed(dfn, as); end
end

module Representable::XML::Namespace::DSL
  def namespace(namespace); end
  def namespace_def(mapping); end

  # :private:
  def namespace_defs; end

  def property(name, options = T.unsafe(nil)); end

  # :private:
  # super ugly hack
  # recursively injects the namespace_defs into all representers of this tree. will be done better in 4.0.
  def update_namespace_defs!(namespace_defs); end
end

module Representable::YAML
  include ::Representable::Hash
  include ::Representable
  extend ::Declarative::Schema::DSL
  extend ::Declarative::Schema::Feature
  extend ::Declarative::Heritage::DSL
  extend ::Representable::Declarative
  extend ::Declarative::Heritage::Included
  extend ::Declarative::Heritage::Inherited
  extend ::Representable::ModuleExtensions
  extend ::Representable::ClassMethods
  extend ::Representable::ForCollection
  extend ::Representable::Represent
  extend ::Representable::Hash::ClassMethods
  include ::Representable

  mixes_in_class_methods ::Representable::Declarative
  mixes_in_class_methods ::Declarative::Heritage::Included
  mixes_in_class_methods ::Declarative::Heritage::Inherited
  mixes_in_class_methods ::Representable::ModuleExtensions
  mixes_in_class_methods ::Representable::ClassMethods
  mixes_in_class_methods ::Representable::ForCollection
  mixes_in_class_methods ::Representable::Represent
  mixes_in_class_methods ::Representable::YAML::ClassMethods

  def from_yaml(doc, options = T.unsafe(nil)); end
  def parse(doc, options = T.unsafe(nil)); end
  def render(*args); end

  # Returns a Nokogiri::XML object representing this object.
  def to_ast(options = T.unsafe(nil)); end

  def to_yaml(*args); end

  class << self
    # @private
    def included(base); end
  end
end

class Representable::YAML::Binding < ::Representable::Hash::Binding
  def deserialize_method; end

  # private
  def node_for(fragment); end

  def serialize_method; end
  def write(map, fragment, as); end
  def write_scalar(value); end

  class << self
    def build_for(definition); end
  end
end

class Representable::YAML::Binding::Collection < ::Representable::YAML::Binding
  include ::Representable::Binding::Collection

  def node_for(fragments); end
end

module Representable::YAML::ClassMethods
  def format_engine; end
end
