# typed: true

# DO NOT EDIT MANUALLY
# This is an autogenerated file for types exported from the `dry-auto_inject` gem.
# Please instead update this file by running `bin/tapioca gem dry-auto_inject`.

module Dry
  class << self
    # Configure an auto-injection module
    #
    # @api public
    # @example
    #   module MyApp
    #   # set up your container
    #   container = Dry::Container.new
    #
    #   container.register(:data_store, -> { DataStore.new })
    #   container.register(:user_repository, -> { container[:data_store][:users] })
    #   container.register(:persist_user, -> { PersistUser.new })
    #
    #   # set up your auto-injection function
    #   AutoInject = Dry::AutoInject(container)
    #
    #   # define your injection function
    #   def self.Inject(*keys)
    #   AutoInject[*keys]
    #   end
    #   end
    #
    #   # then simply include it in your class providing which dependencies should be
    #   # injected automatically from the configured container
    #   class PersistUser
    #   include MyApp::Inject(:user_repository)
    #
    #   def call(user)
    #   user_repository << user
    #   end
    #   end
    #
    #   persist_user = container[:persist_user]
    #
    #   persist_user.call(name: 'Jane')
    # @return [Proc] calling the returned proc builds an auto-injection module
    def AutoInject(container, options = T.unsafe(nil)); end

    def Equalizer(*keys, **options); end
  end
end

module Dry::AutoInject; end

class Dry::AutoInject::Builder
  # @return [Builder] a new instance of Builder
  def initialize(container, options = T.unsafe(nil)); end

  # @api public
  def [](*dependency_names); end

  # @api private
  def container; end

  # @api private
  def strategies; end

  private

  def method_missing(name, *args, &block); end

  # @return [Boolean]
  def respond_to_missing?(name, _include_private = T.unsafe(nil)); end
end

class Dry::AutoInject::DependencyMap
  # @return [DependencyMap] a new instance of DependencyMap
  def initialize(*dependencies); end

  def inspect; end
  def names; end
  def to_h; end
  def to_hash; end

  private

  # @raise [DuplicateDependencyError]
  def add_dependency(name, identifier); end

  def name_for(identifier); end
end

class Dry::AutoInject::DependencyNameInvalid < ::StandardError; end
class Dry::AutoInject::DuplicateDependencyError < ::StandardError; end

class Dry::AutoInject::Injector < ::BasicObject
  # @api private
  # @return [Injector] a new instance of Injector
  def initialize(container, strategy, builder:); end

  def [](*dependency_names); end

  # @api private
  def builder; end

  # @api private
  def container; end

  def respond_to?(*_arg0); end

  # @api private
  def strategy; end

  private

  def method_missing(name, *_args); end

  # @return [Boolean]
  def respond_to_missing?(name, _include_private = T.unsafe(nil)); end
end

# @api private
class Dry::AutoInject::MethodParameters
  # @api private
  # @return [MethodParameters] a new instance of MethodParameters
  def initialize(parameters); end

  # @api private
  # @return [Boolean]
  def empty?; end

  # @api private
  # @return [Boolean]
  def keyword?(name); end

  # @api private
  def keyword_names; end

  # @api private
  def length; end

  # @api private
  def parameters; end

  # @api private
  # @return [Boolean]
  def pass_through?; end

  # @api private
  # @return [Boolean]
  def sequential_arguments?; end

  # @api private
  # @return [Boolean]
  def splat?; end

  class << self
    # @api private
    def of(obj, name); end
  end
end

# @api private
Dry::AutoInject::MethodParameters::EMPTY = T.let(T.unsafe(nil), Dry::AutoInject::MethodParameters)

# @api private
Dry::AutoInject::MethodParameters::PASS_THROUGH = T.let(T.unsafe(nil), Array)

class Dry::AutoInject::Strategies
  extend ::Dry::Container::Mixin
  extend ::Dry::Core::Constants
  extend ::Dry::Configurable
  extend ::Dry::Configurable::Methods
  extend ::Dry::Configurable::ClassMethods

  class << self
    # @api public
    def register_default(name, strategy); end
  end
end

# @api private
class Dry::AutoInject::Strategies::Args < ::Dry::AutoInject::Strategies::Constructor
  private

  # @api private
  def define_initialize(klass); end

  # @api private
  def define_initialize_with_params; end

  # @api private
  def define_initialize_with_splat(super_parameters); end

  # @api private
  def define_new; end
end

class Dry::AutoInject::Strategies::Constructor < ::Module
  # @return [Constructor] a new instance of Constructor
  def initialize(container, *dependency_names); end

  # Returns the value of attribute class_mod.
  def class_mod; end

  # Returns the value of attribute container.
  def container; end

  # Returns the value of attribute dependency_map.
  def dependency_map; end

  # @api private
  def included(klass); end

  # Returns the value of attribute instance_mod.
  def instance_mod; end

  private

  # @raise [NotImplementedError]
  def define_initialize(_klass); end

  # @raise [NotImplementedError]
  def define_new; end

  def define_readers; end
end

class Dry::AutoInject::Strategies::Constructor::ClassMethods < ::Module; end
class Dry::AutoInject::Strategies::Constructor::InstanceMethods < ::Module; end

# @api private
class Dry::AutoInject::Strategies::Hash < ::Dry::AutoInject::Strategies::Constructor
  private

  # @api private
  def define_initialize(klass); end

  # @api private
  def define_new; end
end

# @api private
class Dry::AutoInject::Strategies::Kwargs < ::Dry::AutoInject::Strategies::Constructor
  private

  # @api private
  def assign_dependencies(kwargs, destination); end

  # @api private
  def define_initialize(klass); end

  # @api private
  def define_initialize_with_keywords(super_parameters); end

  # @api private
  def define_initialize_with_splat(super_parameters); end

  # @api private
  def define_new; end

  # @api private
  def slice_kwargs(kwargs, super_parameters); end
end

Dry::AutoInject::VALID_NAME = T.let(T.unsafe(nil), Regexp)
