# typed: true

# DO NOT EDIT MANUALLY
# This is an autogenerated file for types exported from the `declarative` gem.
# Please instead update this file by running `bin/tapioca gem declarative`.

module Declarative; end

module Declarative::DeepDup
  class << self
    def call(args); end
    def dup_items(arr); end
  end
end

# {Defaults} is a mutable DSL object that collects default directives via #merge!.
# Internally, it uses {Variables} to implement the merging of defaults.
class Declarative::Defaults
  # @return [Defaults] a new instance of Defaults
  def initialize; end

  # Evaluate defaults and merge given_options into them.
  def call(name, given_options); end

  def handle_array_and_deprecate(variables); end

  # Set default values. Usually called in Schema::defaults.
  # This can be called multiple times and will "deep-merge" arrays, e.g. `_features: []`.
  def merge!(hash = T.unsafe(nil), &block); end

  class << self
    # Wrap arrays in `variables` with Variables::Append so they get appended to existing
    # same-named arrays.
    def wrap_arrays(variables); end
  end
end

class Declarative::Definitions < ::Hash
  # @return [Definitions] a new instance of Definitions
  def initialize(definition_class); end

  # #add is high-level behavior for Definitions#[]=.
  # reserved options:
  #   :_features
  #   :_defaults
  #   :_base
  #   :_nested_builder
  def add(name, options = T.unsafe(nil), &block); end

  # TODO : test me!
  def each(&block); end

  def get(name); end

  private

  # Run builder to create nested schema (or twin, or representer, or whatever).
  def build_nested(options); end
end

class Declarative::Definitions::Definition
  # @return [Definition] a new instance of Definition
  def initialize(name, options = T.unsafe(nil)); end

  def [](name); end

  # TODO: should be called #copy.
  def merge(hash); end

  # TODO: this should return a new Definition instance.
  def merge!(hash); end
end

class Declarative::Heritage < ::Array
  # Replay the recorded assignments on inheritor.
  # Accepts a block that will allow processing the arguments for every recorded statement.
  def call(inheritor, &block); end

  # Record inheritable assignments for replay in an inheriting class.
  def record(method, *args, &block); end

  private

  # @yield [cfg]
  def call!(inheritor, cfg); end
end

module Declarative::Heritage::DSL
  def heritage; end
end

# To be included into modules using Heritage. When included, inherits the heritage.
module Declarative::Heritage::Included
  def included(mod); end
end

# To be extended into classes using Heritage. Inherits the heritage.
module Declarative::Heritage::Inherited
  def inherited(subclass); end
end

# Include this to maintain inheritable, nested schemas with ::defaults and
# ::feature the way we have it in Representable, Reform, and Disposable.
#
# The schema with its defnitions will be kept in ::definitions.
#
# Requirements to includer: ::default_nested_class, override building with ::nested_builder.
module Declarative::Schema
  class << self
    # @private
    def extended(extender); end
  end
end

module Declarative::Schema::DSL
  def defaults(options = T.unsafe(nil), &block); end

  # TODO: test me.
  def definition_class; end

  def definitions; end
  def property(name, options = T.unsafe(nil), &block); end

  private

  def _defaults; end
  def build_definition(name, options = T.unsafe(nil), &block); end
  def nested_builder; end

  # When called, executes `block` and wraps all array values in Variables::Append.
  # This is the default behavior in older versions and allows to provide arrays for
  # default values that will be prepended.
  def wrap_arrays_from_block(block); end
end

Declarative::Schema::DSL::NestedBuilder = T.let(T.unsafe(nil), Proc)

module Declarative::Schema::Feature
  # features are registered as defaults using _features, which in turn get translated to
  # Class.new... { feature mod } which makes it recursive in nested schemas.
  def feature(*mods); end

  private

  def register_feature(mod); end
end

# Implements the pattern of maintaining a hash of key/values (usually "defaults")
# that are mutated several times by user and library code (override defaults).
#
# The Variables instance then represents the configuration data to be processed by the
# using library (e.g. Representable or Trailblazer).
class Declarative::Variables
  class << self
    def Append(appended_array); end
    def Merge(merged_hash); end

    # @return Hash hash where `overrides` is merged onto `defaults` respecting Merge, Append etc.
    def merge(defaults, overrides); end
  end
end

class Declarative::Variables::Proc < ::Proc; end
