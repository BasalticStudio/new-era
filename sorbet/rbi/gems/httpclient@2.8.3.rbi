# typed: true

# DO NOT EDIT MANUALLY
# This is an autogenerated file for types exported from the `httpclient` gem.
# Please instead update this file by running `bin/tapioca gem httpclient`.

# A namespace module for HTTP Message definitions used by HTTPClient.
module HTTP; end

# Represents a HTTP message.  A message is for a request or a response.
#
# Request message is generated from given parameters internally so users
# don't need to care about it.  Response message is the instance that
# methods of HTTPClient returns so users need to know how to extract
# HTTP response data from Message.
#
# Some attributes are only for a request or a response, not both.
#
# == How to use HTTP response message
#
# 1. Gets response message body.
#
#     res = clnt.get(url)
#     p res.content #=> String
#
# 2. Gets response status code.
#
#     res = clnt.get(url)
#     p res.status #=> 200, 501, etc. (Integer)
#
# 3. Gets response header.
#
#     res = clnt.get(url)
#     res.header['set-cookie'].each do |value|
#       p value
#     end
#     assert_equal(1, res.header['last-modified'].size)
#     p res.header['last-modified'].first
class HTTP::Message
  include ::HTTPClient::Util

  # Creates a Message.  This method should be used internally.
  # Use Message.new_connect_request, Message.new_request or
  # Message.new_response instead.
  #
  # @return [Message] a new instance of Message
  def initialize; end

  # Returns a content of message body.  A String or an IO.
  def body; end

  # Sets a new body.  header.body_size is updated with new body.size.
  def body=(body); end

  # Returns content encoding
  def body_encoding; end

  # Returns HTTP status code in response.  Integer.
  def code; end

  # Returns a content of message body.  A String or an IO.
  def content; end

  # Returns 'Content-Type' header value.
  def content_type; end

  # Sets 'Content-Type' header value.  Overrides if already exists.
  def content_type=(content_type); end

  # Returns 'Content-Type' header value.
  def contenttype; end

  # Sets 'Content-Type' header value.  Overrides if already exists.
  def contenttype=(content_type); end

  # Extracts cookies from 'Set-Cookie' header.
  # Supports 'Set-Cookie' in response header only.
  # Do we need 'Cookie' support in request header?
  def cookies; end

  # Dumps message (header and body) to given dev.
  # dev needs to respond to <<.
  def dump(dev = T.unsafe(nil)); end

  # HTTP::Message::Headers:: message header.
  def header; end

  # Returns Hash of header. key and value are both String. Each key has a
  # single value so you can't extract exact value when a message has multiple
  # headers like 'Set-Cookie'. Use header['Set-Cookie'] for that purpose.
  # (It returns an Array always)
  def headers; end

  # HTTP::Message::Body:: message body.
  def http_body; end

  # Sets a new body.  header.body_size is updated with new body.size.
  def http_body=(body); end

  # HTTP::Message::Headers:: message header.
  def http_header; end

  # HTTP::Message::Headers:: message header.
  def http_header=(_arg0); end

  # Returns HTTP version in a HTTP header.  String.
  def http_version; end

  # Sets HTTP version in a HTTP header.  String.
  def http_version=(http_version); end

  # Convenience method to return boolean of whether we had a successful request
  #
  # @return [Boolean]
  def ok?; end

  # OpenSSL::X509::Certificate:: response only.  server certificate which is
  #                              used for retrieving the response.
  def peer_cert; end

  # OpenSSL::X509::Certificate:: response only.  server certificate which is
  #                              used for retrieving the response.
  def peer_cert=(_arg0); end

  # The other Message object when this Message is generated instead of
  # the Message because of redirection, negotiation, or format conversion.
  def previous; end

  # The other Message object when this Message is generated instead of
  # the Message because of redirection, negotiation, or format conversion.
  def previous=(_arg0); end

  # Returns  HTTP status reason phrase in response.  String.
  def reason; end

  # Sets  HTTP status reason phrase of response.  String.
  def reason=(reason); end

  # @return [Boolean]
  def redirect?; end

  # SEE_OTHER is a redirect, but it should sent as GET
  #
  # @return [Boolean]
  def see_other?; end

  # Returns HTTP status code in response.  Integer.
  def status; end

  # Sets HTTP status code of response.  Integer.
  # Reason phrase is updated, too.
  def status=(status); end

  # Returns HTTP status code in response.  Integer.
  def status_code; end

  def version; end
  def version=(version); end

  class << self
    def create_query_part_str(query); end
    def escape(str); end
    def escape_query(query); end

    # Returns true if the given object is a File.  In HTTPClient, a file is;
    # * must respond to :read for retrieving String chunks.
    # * must respond to :pos and :pos= to rewind for reading.
    #   Rewinding is only needed for following HTTP redirect.  Some IO impl
    #   defines :pos= but raises an Exception for pos= such as StringIO
    #   but there's no problem as far as using it for non-following methods
    #   (get/post/etc.)
    #
    # @return [Boolean]
    def file?(obj); end

    # Returns MIME type handler.
    def get_mime_type_func; end

    # Default MIME type handler.
    # See mime_type_handler=.
    def internal_mime_type(path); end

    # Returns true if the given HTTP version allows keep alive connection.
    # version:: String
    #
    # @return [Boolean]
    def keep_alive_enabled?(version); end

    def mime_type(path); end

    # Returns MIME type handler.
    def mime_type_handler; end

    # Sets MIME type handler.
    #
    # handler must respond to :call with a single argument :path and returns
    # a MIME type String e.g. 'text/html'.
    # When the handler returns nil or an empty String,
    # 'application/octet-stream' is used.
    #
    # When you set nil to the handler, internal_mime_type is used instead.
    # The handler is nil by default.
    def mime_type_handler=(handler); end

    # Returns true if the given query (or body) has a multiple parameter.
    #
    # @return [Boolean]
    def multiparam_query?(query); end

    # Creates a Message instance of 'CONNECT' request.
    # 'CONNECT' request does not have Body.
    # uri:: an URI that need to connect.  Only uri.host and uri.port are used.
    def new_connect_request(uri); end

    # Creates a Message instance of general request.
    # method:: HTTP method String.
    # uri:: an URI object which represents an URL of web resource.
    # query:: a Hash or an Array of query part of URL.
    #         e.g. { "a" => "b" } => 'http://host/part?a=b'
    #         Give an array to pass multiple value like
    #         [["a", "b"], ["a", "c"]] => 'http://host/part?a=b&a=c'
    # body:: a Hash or an Array of body part.
    #        e.g. { "a" => "b" } => 'a=b'.
    #        Give an array to pass multiple value like
    #        [["a", "b"], ["a", "c"]] => 'a=b&a=c'.
    # boundary:: When the boundary given, it is sent as
    #            a multipart/form-data using this boundary String.
    def new_request(method, uri, query = T.unsafe(nil), body = T.unsafe(nil), boundary = T.unsafe(nil)); end

    # Creates a Message instance of response.
    # body:: a String or an IO of response message body.
    def new_response(body, req = T.unsafe(nil)); end

    # from CGI.parse
    def parse(query); end

    # Sets MIME type handler.
    #
    # handler must respond to :call with a single argument :path and returns
    # a MIME type String e.g. 'text/html'.
    # When the handler returns nil or an empty String,
    # 'application/octet-stream' is used.
    #
    # When you set nil to the handler, internal_mime_type is used instead.
    # The handler is nil by default.
    # For backward compatibility.
    def set_mime_type_func(handler); end

    # from CGI.unescape
    def unescape(string); end
  end
end

# Represents HTTP message body.
class HTTP::Message::Body
  # Creates a Message::Body.  Use init_request or init_response
  # for acutual initialize.
  #
  # @return [Body] a new instance of Body
  def initialize; end

  # maxbytes of IO#read for streaming request.  See DEFAULT_CHUNK_SIZE.
  def chunk_size; end

  # maxbytes of IO#read for streaming request.  See DEFAULT_CHUNK_SIZE.
  def chunk_size=(_arg0); end

  # Returns a message body itself.
  def content; end

  # Dumps message body to given dev.
  # dev needs to respond to <<.
  #
  # Message header must be given as the first argument for performance
  # reason. (header is dumped to dev, too)
  # If no dev (the second argument) given, this method returns a dumped
  # String.
  #
  # assert: @size is not nil
  def dump(header = T.unsafe(nil), dev = T.unsafe(nil)); end

  # Dumps message body with chunked encoding to given dev.
  # dev needs to respond to <<.
  #
  # Message header must be given as the first argument for performance
  # reason. (header is dumped to dev, too)
  # If no dev (the second argument) given, this method returns a dumped
  # String.
  def dump_chunked(header = T.unsafe(nil), dev = T.unsafe(nil)); end

  # Initialize this instance as a request.
  def init_request(body = T.unsafe(nil), boundary = T.unsafe(nil)); end

  # Initialize this instance as a response.
  def init_response(body = T.unsafe(nil)); end

  # Hash that keeps IO positions
  def positions; end

  # Hash that keeps IO positions
  def positions=(_arg0); end

  # Size of body.  nil when size is unknown (e.g. chunked response).
  def size; end

  private

  def build_query_multipart_str(query, boundary); end
  def dump_chunk(str); end
  def dump_chunk_size(size); end
  def dump_chunks(io, dev); end
  def dump_file(io, dev, sz); end
  def dump_last_chunk; end
  def params_from_file(value); end
  def remember_pos(io); end
  def reset_pos(io); end
  def set_content(body, boundary = T.unsafe(nil)); end
end

# Default value for chunk_size
HTTP::Message::Body::DEFAULT_CHUNK_SIZE = T.let(T.unsafe(nil), Integer)

class HTTP::Message::Body::Parts
  # @return [Parts] a new instance of Parts
  def initialize; end

  def add(part); end
  def parts; end

  # Returns the value of attribute size.
  def size; end

  # Returns the value of attribute sizes.
  def sizes; end

  private

  def add_size(part, sz); end
end

HTTP::Message::CRLF = T.let(T.unsafe(nil), String)

# Represents HTTP message header.
class HTTP::Message::Headers
  # Creates a Message::Headers.  Use init_request, init_response, or
  # init_connect_request for acutual initialize.
  #
  # @return [Headers] a new instance of Headers
  def initialize; end

  # Returns an Array of header values for the given key.
  def [](key); end

  # Adds a header.  See set.
  def []=(key, value); end

  # Adds a header.  Addition order is preserved.
  def add(key, value); end

  # Returns an Array of all headers.
  def all; end

  # Used for dumping response.
  def body_charset; end

  # Used for dumping response.
  def body_charset=(_arg0); end

  # Used for dumping response.
  def body_date; end

  # Used for dumping response.
  def body_date=(_arg0); end

  # Used for keeping content encoding.
  def body_encoding; end

  # Size of body.  nil when size is unknown (e.g. chunked response).
  def body_size; end

  # Sets byte size of message body.
  # body_size == nil means that the body is_a? IO
  def body_size=(body_size); end

  # Used for dumping response.
  def body_type; end

  # Used for dumping response.
  def body_type=(_arg0); end

  # Request/Response is chunked or not.
  def chunked; end

  # Request/Response is chunked or not.
  def chunked=(_arg0); end

  # Returns 'Content-Type' header value.
  def content_type; end

  # Sets 'Content-Type' header value.  Overrides if already exists.
  def content_type=(content_type); end

  # Returns 'Content-Type' header value.
  def contenttype; end

  # Sets 'Content-Type' header value.  Overrides if already exists.
  def contenttype=(content_type); end

  def create_query_part; end
  def create_query_uri; end

  # Deletes headers of the given key.
  def delete(key); end

  # Dumps message header part and returns a dumped String.
  def dump; end

  # Returns an Array of headers for the given key.  Each element is a pair
  # of key and value.  It returns an single element Array even if the only
  # one header exists.  If nil key given, it returns all headers.
  def get(key = T.unsafe(nil)); end

  # HTTP version in a HTTP header.  String.
  def http_version; end

  # HTTP version in a HTTP header.  String.
  def http_version=(_arg0); end

  # Initialize this instance as a CONNECT request.
  def init_connect_request(uri); end

  # Initialize this instance as a general request.
  def init_request(method, uri, query = T.unsafe(nil)); end

  # Initialize this instance as a response.
  def init_response(status_code, req = T.unsafe(nil)); end

  # Response only.  HTTP status reason phrase.
  def reason_phrase; end

  # Response only.  HTTP status reason phrase.
  def reason_phrase=(_arg0); end

  # Request only.  Requested via proxy or not.
  def request_absolute_uri; end

  # Request only.  Requested via proxy or not.
  def request_absolute_uri=(_arg0); end

  # Request only.  Requested method.
  def request_method; end

  # Request only.  Requested query.
  def request_query; end

  # Request only.  Requested query.
  def request_query=(_arg0); end

  # Request only.  Requested URI.
  def request_uri; end

  # Request only.  Requested URI.
  def request_uri=(_arg0); end

  # Sets a header.
  def set(key, value); end

  def set_body_encoding; end

  # Set Date header
  def set_date_header; end

  def set_headers(headers); end

  # Response only.  HTTP status
  def status_code; end

  # Sets status code and reason phrase.
  def status_code=(status_code); end

  private

  def charset_label; end
  def request_line; end
  def response_status_line; end
  def set_header; end
  def set_request_header; end
  def set_response_header; end
end

# $KCODE to charset mapping definition.
HTTP::Message::Headers::CHARSET_MAP = T.let(T.unsafe(nil), Hash)

# Placeholder URI object for nil uri.
HTTP::Message::Headers::NIL_URI = T.let(T.unsafe(nil), HTTPClient::Util::AddressableURI)

# HTTP response status code to reason phrase mapping definition.
HTTP::Message::Headers::STATUS_CODE_MAP = T.let(T.unsafe(nil), Hash)

HTTP::Message::VERSION_WARNING = T.let(T.unsafe(nil), String)

# Represents HTTP response status code.  Defines constants for HTTP response
# and some conditional methods.
module HTTP::Status
  class << self
    # Returns true if the given status is thought to be redirect.
    # See also REDIRECT_STATUS.
    #
    # @return [Boolean]
    def redirect?(status); end

    # Returns true if the given status represents successful HTTP response.
    # See also SUCCESSFUL_STATUS.
    #
    # @return [Boolean]
    def successful?(status); end
  end
end

HTTP::Status::ACCEPTED = T.let(T.unsafe(nil), Integer)
HTTP::Status::BAD_REQUEST = T.let(T.unsafe(nil), Integer)
HTTP::Status::CREATED = T.let(T.unsafe(nil), Integer)
HTTP::Status::FOUND = T.let(T.unsafe(nil), Integer)
HTTP::Status::INTERNAL = T.let(T.unsafe(nil), Integer)
HTTP::Status::MOVED_PERMANENTLY = T.let(T.unsafe(nil), Integer)
HTTP::Status::MOVED_TEMPORARILY = T.let(T.unsafe(nil), Integer)
HTTP::Status::NON_AUTHORITATIVE_INFORMATION = T.let(T.unsafe(nil), Integer)
HTTP::Status::NO_CONTENT = T.let(T.unsafe(nil), Integer)
HTTP::Status::OK = T.let(T.unsafe(nil), Integer)
HTTP::Status::PARTIAL_CONTENT = T.let(T.unsafe(nil), Integer)
HTTP::Status::PROXY_AUTHENTICATE_REQUIRED = T.let(T.unsafe(nil), Integer)

# Status codes which is a redirect.
HTTP::Status::REDIRECT_STATUS = T.let(T.unsafe(nil), Array)

HTTP::Status::RESET_CONTENT = T.let(T.unsafe(nil), Integer)
HTTP::Status::SEE_OTHER = T.let(T.unsafe(nil), Integer)

# Status codes for successful HTTP response.
HTTP::Status::SUCCESSFUL_STATUS = T.let(T.unsafe(nil), Array)

HTTP::Status::TEMPORARY_REDIRECT = T.let(T.unsafe(nil), Integer)
HTTP::Status::UNAUTHORIZED = T.let(T.unsafe(nil), Integer)

# :main:HTTPClient
# The HTTPClient class provides several methods for accessing Web resources
# via HTTP.
#
# HTTPClient instance is designed to be MT-safe.  You can call a HTTPClient
# instance from several threads without synchronization after setting up an
# instance.
#
#   clnt = HTTPClient.new
#   clnt.set_cookie_store('/home/nahi/cookie.dat')
#   urls.each do |url|
#     Thread.new(url) do |u|
#       p clnt.head(u).status
#     end
#   end
#
# == How to use
#
# At first, how to create your client.  See initialize for more detail.
#
# 1. Create simple client.
#
#     clnt = HTTPClient.new
#
# 2. Accessing resources through HTTP proxy.  You can use environment
#    variable 'http_proxy' or 'HTTP_PROXY' instead.
#
#     clnt = HTTPClient.new('http://myproxy:8080')
#
# === How to retrieve web resources
#
# See get and get_content.
#
# 1. Get content of specified URL.  It returns HTTP::Message object and
#    calling 'body' method of it returns a content String.
#
#     puts clnt.get('http://dev.ctor.org/').body
#
# 2. For getting content directly, use get_content.  It follows redirect
#    response and returns a String of whole result.
#
#     puts clnt.get_content('http://dev.ctor.org/')
#
# 3. You can pass :follow_redirect option to follow redirect response in get.
#
#     puts clnt.get('http://dev.ctor.org/', :follow_redirect => true)
#
# 4. Get content as chunks of String.  It yields chunks of String.
#
#     clnt.get_content('http://dev.ctor.org/') do |chunk|
#       puts chunk
#     end
#
# === Invoking other HTTP methods
#
# See head, get, post, put, delete, options, propfind, proppatch and trace.
# It returns a HTTP::Message instance as a response.
#
# 1. Do HEAD request.
#
#     res = clnt.head(uri)
#     p res.header['Last-Modified'][0]
#
# 2. Do GET request with query.
#
#     query = { 'keyword' => 'ruby', 'lang' => 'en' }
#     res = clnt.get(uri, query)
#     p res.status
#     p res.contenttype
#     p res.header['X-Custom']
#     puts res.body
#
#    You can also use keyword argument style.
#
#     res = clnt.get(uri, :query => { :keyword => 'ruby', :lang => 'en' })
#
# === How to POST
#
# See post.
#
# 1. Do POST a form data.
#
#     body = { 'keyword' => 'ruby', 'lang' => 'en' }
#     res = clnt.post(uri, body)
#
#    Keyword argument style.
#
#     res = clnt.post(uri, :body => ...)
#
# 2. Do multipart file upload with POST.  No need to set extra header by
#    yourself from httpclient/2.1.4.
#
#     File.open('/tmp/post_data') do |file|
#       body = { 'upload' => file, 'user' => 'nahi' }
#       res = clnt.post(uri, body)
#     end
#
# 3. Do multipart with custom body.
#
#     File.open('/tmp/post_data') do |file|
#       body = [{ 'Content-Type' => 'application/atom+xml; charset=UTF-8',
#                 :content => '<entry>...</entry>' },
#               { 'Content-Type' => 'video/mp4',
#                 'Content-Transfer-Encoding' => 'binary',
#                 :content => file }]
#       res = clnt.post(uri, body)
#     end
#
# === Accessing via SSL
#
# Ruby needs to be compiled with OpenSSL.
#
# 1. Get content of specified URL via SSL.
#    Just pass an URL which starts with 'https://'.
#
#     https_url = 'https://www.rsa.com'
#     clnt.get(https_url)
#
# 2. Getting peer certificate from response.
#
#     res = clnt.get(https_url)
#     p res.peer_cert #=> returns OpenSSL::X509::Certificate
#
# 3. Configuring OpenSSL options.  See HTTPClient::SSLConfig for more details.
#
#     user_cert_file = 'cert.pem'
#     user_key_file = 'privkey.pem'
#     clnt.ssl_config.set_client_cert_file(user_cert_file, user_key_file)
#     clnt.get(https_url)
#
# 4. Revocation check. On JRuby you can set following options to let
#    HTTPClient to perform revocation check with CRL and OCSP:
#
#     -J-Dcom.sun.security.enableCRLDP=true -J-Dcom.sun.net.ssl.checkRevocation=true
#     ex. jruby -J-Dcom.sun.security.enableCRLDP=true -J-Dcom.sun.net.ssl.checkRevocation=true app.rb
#     Revoked cert example: https://test-sspev.verisign.com:2443/test-SSPEV-revoked-verisign.html
#
#    On other platform you can download CRL by yourself and set it via
#    SSLConfig#add_crl.
#
# === Handling Cookies
#
# 1. Using volatile Cookies.  Nothing to do.  HTTPClient handles Cookies.
#
#     clnt = HTTPClient.new
#     res = clnt.get(url1) # receives Cookies.
#     res = clnt.get(url2) # sends Cookies if needed.
#     p res.cookies
#
# 2. Saving non volatile Cookies to a specified file.  Need to set a file at
#    first and invoke save method at last.
#
#     clnt = HTTPClient.new
#     clnt.set_cookie_store('/home/nahi/cookie.dat')
#     clnt.get(url)
#     ...
#     clnt.save_cookie_store
#
# 3. Disabling Cookies.
#
#     clnt = HTTPClient.new
#     clnt.cookie_manager = nil
#
# === Configuring authentication credentials
#
# 1. Authentication with Web server.  Supports BasicAuth, DigestAuth, and
#    Negotiate/NTLM (requires ruby/ntlm module).
#
#     clnt = HTTPClient.new
#     domain = 'http://dev.ctor.org/http-access2/'
#     user = 'user'
#     password = 'user'
#     clnt.set_auth(domain, user, password)
#     p clnt.get('http://dev.ctor.org/http-access2/login').status
#
# 2. Authentication with Proxy server.  Supports BasicAuth and NTLM
#    (requires win32/sspi)
#
#     clnt = HTTPClient.new(proxy)
#     user = 'proxy'
#     password = 'proxy'
#     clnt.set_proxy_auth(user, password)
#     p clnt.get(url)
#
# === Invoking HTTP methods with custom header
#
# Pass a Hash or an Array for header argument.
#
#     header = { 'Accept' => 'text/html' }
#     clnt.get(uri, query, header)
#
#     header = [['Accept', 'image/jpeg'], ['Accept', 'image/png']]
#     clnt.get_content(uri, query, header)
#
# === Invoking HTTP methods asynchronously
#
# See head_async, get_async, post_async, put_async, delete_async,
# options_async, propfind_async, proppatch_async, and trace_async.
# It immediately returns a HTTPClient::Connection instance as a returning value.
#
#     connection = clnt.post_async(url, body)
#     print 'posting.'
#     while true
#       break if connection.finished?
#       print '.'
#       sleep 1
#     end
#     puts '.'
#     res = connection.pop
#     p res.status
#     p res.body.read # res.body is an IO for the res of async method.
#
# === Shortcut methods
#
# You can invoke get_content, get, etc. without creating HTTPClient instance.
#
#   ruby -rhttpclient -e 'puts HTTPClient.get_content(ARGV.shift)' http://dev.ctor.org/
#   ruby -rhttpclient -e 'p HTTPClient.head(ARGV.shift).header["last-modified"]' http://dev.ctor.org/
class HTTPClient
  include ::HTTPClient::Util

  # Creates a HTTPClient instance which manages sessions, cookies, etc.
  #
  # HTTPClient.new takes optional arguments as a Hash.
  #  * :proxy - proxy url string
  #  * :agent_name - User-Agent String
  #  * :from - from header String
  #  * :base_url - base URL of resources
  #  * :default_header - header Hash all HTTP requests should have
  #  * :force_basic_auth - flag for sending Authorization header w/o gettin 401 first
  # User-Agent and From are embedded in HTTP request Header if given.
  # From header is not set without setting it explicitly.
  #
  #   proxy = 'http://myproxy:8080'
  #   agent_name = 'MyAgent/0.1'
  #   from = 'from@example.com'
  #   HTTPClient.new(proxy, agent_name, from)
  #
  # After you set :base_url, all resources you pass to get, post and other
  # methods are recognized to be prefixed with base_url. Say base_url is
  # 'https://api.example.com/v1/, get('users') is the same as
  # get('https://api.example.com/v1/users') internally. You can also pass
  # full URL from 'http://' even after setting base_url.
  #
  # The expected base_url and path behavior is the following. Please take
  # care of '/' in base_url and path.
  #
  # The last '/' is important for base_url:
  #   1. http://foo/bar/baz/ + path -> http://foo/bar/baz/path
  #   2. http://foo/bar/baz + path -> http://foo/bar/path
  # Relative path handling:
  #   3. http://foo/bar/baz/ + ../path -> http://foo/bar/path
  #   4. http://foo/bar/baz + ../path -> http://foo/path
  #   5. http://foo/bar/baz/ + ./path -> http://foo/bar/baz/path
  #   6. http://foo/bar/baz + ./path -> http://foo/bar/path
  # The leading '/' of path means absolute path:
  #   7. http://foo/bar/baz/ + /path -> http://foo/path
  #   8. http://foo/bar/baz + /path -> http://foo/path
  #
  # :default_header is for providing default headers Hash that all HTTP
  # requests should have, such as custom 'Authorization' header in API.
  # You can override :default_header with :header Hash parameter in HTTP
  # request methods.
  #
  # :force_basic_auth turns on/off the BasicAuth force flag. Generally
  # HTTP client must send Authorization header after it gets 401 error
  # from server from security reason. But in some situation (e.g. API
  # client) you might want to send Authorization from the beginning.
  #
  # @return [HTTPClient] a new instance of HTTPClient
  def initialize(*args, &block); end

  def agent_name; end
  def agent_name=(rhs); end

  # Base url of resources.
  def base_url; end

  # Base url of resources.
  def base_url=(_arg0); end

  def connect_timeout; end
  def connect_timeout=(rhs); end

  # HTTPClient::CookieManager:: Cookies configurator.
  def cookie_manager; end

  # HTTPClient::CookieManager:: Cookies configurator.
  def cookie_manager=(_arg0); end

  # Returns stored cookies.
  def cookies; end

  # Returns debug device if exists.  See debug_dev=.
  def debug_dev; end

  # Sets debug device.  Once debug device is set, all HTTP requests and
  # responses are dumped to given device.  dev must respond to << for dump.
  #
  # Calling this method resets all existing sessions.
  def debug_dev=(dev); end

  # Default request header.
  def default_header; end

  # Default request header.
  def default_header=(_arg0); end

  # A default method for redirect uri callback.  This method is used by
  # HTTPClient instance by default.
  # This callback allows relative redirect such as
  #   Location: ../foo/
  # in HTTP header.
  def default_redirect_uri_callback(uri, res); end

  # Sends DELETE request to the specified URL.  See request for arguments.
  def delete(uri, *args, &block); end

  # Sends DELETE request in async style.  See request_async2 for arguments.
  # It immediately returns a HTTPClient::Connection instance as a result.
  def delete_async(uri, *args); end

  # How many times get_content and post_content follows HTTP redirect.
  # 10 by default.
  def follow_redirect_count; end

  # How many times get_content and post_content follows HTTP redirect.
  # 10 by default.
  def follow_redirect_count=(_arg0); end

  # Turn on/off the BasicAuth force flag. Generally HTTP client must
  # send Authorization header after it gets 401 error from server from
  # security reason. But in some situation (e.g. API client) you might
  # want to send Authorization from the beginning.
  def force_basic_auth=(force_basic_auth); end

  def from; end
  def from=(rhs); end

  # Sends GET request to the specified URL.  See request for arguments.
  def get(uri, *args, &block); end

  # Sends GET request in async style.  See request_async for arguments.
  # It immediately returns a HTTPClient::Connection instance as a result.
  def get_async(uri, *args); end

  # Retrieves a web resource.
  #
  # uri:: a String or an URI object which represents an URL of web resource.
  # query:: a Hash or an Array of query part of URL.
  #         e.g. { "a" => "b" } => 'http://host/part?a=b'.
  #         Give an array to pass multiple value like
  #         [["a", "b"], ["a", "c"]] => 'http://host/part?a=b&a=c'.
  # header:: a Hash or an Array of extra headers.  e.g.
  #          { 'Accept' => 'text/html' } or
  #          [['Accept', 'image/jpeg'], ['Accept', 'image/png']].
  # &block:: Give a block to get chunked message-body of response like
  #          get_content(uri) { |chunked_body| ... }.
  #          Size of each chunk may not be the same.
  #
  # get_content follows HTTP redirect status (see HTTP::Status.redirect?)
  # internally and try to retrieve content from redirected URL.  See
  # redirect_uri_callback= how HTTP redirection is handled.
  #
  # If you need to get full HTTP response including HTTP status and headers,
  # use get method.  get returns HTTP::Message as a response and you need to
  # follow HTTP redirect by yourself if you need.
  def get_content(uri, *args, &block); end

  # Sends HEAD request to the specified URL.  See request for arguments.
  def head(uri, *args); end

  # Sends HEAD request in async style.  See request_async for arguments.
  # It immediately returns a HTTPClient::Connection instance as a result.
  def head_async(uri, *args); end

  def keep_alive_timeout; end
  def keep_alive_timeout=(rhs); end

  # webmock 1.6.2 depends on HTTP::Message#body.content to work.
  # let's keep it work iif webmock is loaded for a while.
  def keep_webmock_compat; end

  # Returns NO_PROXY setting String if given.
  def no_proxy; end

  # Sets NO_PROXY setting String.  no_proxy must be a comma separated String.
  # Each entry must be 'host' or 'host:port' such as;
  # HTTPClient#no_proxy = 'example.com,example.co.jp:443'
  #
  # 'localhost' is treated as a no_proxy site regardless of explicitly listed.
  # HTTPClient checks given URI objects before accessing it.
  # 'host' is tail string match.  No IP-addr conversion.
  #
  # You can use environment variable 'no_proxy' or 'NO_PROXY' for it.
  #
  # Calling this method resets all existing sessions.
  def no_proxy=(no_proxy); end

  # Sends OPTIONS request to the specified URL.  See request for arguments.
  def options(uri, *args, &block); end

  # Sends OPTIONS request in async style.  See request_async2 for arguments.
  # It immediately returns a HTTPClient::Connection instance as a result.
  def options_async(uri, *args); end

  # Sends PATCH request to the specified URL.  See request for arguments.
  def patch(uri, *args, &block); end

  # Sends PATCH request in async style.  See request_async2 for arguments.
  # It immediately returns a HTTPClient::Connection instance as a result.
  def patch_async(uri, *args); end

  # Sends POST request to the specified URL.  See request for arguments.
  # You should not depend on :follow_redirect => true for POST method.  It
  # sends the same POST method to the new location which is prohibited in HTTP spec.
  def post(uri, *args, &block); end

  # Sends POST request in async style.  See request_async for arguments.
  # It immediately returns a HTTPClient::Connection instance as a result.
  def post_async(uri, *args); end

  # Posts a content.
  #
  # uri:: a String or an URI object which represents an URL of web resource.
  # body:: a Hash or an Array of body part. e.g.
  #          { "a" => "b" } => 'a=b'
  #        Give an array to pass multiple value like
  #          [["a", "b"], ["a", "c"]] => 'a=b&a=c'
  #        When you pass a File as a value, it will be posted as a
  #        multipart/form-data.  e.g.
  #          { 'upload' => file }
  #        You can also send custom multipart by passing an array of hashes.
  #        Each part must have a :content attribute which can be a file, all
  #        other keys will become headers.
  #          [{ 'Content-Type' => 'text/plain', :content => "some text" },
  #           { 'Content-Type' => 'video/mp4', :content => File.new('video.mp4') }]
  #          => <Two parts with custom Content-Type header>
  # header:: a Hash or an Array of extra headers. e.g.
  #            { 'Accept' => 'text/html' }
  #          or
  #            [['Accept', 'image/jpeg'], ['Accept', 'image/png']].
  # &block:: Give a block to get chunked message-body of response like
  #            post_content(uri) { |chunked_body| ... }.
  #          Size of each chunk may not be the same.
  #
  # post_content follows HTTP redirect status (see HTTP::Status.redirect?)
  # internally and try to post the content to redirected URL.  See
  # redirect_uri_callback= how HTTP redirection is handled.
  # Bear in mind that you should not depend on post_content because it sends
  # the same POST method to the new location which is prohibited in HTTP spec.
  #
  # If you need to get full HTTP response including HTTP status and headers,
  # use post method.
  def post_content(uri, *args, &block); end

  # Sends PROPFIND request to the specified URL.  See request for arguments.
  def propfind(uri, *args, &block); end

  # Sends PROPFIND request in async style.  See request_async2 for arguments.
  # It immediately returns a HTTPClient::Connection instance as a result.
  def propfind_async(uri, *args); end

  # Sends PROPPATCH request to the specified URL.  See request for arguments.
  def proppatch(uri, *args, &block); end

  # Sends PROPPATCH request in async style.  See request_async2 for arguments.
  # It immediately returns a HTTPClient::Connection instance as a result.
  def proppatch_async(uri, *args); end

  def protocol_retry_count; end
  def protocol_retry_count=(rhs); end
  def protocol_version; end
  def protocol_version=(rhs); end

  # Returns URI object of HTTP proxy if exists.
  def proxy; end

  # Sets HTTP proxy used for HTTP connection.  Given proxy can be an URI,
  # a String or nil.  You can set user/password for proxy authentication like
  # HTTPClient#proxy = 'http://user:passwd@myproxy:8080'
  #
  # You can use environment variable 'http_proxy' or 'HTTP_PROXY' for it.
  # You need to use 'cgi_http_proxy' or 'CGI_HTTP_PROXY' instead if you run
  # HTTPClient from CGI environment from security reason. (HTTPClient checks
  # 'REQUEST_METHOD' environment variable whether it's CGI or not)
  #
  # Calling this method resets all existing sessions.
  def proxy=(proxy); end

  # HTTPClient::ProxyAuth:: Proxy authentication handler.
  def proxy_auth; end

  # Sends PUT request to the specified URL.  See request for arguments.
  def put(uri, *args, &block); end

  # Sends PUT request in async style.  See request_async2 for arguments.
  # It immediately returns a HTTPClient::Connection instance as a result.
  def put_async(uri, *args); end

  def read_block_size; end
  def read_block_size=(rhs); end
  def receive_timeout; end
  def receive_timeout=(rhs); end

  # Sets callback proc when HTTP redirect status is returned for get_content
  # and post_content.  default_redirect_uri_callback is used by default.
  #
  # If you need strict implementation which does not allow relative URI
  # redirection, set strict_redirect_uri_callback instead.
  #
  #   clnt.redirect_uri_callback = clnt.method(:strict_redirect_uri_callback)
  def redirect_uri_callback=(redirect_uri_callback); end

  # Sends a request to the specified URL.
  #
  # method:: HTTP method to be sent.  method.to_s.upcase is used.
  # uri:: a String or an URI object which represents an URL of web resource.
  # query:: a Hash or an Array of query part of URL.
  #         e.g. { "a" => "b" } => 'http://host/part?a=b'
  #         Give an array to pass multiple value like
  #         [["a", "b"], ["a", "c"]] => 'http://host/part?a=b&a=c'
  # body:: a Hash or an Array of body part. e.g.
  #          { "a" => "b" }
  #          => 'a=b'
  #        Give an array to pass multiple value like
  #          [["a", "b"], ["a", "c"]]
  #          => 'a=b&a=c'.
  #        When the given method is 'POST' and the given body contains a file
  #        as a value, it will be posted as a multipart/form-data. e.g.
  #          { 'upload' => file }
  #        You can also send custom multipart by passing an array of hashes.
  #        Each part must have a :content attribute which can be a file, all
  #        other keys will become headers.
  #          [{ 'Content-Type' => 'text/plain', :content => "some text" },
  #           { 'Content-Type' => 'video/mp4', :content => File.new('video.mp4') }]
  #          => <Two parts with custom Content-Type header>
  #        See HTTP::Message.file? for actual condition of 'a file'.
  # header:: a Hash or an Array of extra headers.  e.g.
  #          { 'Accept' => 'text/html' } or
  #          [['Accept', 'image/jpeg'], ['Accept', 'image/png']].
  # &block:: Give a block to get chunked message-body of response like
  #          get(uri) { |chunked_body| ... }.
  #          Size of each chunk may not be the same.
  #
  # You can also pass a String as a body.  HTTPClient just sends a String as
  # a HTTP request message body.
  #
  # When you pass an IO as a body, HTTPClient sends it as a HTTP request with
  # chunked encoding (Transfer-Encoding: chunked in HTTP header) if IO does not
  # respond to :size. Bear in mind that some server application does not support
  # chunked request.  At least cgi.rb does not support it.
  def request(method, uri, *args, &block); end

  # Sends a request in async style.  request method creates new Thread for
  # HTTP connection and returns a HTTPClient::Connection instance immediately.
  #
  # Arguments definition is the same as request.
  def request_async(method, uri, query = T.unsafe(nil), body = T.unsafe(nil), header = T.unsafe(nil)); end

  # new method that has same signature as 'request'
  def request_async2(method, uri, *args); end

  # An array of request filter which can trap HTTP request/response.
  # See HTTPClient::WWWAuth to see how to use it.
  def request_filter; end

  # Resets internal session for the given URL.  Keep-alive connection for the
  # site (host-port pair) is disconnected if exists.
  def reset(uri); end

  # Resets all of internal sessions.  Keep-alive connections are disconnected.
  def reset_all; end

  # Try to save Cookies to the file specified in set_cookie_store.  Unexpected
  # error will be raised if you don't call set_cookie_store first.
  def save_cookie_store; end

  def send_timeout; end
  def send_timeout=(rhs); end

  # Sets credential for Web server authentication.
  # domain:: a String or an URI to specify where HTTPClient should use this
  #       credential.  If you set uri to nil, HTTPClient uses this credential
  #       wherever a server requires it.
  # user:: username String.
  # passwd:: password String.
  #
  # You can set multiple credentials for each uri.
  #
  #   clnt.set_auth('http://www.example.com/foo/', 'foo_user', 'passwd')
  #   clnt.set_auth('http://www.example.com/bar/', 'bar_user', 'passwd')
  #
  # Calling this method resets all existing sessions.
  def set_auth(domain, user, passwd); end

  # Deprecated.  Use set_auth instead.
  def set_basic_auth(domain, user, passwd); end

  # Sets the filename where non-volatile Cookies be saved by calling
  # save_cookie_store.
  # This method tries to load and managing Cookies from the specified file.
  #
  # Calling this method resets all existing sessions.
  def set_cookie_store(filename); end

  # Sets credential for Proxy authentication.
  # user:: username String.
  # passwd:: password String.
  #
  # Calling this method resets all existing sessions.
  def set_proxy_auth(user, passwd); end

  def socket_local; end
  def socket_local=(rhs); end
  def socket_sync; end
  def socket_sync=(rhs); end

  # HTTPClient::SSLConfig:: SSL configurator.
  def ssl_config; end

  # A method for redirect uri callback.  How to use:
  #   clnt.redirect_uri_callback = clnt.method(:strict_redirect_uri_callback)
  # This callback does not allow relative redirect such as
  #   Location: ../foo/
  # in HTTP header. (raises BadResponseError instead)
  def strict_redirect_uri_callback(uri, res); end

  def strict_response_size_check; end
  def strict_response_size_check=(rhs); end
  def tcp_keepalive; end
  def tcp_keepalive=(rhs); end
  def test_loopback_http_response; end

  # An array of response HTTP message body String which is used for loop-back
  # test.  See test/* to see how to use it.  If you want to do loop-back test
  # of HTTP header, use test_loopback_http_response instead.
  def test_loopback_response; end

  # Sends TRACE request to the specified URL.  See request for arguments.
  def trace(uri, *args, &block); end

  # Sends TRACE request in async style.  See request_async2 for arguments.
  # It immediately returns a HTTPClient::Connection instance as a result.
  def trace_async(uri, *args); end

  def transparent_gzip_decompression; end
  def transparent_gzip_decompression=(rhs); end

  # HTTPClient::WWWAuth:: WWW authentication handler.
  def www_auth; end

  private

  def adapt_block(&block); end
  def create_boundary; end
  def create_request(method, uri, query, body, header); end

  # !! CAUTION !!
  #   Method 'do_get*' runs under MT conditon. Be careful to change.
  def do_get_block(req, proxy, conn, &block); end

  def do_get_header(req, res, sess); end
  def do_get_stream(req, proxy, conn); end
  def do_request(method, uri, query, body, header, &block); end
  def do_request_async(method, uri, query, body, header); end
  def dump_dummy_request_response(req, res); end

  # @return [Boolean]
  def file_in_form_data?(body); end

  # @raise [BadResponseError]
  def follow_redirect(method, uri, query, body, header, &block); end

  def getenv(name); end
  def hashy_argument_has_keys(args, *key); end
  def load_environment; end

  # @return [Boolean]
  def no_proxy?(uri); end

  def override_header(header, key, value); end
  def protect_keep_alive_disconnected; end
  def set_encoding(str, encoding); end
  def success_content(res); end
  def to_resource_url(uri); end

  class << self
    def delete(*arg, &block); end
    def get(*arg, &block); end
    def get_content(*arg, &block); end
    def head(*arg, &block); end
    def options(*arg, &block); end
    def post(*arg, &block); end
    def post_content(*arg, &block); end
    def propfind(*arg, &block); end
    def proppatch(*arg, &block); end
    def put(*arg, &block); end
    def trace(*arg, &block); end

    private

    def attr_proxy(symbol, assignable = T.unsafe(nil)); end
  end
end

# Authentication filter base class.
class HTTPClient::AuthBase
  include ::HTTPClient::Util

  # @return [AuthBase] a new instance of AuthBase
  def initialize(scheme); end

  # Resets challenge state.  Do not send '*Authorization' header until the
  # server sends '*Authentication' again.
  def reset_challenge; end

  # Authentication scheme.
  def scheme; end
end

# Common abstract class for authentication filter.
#
# There are 2 authentication filters.
# WWWAuth:: Authentication filter for handling authentication negotiation
#           between Web server.  Parses 'WWW-Authentication' header in
#           response and generates 'Authorization' header in request.
# ProxyAuth:: Authentication filter for handling authentication negotiation
#             between Proxy server.  Parses 'Proxy-Authentication' header in
#             response and generates 'Proxy-Authorization' header in request.
class HTTPClient::AuthFilterBase
  private

  def parse_authentication_header(res, tag); end
  def parse_challenge_header(challenge); end
end

# Raised for indicating HTTP response error.
class HTTPClient::BadResponseError < ::RuntimeError
  # @return [BadResponseError] a new instance of BadResponseError
  def initialize(msg, res = T.unsafe(nil)); end

  # HTTP::Message:: a response
  def res; end
end

# Authentication filter for handling BasicAuth negotiation.
# Used in WWWAuth and ProxyAuth.
class HTTPClient::BasicAuth < ::HTTPClient::AuthBase
  include ::Mutex_m

  # Creates new BasicAuth filter.
  #
  # @return [BasicAuth] a new instance of BasicAuth
  def initialize; end

  # Challenge handler: remember URL for response.
  def challenge(uri, param_str = T.unsafe(nil)); end

  # Send Authorization Header without receiving 401
  def force_auth; end

  # Send Authorization Header without receiving 401
  def force_auth=(_arg0); end

  # Response handler: returns credential.
  # It sends cred only when a given uri is;
  # * child page of challengeable(got *Authenticate before) uri and,
  # * child page of defined credential
  def get(req); end

  def lock; end
  def locked?; end

  # Set authentication credential.
  # uri == nil for generic purpose (allow to use user/password for any URL).
  def set(uri, user, passwd); end

  # have we marked this as set - ie that it's valid to use in this context?
  #
  # @return [Boolean]
  def set?; end

  def synchronize(&block); end
  def try_lock; end
  def unlock; end
end

# Raised for indicating running environment configuration error for example
# accessing via SSL under the ruby which is not compiled with OpenSSL.
class HTTPClient::ConfigurationError < ::StandardError; end

# Raised for indicating a connection timeout error.
# You can configure connection timeout via HTTPClient#connect_timeout=.
class HTTPClient::ConnectTimeoutError < ::HTTPClient::TimeoutError; end

# Represents a HTTP response to an asynchronous request.  Async methods of
# HTTPClient such as get_async, post_async, etc. returns an instance of
# Connection.
#
# == How to use
#
# 1. Invoke HTTP method asynchronously and check if it's been finished
#    periodically.
#
#     connection = clnt.post_async(url, body)
#     print 'posting.'
#     while true
#       break if connection.finished?
#       print '.'
#       sleep 1
#     end
#     puts '.'
#     res = connection.pop
#     p res.status
#
# 2. Read the response as an IO.
#
#     connection = clnt.get_async('http://dev.ctor.org/')
#     io = connection.pop.content
#     while str = io.read(40)
#       p str
#     end
class HTTPClient::Connection
  # @return [Connection] a new instance of Connection
  def initialize(header_queue = T.unsafe(nil), body_queue = T.unsafe(nil)); end

  # Returns the value of attribute async_thread.
  def async_thread; end

  # Sets the attribute async_thread
  #
  # @param value the value to set the attribute async_thread to.
  def async_thread=(_arg0); end

  # Checks if the asynchronous invocation has been finished or not.
  #
  # @return [Boolean]
  def finished?; end

  # Waits the completion of the asynchronous invocation.
  def join; end

  # Retrieves a HTTP::Message instance of HTTP response.  Do not invoke this
  # method twice for now.  The second invocation will be blocked.
  def pop; end

  def push(result); end
end

HTTPClient::CookieManager = WebAgent::CookieManager

# Default User-Agent header
HTTPClient::DEFAULT_AGENT_NAME = T.let(T.unsafe(nil), String)

# Module for intercepting Socket methods and dumps in/out to given debugging
# device.  debug_dev must respond to <<.
module HTTPClient::DebugSocket
  extend ::HTTPClient::SocketWrap

  def <<(str); end
  def close; end
  def debug_dev=(debug_dev); end
  def gets(rs); end
  def read(size, buf = T.unsafe(nil)); end
  def readpartial(size, buf = T.unsafe(nil)); end

  private

  def debug(str); end
end

# Authentication filter for handling DigestAuth negotiation.
# Used in WWWAuth.
class HTTPClient::DigestAuth < ::HTTPClient::AuthBase
  include ::Mutex_m

  # Creates new DigestAuth filter.
  #
  # @return [DigestAuth] a new instance of DigestAuth
  def initialize; end

  # Challenge handler: remember URL and challenge token for response.
  def challenge(uri, param_str); end

  # Response handler: returns credential.
  # It sends cred only when a given uri is;
  # * child page of challengeable(got *Authenticate before) uri and,
  # * child page of defined credential
  def get(req); end

  def lock; end
  def locked?; end

  # Set authentication credential.
  # uri == nil is ignored.
  def set(uri, user, passwd); end

  # have we marked this as set - ie that it's valid to use in this context?
  #
  # @return [Boolean]
  def set?; end

  def synchronize(&block); end
  def try_lock; end
  def unlock; end

  private

  # this method is implemented by sromano and posted to
  # http://tools.assembla.com/breakout/wiki/DigestForSoap
  # Thanks!
  # supported algorithms: MD5, MD5-sess
  def calc_cred(req, user, passwd, param); end

  # cf. WEBrick::HTTPAuth::DigestAuth#generate_next_nonce(aTime)
  def generate_cnonce; end

  def parse_challenge_param(param_str); end
end

class HTTPClient::KeepAliveDisconnected < ::StandardError
  # @return [KeepAliveDisconnected] a new instance of KeepAliveDisconnected
  def initialize(sess = T.unsafe(nil), cause = T.unsafe(nil)); end

  # Returns the value of attribute cause.
  def cause; end

  # Returns the value of attribute sess.
  def sess; end
end

HTTPClient::LIB_NAME = T.let(T.unsafe(nil), String)

# Dummy Socket for emulating loopback test.
class HTTPClient::LoopBackSocket
  include ::HTTPClient::SocketWrap

  # @return [LoopBackSocket] a new instance of LoopBackSocket
  def initialize(host, port, response); end

  def <<(str); end
  def peer_cert; end
end

HTTPClient::NO_PROXY_HOSTS = T.let(T.unsafe(nil), Array)

# Authentication filter for handling Negotiate/NTLM negotiation.
# Used in WWWAuth and ProxyAuth.
#
# NegotiateAuth depends on 'ruby/ntlm' module.
class HTTPClient::NegotiateAuth < ::HTTPClient::AuthBase
  include ::Mutex_m

  # Creates new NegotiateAuth filter.
  #
  # @return [NegotiateAuth] a new instance of NegotiateAuth
  def initialize(scheme = T.unsafe(nil)); end

  # Challenge handler: remember URL and challenge token for response.
  def challenge(uri, param_str); end

  # Response handler: returns credential.
  # See ruby/ntlm for negotiation state transition.
  def get(req); end

  def lock; end
  def locked?; end

  # NTLM opt for ruby/ntlm.  {:ntlmv2 => true} by default.
  def ntlm_opt; end

  # Set authentication credential.
  # uri == nil for generic purpose (allow to use user/password for any URL).
  def set(uri, user, passwd); end

  # have we marked this as set - ie that it's valid to use in this context?
  #
  # @return [Boolean]
  def set?; end

  def synchronize(&block); end
  def try_lock; end
  def unlock; end
end

# Authentication filter for handling OAuth negotiation.
# Used in WWWAuth.
#
# CAUTION: This impl only support '#7 Accessing Protected Resources' in OAuth
# Core 1.0 spec for now. You need to obtain Access token and Access secret by
# yourself.
#
# CAUTION: This impl does NOT support OAuth Request Body Hash spec for now.
# http://oauth.googlecode.com/svn/spec/ext/body_hash/1.0/oauth-bodyhash.html
class HTTPClient::OAuth < ::HTTPClient::AuthBase
  include ::Mutex_m

  # Creates new DigestAuth filter.
  #
  # @return [OAuth] a new instance of OAuth
  def initialize; end

  # Challenge handler: remember URL for response.
  #
  # challenge() in OAuth handler always returns false to avoid connection
  # retry which should not work in OAuth authentication context.  This
  # method just remember URL (nil means 'any') for the next connection.
  # Normally OAuthClient handles this correctly but see how it uses when
  # you need to use this class directly.
  def challenge(uri, param_str = T.unsafe(nil)); end

  def escape(str); end

  # Response handler: returns credential.
  # It sends cred only when a given uri is;
  # * child page of challengeable(got *Authenticate before) uri and,
  # * child page of defined credential
  def get(req); end

  # Get authentication credential.
  def get_config(uri = T.unsafe(nil)); end

  def lock; end
  def locked?; end

  # Set authentication credential.
  # You cannot set OAuth config via WWWAuth#set_auth. Use OAuth#config=
  def set(*args); end

  # Check always (not effective but it works)
  #
  # @return [Boolean]
  def set?; end

  # Set authentication credential.
  def set_config(uri, config); end

  def synchronize(&block); end
  def try_lock; end
  def unlock; end

  private

  def calc_cred(req, config); end
  def create_base_string(config, header, req); end
  def do_get_config(uri = T.unsafe(nil)); end
  def encode_header(k, v); end
  def encode_param(params); end
  def generate_nonce; end
  def sign(config, header, req); end
  def sign_hmac_sha1(config, base_string); end

  class << self
    def escape(str); end
  end
end

class HTTPClient::OAuth::Config
  include ::HTTPClient::Util

  # @return [Config] a new instance of Config
  def initialize(*args); end

  # Returns the value of attribute callback.
  def callback; end

  # Sets the attribute callback
  #
  # @param value the value to set the attribute callback to.
  def callback=(_arg0); end

  # Returns the value of attribute consumer_key.
  def consumer_key; end

  # Sets the attribute consumer_key
  #
  # @param value the value to set the attribute consumer_key to.
  def consumer_key=(_arg0); end

  # Returns the value of attribute consumer_secret.
  def consumer_secret; end

  # Sets the attribute consumer_secret
  #
  # @param value the value to set the attribute consumer_secret to.
  def consumer_secret=(_arg0); end

  # Returns the value of attribute debug_nonce.
  def debug_nonce; end

  # Sets the attribute debug_nonce
  #
  # @param value the value to set the attribute debug_nonce to.
  def debug_nonce=(_arg0); end

  # Returns the value of attribute debug_timestamp.
  def debug_timestamp; end

  # Sets the attribute debug_timestamp
  #
  # @param value the value to set the attribute debug_timestamp to.
  def debug_timestamp=(_arg0); end

  # Returns the value of attribute http_method.
  def http_method; end

  # Sets the attribute http_method
  #
  # @param value the value to set the attribute http_method to.
  def http_method=(_arg0); end

  # Returns the value of attribute realm.
  def realm; end

  # Sets the attribute realm
  #
  # @param value the value to set the attribute realm to.
  def realm=(_arg0); end

  # Returns the value of attribute secret.
  def secret; end

  # Sets the attribute secret
  #
  # @param value the value to set the attribute secret to.
  def secret=(_arg0); end

  # for OAuth Session 1.0 (draft)
  def session_handle; end

  # for OAuth Session 1.0 (draft)
  def session_handle=(_arg0); end

  # Returns the value of attribute signature_handler.
  def signature_handler; end

  # Returns the value of attribute signature_method.
  def signature_method; end

  # Sets the attribute signature_method
  #
  # @param value the value to set the attribute signature_method to.
  def signature_method=(_arg0); end

  # Returns the value of attribute token.
  def token; end

  # Sets the attribute token
  #
  # @param value the value to set the attribute token to.
  def token=(_arg0); end

  # Returns the value of attribute verifier.
  def verifier; end

  # Sets the attribute verifier
  #
  # @param value the value to set the attribute verifier to.
  def verifier=(_arg0); end

  # Returns the value of attribute version.
  def version; end

  # Sets the attribute version
  #
  # @param value the value to set the attribute version to.
  def version=(_arg0); end
end

# Default header for PROPFIND request.
HTTPClient::PROPFIND_DEFAULT_EXTHEADER = T.let(T.unsafe(nil), Hash)

# Authentication filter for handling authentication negotiation between
# Proxy server.  Parses 'Proxy-Authentication' header in response and
# generates 'Proxy-Authorization' header in request.
#
# Authentication filter is implemented using request filter of HTTPClient.
# It traps HTTP response header and maintains authentication state, and
# traps HTTP request header for inserting necessary authentication header.
#
# ProxyAuth has sub filters (BasicAuth, NegotiateAuth, and SSPINegotiateAuth)
# and delegates some operations to it.
# NegotiateAuth requires 'ruby/ntlm' module.
# SSPINegotiateAuth requires 'win32/sspi' module.
class HTTPClient::ProxyAuth < ::HTTPClient::AuthFilterBase
  # Creates new ProxyAuth.
  #
  # @return [ProxyAuth] a new instance of ProxyAuth
  def initialize; end

  # Returns the value of attribute basic_auth.
  def basic_auth; end

  # Returns the value of attribute digest_auth.
  def digest_auth; end

  # Filter API implementation.  Traps HTTP request and insert
  # 'Proxy-Authorization' header if needed.
  def filter_request(req); end

  # Filter API implementation.  Traps HTTP response and parses
  # 'Proxy-Authenticate' header.
  def filter_response(req, res); end

  # Returns the value of attribute negotiate_auth.
  def negotiate_auth; end

  # Resets challenge state.  See sub filters for more details.
  def reset_challenge; end

  # Set authentication credential.  See sub filters for more details.
  def set_auth(user, passwd); end

  # Returns the value of attribute sspi_negotiate_auth.
  def sspi_negotiate_auth; end
end

class HTTPClient::ProxyBasicAuth < ::HTTPClient::BasicAuth
  # Challenge handler: remember URL for response.
  def challenge(uri, param_str = T.unsafe(nil)); end

  def get(req); end
  def set(uri, user, passwd); end
end

# Authentication filter for handling DigestAuth negotiation.
# Ignores uri argument. Used in ProxyAuth.
class HTTPClient::ProxyDigestAuth < ::HTTPClient::DigestAuth
  def challenge(uri, param_str); end

  # overrides DigestAuth#get. Uses default user name and password
  # regardless of target uri if the proxy has required authentication
  # before
  def get(req); end

  def reset_challenge; end

  # overrides DigestAuth#set. sets default user name and password. uri is not used.
  def set(uri, user, passwd); end
end

HTTPClient::RUBY_VERSION_STRING = T.let(T.unsafe(nil), String)

# Raised for indicating a response receiving timeout error.
# You can configure response receiving timeout via
# HTTPClient#receive_timeout=.
class HTTPClient::ReceiveTimeoutError < ::HTTPClient::TimeoutError; end

class HTTPClient::RetryableResponse < ::StandardError
  # @return [RetryableResponse] a new instance of RetryableResponse
  def initialize(res = T.unsafe(nil)); end

  # Returns the value of attribute res.
  def res; end
end

# Represents SSL configuration for HTTPClient instance.
# The implementation depends on OpenSSL.
#
# == Trust Anchor Control
#
# SSLConfig loads 'httpclient/cacert.pem' as a trust anchor
# (trusted certificate(s)) with add_trust_ca in initialization time.
# This means that HTTPClient instance trusts some CA certificates by default,
# like Web browsers.  'httpclient/cacert.pem' is downloaded from curl web
# site by the author and included in released package.
#
# On JRuby, HTTPClient uses Java runtime's trusted CA certificates, not
# cacert.pem by default. You can load cacert.pem by calling
# SSLConfig#load_trust_ca manually like:
#
#   HTTPClient.new { self.ssl_config.load_trust_ca }.get("https://...")
#
# You may want to change trust anchor by yourself.  Call clear_cert_store
# then add_trust_ca for that purpose.
class HTTPClient::SSLConfig
  include ::HTTPClient::Util
  include ::OpenSSL

  # Creates a SSLConfig.
  #
  # @return [SSLConfig] a new instance of SSLConfig
  def initialize(client); end

  # Adds CRL for verification.
  # crl:: a OpenSSL::X509::CRL or a filename of a PEM/DER formatted
  #       OpenSSL::X509::CRL.
  #
  # On JRuby, instead of setting CRL by yourself you can set following
  # options to let HTTPClient to perform revocation check with CRL and OCSP:
  # -J-Dcom.sun.security.enableCRLDP=true -J-Dcom.sun.net.ssl.checkRevocation=true
  # ex. jruby -J-Dcom.sun.security.enableCRLDP=true -J-Dcom.sun.net.ssl.checkRevocation=true app.rb
  #
  # Revoked cert example: https://test-sspev.verisign.com:2443/test-SSPEV-revoked-verisign.html
  #
  # Calling this method resets all existing sessions.
  def add_crl(crl); end

  # Sets trust anchor certificate(s) for verification.
  # trust_ca_file_or_hashed_dir:: a filename of a PEM/DER formatted
  #                               OpenSSL::X509::Certificate or
  #                               a 'c-rehash'eddirectory name which stores
  #                               trusted certificate files.
  #
  # Calling this method resets all existing sessions.
  def add_trust_ca(trust_ca_file_or_hashed_dir); end

  def add_trust_ca_to_store(cert_store, trust_ca_file_or_hashed_dir); end

  # OpenSSL::X509::X509::Store used for verification.  You can reset the
  # store with clear_cert_store and set the new store with cert_store=.
  def cert_store; end

  # Sets new certificate store (OpenSSL::X509::Store).
  # don't use if you don't know what it is.
  #
  # Calling this method resets all existing sessions.
  def cert_store=(cert_store); end

  # Returns the value of attribute cert_store_crl_items.
  def cert_store_crl_items; end

  # These array keeps original files/dirs that was added to @cert_store
  def cert_store_items; end

  def ciphers; end
  def ciphers=(rhs); end

  # Drops current certificate store (OpenSSL::X509::Store) for SSL and create
  # new one for the next session.
  #
  # Calling this method resets all existing sessions.
  def clear_cert_store; end

  def client_ca; end
  def client_ca=(rhs); end
  def client_cert; end
  def client_cert=(rhs); end
  def client_key; end
  def client_key=(rhs); end
  def client_key_pass; end
  def client_key_pass=(rhs); end

  # Default callback for verification: only dumps error.
  def default_verify_callback(is_ok, ctx); end

  # Loads default trust anchors.
  # Calling this method resets all existing sessions.
  def load_trust_ca; end

  def options; end
  def options=(rhs); end

  # post connection check proc for ruby < 1.8.5.
  # this definition must match with the one in ext/openssl/lib/openssl/ssl.rb
  #
  # @raise [SSL::SSLError]
  def post_connection_check(peer_cert, hostname); end

  # Sample callback method:  CAUTION: does not check CRL/ARL.
  def sample_verify_callback(is_ok, ctx); end

  # Sets certificate and private key for SSL client authentication.
  # cert_file:: must be a filename of PEM/DER formatted file.
  # key_file:: must be a filename of PEM/DER formatted file.  Key must be an
  #            RSA key.  If you want to use other PKey algorithm,
  #            use client_key=.
  #
  # Calling this method resets all existing sessions if value is changed.
  def set_client_cert_file(cert_file, key_file, pass = T.unsafe(nil)); end

  # interfaces for SSLSocket.
  def set_context(ctx); end

  # Adds CRL for verification.
  # crl:: a OpenSSL::X509::CRL or a filename of a PEM/DER formatted
  #       OpenSSL::X509::CRL.
  #
  # On JRuby, instead of setting CRL by yourself you can set following
  # options to let HTTPClient to perform revocation check with CRL and OCSP:
  # -J-Dcom.sun.security.enableCRLDP=true -J-Dcom.sun.net.ssl.checkRevocation=true
  # ex. jruby -J-Dcom.sun.security.enableCRLDP=true -J-Dcom.sun.net.ssl.checkRevocation=true app.rb
  #
  # Revoked cert example: https://test-sspev.verisign.com:2443/test-SSPEV-revoked-verisign.html
  #
  # Calling this method resets all existing sessions.
  def set_crl(crl); end

  # Sets OpenSSL's default trusted CA certificates.  Generally, OpenSSL is
  # configured to use OS's trusted CA certificates located at
  # /etc/pki/certs or /etc/ssl/certs.  Unfortunately OpenSSL's Windows build
  # does not work with Windows Certificate Storage.
  #
  # On Windows or when you build OpenSSL manually, you can set the
  # CA certificates directory by SSL_CERT_DIR env variable at runtime.
  #
  #   SSL_CERT_DIR=/etc/ssl/certs ruby -rhttpclient -e "..."
  #
  # Calling this method resets all existing sessions.
  def set_default_paths; end

  # Sets trust anchor certificate(s) for verification.
  # trust_ca_file_or_hashed_dir:: a filename of a PEM/DER formatted
  #                               OpenSSL::X509::Certificate or
  #                               a 'c-rehash'eddirectory name which stores
  #                               trusted certificate files.
  #
  # Calling this method resets all existing sessions.
  def set_trust_ca(trust_ca_file_or_hashed_dir); end

  def ssl_version; end
  def ssl_version=(rhs); end
  def timeout; end
  def timeout=(rhs); end

  # @return [Boolean]
  def verify?; end

  def verify_callback; end
  def verify_callback=(rhs); end
  def verify_depth; end
  def verify_depth=(rhs); end
  def verify_mode; end
  def verify_mode=(rhs); end

  private

  def change_notify; end

  # Use 2048 bit certs trust anchor
  def load_cacerts(cert_store); end

  class << self
    private

    def attr_config(symbol); end
  end
end

# OpenSSL >1.0.0 default
HTTPClient::SSLConfig::CIPHERS_DEFAULT = T.let(T.unsafe(nil), String)

HTTPClient::SSLEnabled = T.let(T.unsafe(nil), TrueClass)

# Wraps up OpenSSL::SSL::SSLSocket and offers debugging features.
class HTTPClient::SSLSocket
  # @return [SSLSocket] a new instance of SSLSocket
  def initialize(socket, dest, config, opts = T.unsafe(nil)); end

  def <<(str); end
  def close; end

  # @return [Boolean]
  def closed?; end

  # @return [Boolean]
  def eof?; end

  def flush; end
  def gets(rs); end
  def peer_cert; end
  def read(size, buf = T.unsafe(nil)); end
  def readpartial(size, buf = T.unsafe(nil)); end
  def sync; end
  def sync=(sync); end

  private

  def check_mask(value, mask); end
  def create_openssl_socket(socket); end
  def debug(str); end
  def post_connection_check(hostname); end
  def ssl_connect(hostname = T.unsafe(nil)); end

  class << self
    def create_socket(session); end
  end
end

# Authentication filter for handling Negotiate/NTLM negotiation.
# Used in ProxyAuth.
#
# SSPINegotiateAuth depends on 'win32/sspi' module.
class HTTPClient::SSPINegotiateAuth < ::HTTPClient::AuthBase
  include ::Mutex_m

  # Creates new SSPINegotiateAuth filter.
  #
  # @return [SSPINegotiateAuth] a new instance of SSPINegotiateAuth
  def initialize; end

  # Challenge handler: remember URL and challenge token for response.
  def challenge(uri, param_str); end

  # Response handler: returns credential.
  # See win32/sspi for negotiation state transition.
  def get(req); end

  def lock; end
  def locked?; end

  # Set authentication credential.
  # NOT SUPPORTED: username and necessary data is retrieved by win32/sspi.
  # See win32/sspi for more details.
  def set(*args); end

  # Check always (not effective but it works)
  #
  # @return [Boolean]
  def set?; end

  def synchronize(&block); end
  def try_lock; end
  def unlock; end
end

# Raised for indicating a request sending timeout error.
# You can configure request sending timeout via HTTPClient#send_timeout=.
class HTTPClient::SendTimeoutError < ::HTTPClient::TimeoutError; end

# Deprecated.  just for backward compatibility
class HTTPClient::Session
  include ::HTTPClient::Timeout
  include ::HTTPClient::Util

  # @return [Session] a new instance of Session
  def initialize(client, dest, agent_name, from); end

  def close; end

  # @return [Boolean]
  def closed?; end

  # Returns the value of attribute connect_retry.
  def connect_retry; end

  # Sets the attribute connect_retry
  #
  # @param value the value to set the attribute connect_retry to.
  def connect_retry=(_arg0); end

  def connect_ssl_proxy(socket, uri); end

  # Returns the value of attribute connect_timeout.
  def connect_timeout; end

  # Sets the attribute connect_timeout
  #
  # @param value the value to set the attribute connect_timeout to.
  def connect_timeout=(_arg0); end

  def create_loopback_socket(host, port, str); end
  def create_socket(host, port); end

  # Device for dumping log for debugging
  def debug_dev; end

  # Device for dumping log for debugging
  def debug_dev=(_arg0); end

  # Destination site
  def dest; end

  # @return [Boolean]
  def eof?; end

  def get_body(&block); end
  def get_header; end

  # Returns the value of attribute last_used.
  def last_used; end

  # Returns the value of attribute protocol_retry_count.
  def protocol_retry_count; end

  # Sets the attribute protocol_retry_count
  #
  # @param value the value to set the attribute protocol_retry_count to.
  def protocol_retry_count=(_arg0); end

  # Proxy site
  def proxy; end

  # Proxy site
  def proxy=(_arg0); end

  # Send a request to the server
  def query(req); end

  # Returns the value of attribute read_block_size.
  def read_block_size; end

  # Sets the attribute read_block_size
  #
  # @param value the value to set the attribute read_block_size to.
  def read_block_size=(_arg0); end

  # Returns the value of attribute receive_timeout.
  def receive_timeout; end

  # Sets the attribute receive_timeout
  #
  # @param value the value to set the attribute receive_timeout to.
  def receive_timeout=(_arg0); end

  # Requested protocol version
  def requested_version; end

  # Requested protocol version
  def requested_version=(_arg0); end

  # Returns the value of attribute send_timeout.
  def send_timeout; end

  # Sets the attribute send_timeout
  #
  # @param value the value to set the attribute send_timeout to.
  def send_timeout=(_arg0); end

  # Returns the value of attribute socket_local.
  def socket_local; end

  # Sets the attribute socket_local
  #
  # @param value the value to set the attribute socket_local to.
  def socket_local=(_arg0); end

  # Boolean value for Socket#sync
  def socket_sync; end

  # Boolean value for Socket#sync
  def socket_sync=(_arg0); end

  # Returns the value of attribute ssl_config.
  def ssl_config; end

  # Sets the attribute ssl_config
  #
  # @param value the value to set the attribute ssl_config to.
  def ssl_config=(_arg0); end

  # Returns the value of attribute ssl_peer_cert.
  def ssl_peer_cert; end

  # Returns the value of attribute strict_response_size_check.
  def strict_response_size_check; end

  # Sets the attribute strict_response_size_check
  #
  # @param value the value to set the attribute strict_response_size_check to.
  def strict_response_size_check=(_arg0); end

  # Boolean value to send TCP keepalive packets; no timing settings exist at present
  def tcp_keepalive; end

  # Boolean value to send TCP keepalive packets; no timing settings exist at present
  def tcp_keepalive=(_arg0); end

  # Returns the value of attribute test_loopback_http_response.
  def test_loopback_http_response; end

  # Sets the attribute test_loopback_http_response
  #
  # @param value the value to set the attribute test_loopback_http_response to.
  def test_loopback_http_response=(_arg0); end

  # Returns the value of attribute transparent_gzip_decompression.
  def transparent_gzip_decompression; end

  # Sets the attribute transparent_gzip_decompression
  #
  # @param value the value to set the attribute transparent_gzip_decompression to.
  def transparent_gzip_decompression=(_arg0); end

  private

  # Connect to the server
  def connect; end

  def content_inflater_block(content_encoding, block); end
  def empty_bin_str; end

  # @return [Boolean]
  def no_message_body?(status); end

  def parse_content_header(key, value); end
  def parse_header(socket); end
  def read_body_chunked(&block); end
  def read_body_length(&block); end
  def read_body_rest; end

  # Read status block.
  def read_header; end

  def set_header(req); end
end

HTTPClient::Session::BadResponse = HTTPClient::BadResponseError

# This inflater allows deflate compression with/without zlib header
class HTTPClient::Session::LenientInflater
  # @return [LenientInflater] a new instance of LenientInflater
  def initialize; end

  def inflate(body); end

  private

  def first_inflate(body); end
end

HTTPClient::Session::RS = T.let(T.unsafe(nil), String)
HTTPClient::Session::StatusParseRegexp = T.let(T.unsafe(nil), Regexp)

# Manages sessions for a HTTPClient instance.
class HTTPClient::SessionManager
  # @return [SessionManager] a new instance of SessionManager
  def initialize(client); end

  # Name of this client.  Used for 'User-Agent' header in HTTP request.
  def agent_name; end

  # Name of this client.  Used for 'User-Agent' header in HTTP request.
  def agent_name=(_arg0); end

  # Chunk size for chunked request
  def chunk_size; end

  # Chunk size for chunked request
  def chunk_size=(_arg0); end

  # Maximum retry count.  0 for infinite.
  def connect_retry; end

  # Maximum retry count.  0 for infinite.
  def connect_retry=(_arg0); end

  # Returns the value of attribute connect_timeout.
  def connect_timeout; end

  # Sets the attribute connect_timeout
  #
  # @param value the value to set the attribute connect_timeout to.
  def connect_timeout=(_arg0); end

  # Device for dumping log for debugging
  def debug_dev; end

  # Device for dumping log for debugging
  def debug_dev=(_arg0); end

  # Owner of this client.  Used for 'From' header in HTTP request.
  def from; end

  # Owner of this client.  Used for 'From' header in HTTP request.
  def from=(_arg0); end

  # assert: sess.last_used must not be nil
  def keep(sess); end

  # Returns the value of attribute keep_alive_timeout.
  def keep_alive_timeout; end

  # Sets the attribute keep_alive_timeout
  #
  # @param value the value to set the attribute keep_alive_timeout to.
  def keep_alive_timeout=(_arg0); end

  # Returns the value of attribute protocol_retry_count.
  def protocol_retry_count; end

  # Sets the attribute protocol_retry_count
  #
  # @param value the value to set the attribute protocol_retry_count to.
  def protocol_retry_count=(_arg0); end

  # Requested protocol version
  def protocol_version; end

  # Requested protocol version
  def protocol_version=(_arg0); end

  def proxy=(proxy); end
  def query(req, via_proxy); end

  # Returns the value of attribute read_block_size.
  def read_block_size; end

  # Sets the attribute read_block_size
  #
  # @param value the value to set the attribute read_block_size to.
  def read_block_size=(_arg0); end

  # Returns the value of attribute receive_timeout.
  def receive_timeout; end

  # Sets the attribute receive_timeout
  #
  # @param value the value to set the attribute receive_timeout to.
  def receive_timeout=(_arg0); end

  def reset(uri); end
  def reset_all; end

  # Returns the value of attribute send_timeout.
  def send_timeout; end

  # Sets the attribute send_timeout
  #
  # @param value the value to set the attribute send_timeout to.
  def send_timeout=(_arg0); end

  # Local address to bind local side of the socket to
  def socket_local; end

  # Local address to bind local side of the socket to
  def socket_local=(_arg0); end

  # Boolean value for Socket#sync
  def socket_sync; end

  # Boolean value for Socket#sync
  def socket_sync=(_arg0); end

  # Returns the value of attribute ssl_config.
  def ssl_config; end

  # Sets the attribute ssl_config
  #
  # @param value the value to set the attribute ssl_config to.
  def ssl_config=(_arg0); end

  # Raise BadResponseError if response size does not match with Content-Length header in response.
  def strict_response_size_check; end

  # Raise BadResponseError if response size does not match with Content-Length header in response.
  def strict_response_size_check=(_arg0); end

  # Boolean value to send TCP keepalive packets; no timing settings exist at present
  def tcp_keepalive; end

  # Boolean value to send TCP keepalive packets; no timing settings exist at present
  def tcp_keepalive=(_arg0); end

  # Returns the value of attribute test_loopback_http_response.
  def test_loopback_http_response; end

  # Returns the value of attribute transparent_gzip_decompression.
  def transparent_gzip_decompression; end

  # Sets the attribute transparent_gzip_decompression
  #
  # @param value the value to set the attribute transparent_gzip_decompression to.
  def transparent_gzip_decompression=(_arg0); end

  private

  def add_cached_session(sess); end

  # This method might not work as you expected...
  def close(dest); end

  def close_all; end
  def get_cached_session(site); end

  # TODO: create PR for webmock's httpclient adapter to use get_session
  # instead of open so that we can remove duplicated Site creation for
  # each session.
  def get_session(req, via_proxy = T.unsafe(nil)); end

  def open(uri, via_proxy = T.unsafe(nil)); end
  def scrub_cached_session(now); end

  # @return [Boolean]
  def valid_session?(sess, now); end
end

# Represents a Site: protocol scheme, host String and port Number.
class HTTPClient::Site
  # Creates a new Site based on the given URI.
  #
  # @return [Site] a new instance of Site
  def initialize(uri = T.unsafe(nil)); end

  # Returns true is scheme, host and port are '=='
  def ==(rhs); end

  # Returns address String.
  def addr; end

  # Same as ==.
  #
  # @return [Boolean]
  def eql?(rhs); end

  def hash; end

  # Host String.
  def host; end

  # Host String.
  def host=(_arg0); end

  # Host String.
  def hostname; end

  def inspect; end

  # Returns true if scheme, host and port of the given URI matches with this.
  def match(uri); end

  # Port number.
  def port; end

  # Port number.
  def port=(_arg0); end

  # Protocol scheme.
  def scheme; end

  # Protocol scheme.
  def scheme=(_arg0); end

  def to_s; end
end

HTTPClient::Site::EMPTY = T.let(T.unsafe(nil), HTTPClient::Site)

# Wraps up a Socket for method interception.
module HTTPClient::SocketWrap
  def initialize(socket, *args); end

  def <<(str); end
  def close; end

  # @return [Boolean]
  def closed?; end

  # @return [Boolean]
  def eof?; end

  def flush; end
  def gets(rs); end
  def read(size, buf = T.unsafe(nil)); end
  def readpartial(size, buf = T.unsafe(nil)); end
  def sync; end
  def sync=(sync); end
end

module HTTPClient::Timeout; end

# Raised for indicating a timeout error.
class HTTPClient::TimeoutError < ::RuntimeError; end

# A module for common function.
module HTTPClient::Util
  # Keyword argument to hash helper.
  # args:: given arguments.
  # *field:: a list of arguments to be extracted.
  #
  # Returns hash which has defined keys. When a Hash given, returns it
  # including undefined keys. When an Array given, returns a Hash which only
  # includes defined keys.
  def argument_to_hash(args, *field); end

  # @return [Boolean]
  def http?(uri); end

  # Checks if the given URI is https.
  #
  # @return [Boolean]
  def https?(uri); end

  # Keyword argument helper.
  # args:: given arguments.
  # *field:: a list of arguments to be extracted.
  #
  # You can extract 3 arguments (a, b, c) with:
  #
  #   include Util
  #   def my_method(*args)
  #     a, b, c = keyword_argument(args, :a, :b, :c)
  #     ...
  #   end
  #   my_method(1, 2, 3)
  #   my_method(:b => 2, :a = 1)
  #
  # instead of;
  #
  #   def my_method(a, b, c)
  #     ...
  #   end
  def keyword_argument(args, *field); end

  def warning(message); end

  private

  # Finds a value of a Hash.
  def hash_find_value(hash, &block); end

  # Try to require a feature and returns true/false if loaded
  #
  # It returns 'true' for the second require in contrast of the standard
  # require returns false if the feature is already loaded.
  def try_require(feature); end

  # Returns parent directory URI of the given URI.
  def uri_dirname(uri); end

  # Returns true if the given 2 URIs have a part_of relationship.
  # * the same scheme
  # * the same host String (no host resolution or IP-addr conversion)
  # * the same port number
  # * target URI's path starts with base URI's path.
  def uri_part_of(uri, part); end

  # Gets an URI instance.
  def urify(uri); end

  class << self
    # Finds a value of a Hash.
    def hash_find_value(hash, &block); end

    # Try to require a feature and returns true/false if loaded
    #
    # It returns 'true' for the second require in contrast of the standard
    # require returns false if the feature is already loaded.
    def try_require(feature); end

    # Returns parent directory URI of the given URI.
    def uri_dirname(uri); end

    # Returns true if the given 2 URIs have a part_of relationship.
    # * the same scheme
    # * the same host String (no host resolution or IP-addr conversion)
    # * the same port number
    # * target URI's path starts with base URI's path.
    def uri_part_of(uri, part); end

    # Gets an URI instance.
    def urify(uri); end
  end
end

HTTPClient::Util::AddressableEnabled = T.let(T.unsafe(nil), TrueClass)

class HTTPClient::Util::AddressableURI < ::Addressable::URI
  def authority; end
  def hostname; end
  def port; end
end

HTTPClient::VERSION = T.let(T.unsafe(nil), String)

# Authentication filter for handling authentication negotiation between
# Web server.  Parses 'WWW-Authentication' header in response and
# generates 'Authorization' header in request.
#
# Authentication filter is implemented using request filter of HTTPClient.
# It traps HTTP response header and maintains authentication state, and
# traps HTTP request header for inserting necessary authentication header.
#
# WWWAuth has sub filters (BasicAuth, DigestAuth, NegotiateAuth and
# SSPINegotiateAuth) and delegates some operations to it.
# NegotiateAuth requires 'ruby/ntlm' module (rubyntlm gem).
# SSPINegotiateAuth requires 'win32/sspi' module (rubysspi gem).
class HTTPClient::WWWAuth < ::HTTPClient::AuthFilterBase
  # Creates new WWWAuth.
  #
  # @return [WWWAuth] a new instance of WWWAuth
  def initialize; end

  # Returns the value of attribute basic_auth.
  def basic_auth; end

  # Returns the value of attribute digest_auth.
  def digest_auth; end

  # Filter API implementation.  Traps HTTP request and insert
  # 'Authorization' header if needed.
  def filter_request(req); end

  # Filter API implementation.  Traps HTTP response and parses
  # 'WWW-Authenticate' header.
  #
  # This remembers the challenges for all authentication methods
  # available to the client. On the subsequent retry of the request,
  # filter_request will select the strongest method.
  def filter_response(req, res); end

  # Returns the value of attribute negotiate_auth.
  def negotiate_auth; end

  # Returns the value of attribute oauth.
  def oauth; end

  # Resets challenge state.  See sub filters for more details.
  def reset_challenge; end

  # Set authentication credential.  See sub filters for more details.
  def set_auth(uri, user, passwd); end

  # Returns the value of attribute sspi_negotiate_auth.
  def sspi_negotiate_auth; end
end

class OpenSSL::X509::Store
  def initialize(*args); end

  # Returns the value of attribute _httpclient_cert_store_items.
  def _httpclient_cert_store_items; end

  def add_cert(cert); end
  def add_file(cert); end
  def add_path(cert); end
end

class WebAgent; end

class WebAgent::Cookie
  include ::WebAgent::CookieUtils

  # @return [Cookie] a new instance of Cookie
  def initialize; end

  # Sets the attribute discard
  #
  # @param value the value to set the attribute discard to.
  def discard=(_arg0); end

  # @return [Boolean]
  def discard?; end

  # Returns the value of attribute domain.
  def domain; end

  # Sets the attribute domain
  #
  # @param value the value to set the attribute domain to.
  def domain=(_arg0); end

  # Sets the attribute domain_orig
  #
  # @param value the value to set the attribute domain_orig to.
  def domain_orig=(_arg0); end

  # @return [Boolean]
  def domain_orig?; end

  # for Netscape Cookie
  def expires; end

  # for Netscape Cookie
  def expires=(_arg0); end

  def flag; end

  # Sets the attribute http_only
  #
  # @param value the value to set the attribute http_only to.
  def http_only=(_arg0); end

  # @return [Boolean]
  def http_only?; end

  def join_quotedstr(array, sep); end

  # @return [Boolean]
  def match?(url); end

  # Returns the value of attribute name.
  def name; end

  # Sets the attribute name
  #
  # @param value the value to set the attribute name to.
  def name=(_arg0); end

  # Sets the attribute override
  #
  # @param value the value to set the attribute override to.
  def override=(_arg0); end

  # @return [Boolean]
  def override?; end

  def parse(str, url); end

  # Returns the value of attribute path.
  def path; end

  # Sets the attribute path
  #
  # @param value the value to set the attribute path to.
  def path=(_arg0); end

  # Sets the attribute path_orig
  #
  # @param value the value to set the attribute path_orig to.
  def path_orig=(_arg0); end

  # @return [Boolean]
  def path_orig?; end

  # Sets the attribute secure
  #
  # @param value the value to set the attribute secure to.
  def secure=(_arg0); end

  # @return [Boolean]
  def secure?; end

  def set_flag(flag); end

  # Returns the value of attribute url.
  def url; end

  # Sets the attribute url
  #
  # @param value the value to set the attribute url to.
  def url=(_arg0); end

  # Sets the attribute use
  #
  # @param value the value to set the attribute use to.
  def use=(_arg0); end

  # @return [Boolean]
  def use?; end

  # Returns the value of attribute value.
  def value; end

  # Sets the attribute value
  #
  # @param value the value to set the attribute value to.
  def value=(_arg0); end

  private

  def normalize_cookie_value(value); end

  class << self
    def parse(str, url); end
  end
end

WebAgent::Cookie::DISCARD = T.let(T.unsafe(nil), Integer)
WebAgent::Cookie::DOMAIN = T.let(T.unsafe(nil), Integer)
WebAgent::Cookie::HTTP_ONLY = T.let(T.unsafe(nil), Integer)
WebAgent::Cookie::OVERRIDE = T.let(T.unsafe(nil), Integer)
WebAgent::Cookie::OVERRIDE_OK = T.let(T.unsafe(nil), Integer)
WebAgent::Cookie::PATH = T.let(T.unsafe(nil), Integer)
WebAgent::Cookie::SECURE = T.let(T.unsafe(nil), Integer)
WebAgent::Cookie::USE = T.let(T.unsafe(nil), Integer)

class WebAgent::CookieManager
  include ::WebAgent::CookieUtils

  # @return [CookieManager] a new instance of CookieManager
  def initialize(file = T.unsafe(nil)); end

  # Returns the value of attribute accept_domains.
  def accept_domains; end

  # Sets the attribute accept_domains
  #
  # @param value the value to set the attribute accept_domains to.
  def accept_domains=(_arg0); end

  def add(given); end

  # Who use it?
  def check_cookie_accept_domain(domain); end

  def check_expired_cookies; end
  def cookie_value(url); end

  # Returns the value of attribute cookies.
  def cookies; end

  def cookies=(cookies); end

  # Returns the value of attribute cookies_file.
  def cookies_file; end

  # Sets the attribute cookies_file
  #
  # @param value the value to set the attribute cookies_file to.
  def cookies_file=(_arg0); end

  def find(url); end
  def load_cookies; end
  def parse(str, url); end

  # Returns the value of attribute reject_domains.
  def reject_domains; end

  # Sets the attribute reject_domains
  #
  # @param value the value to set the attribute reject_domains to.
  def reject_domains=(_arg0); end

  def save_all_cookies(force = T.unsafe(nil), save_unused = T.unsafe(nil), save_discarded = T.unsafe(nil)); end
  def save_cookies(force = T.unsafe(nil)); end

  private

  def check_domain(domain, hostname, override); end

  # not tested well; used only netscape_rule = true.
  def cookie_error(err, override); end

  def make_cookie_str(cookie_list); end

  # for conformance to http://wp.netscape.com/newsref/std/cookie_spec.html
  def netscape_rule; end

  # for conformance to http://wp.netscape.com/newsref/std/cookie_spec.html
  def netscape_rule=(_arg0); end
end

# errors
class WebAgent::CookieManager::Error < ::StandardError; end

class WebAgent::CookieManager::ErrorOverrideOK < ::WebAgent::CookieManager::Error; end
WebAgent::CookieManager::SPECIAL_DOMAIN = T.let(T.unsafe(nil), Array)
class WebAgent::CookieManager::SpecialError < ::WebAgent::CookieManager::Error; end

module WebAgent::CookieUtils
  def domain_match(host, domain); end

  # @return [Boolean]
  def head_match?(str1, str2); end

  # @return [Boolean]
  def tail_match?(str1, str2); end
end

# An Array class that already includes the MonitorMixin module.
class WebAgent::SynchronizedArray < ::Array
  include ::MonitorMixin
end
