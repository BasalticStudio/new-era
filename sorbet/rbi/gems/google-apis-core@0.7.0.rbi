# typed: true

# DO NOT EDIT MANUALLY
# This is an autogenerated file for types exported from the `google-apis-core` gem.
# Please instead update this file by running `bin/tapioca gem google-apis-core`.

module Google; end

module Google::Apis
  class << self
    # Create and configure a logger
    #
    # @return [Logger]
    def default_logger; end

    # @return [Logger] The logger.
    def logger; end

    # Sets the attribute logger
    #
    # @param value the value to set the attribute logger to.
    def logger=(_arg0); end

    # Check to see if client is being used in a Rails environment and get the logger if present.
    # Setting the ENV variable 'GOOGLE_API_USE_RAILS_LOGGER' to false will force the client
    # to use its own logger.
    #
    # @return [Logger]
    def rails_logger; end
  end
end

# A 401 HTTP error occurred.
class Google::Apis::AuthorizationError < ::Google::Apis::Error; end

# Error class for problems in batch requests.
class Google::Apis::BatchError < ::Google::Apis::Error; end

# A 4xx class HTTP error occurred.
class Google::Apis::ClientError < ::Google::Apis::Error; end

# General client options
class Google::Apis::ClientOptions < ::Struct
  # @return [String] Name of the application, for identification in the User-Agent header
  def application_name; end

  # @return [String] Name of the application, for identification in the User-Agent header
  def application_name=(_); end

  # @return [String] Version of the application, for identification in the User-Agent header
  def application_version; end

  # @return [String] Version of the application, for identification in the User-Agent header
  def application_version=(_); end

  # @return [Boolean] True if raw HTTP requests should be logged
  def log_http_requests; end

  # @return [Boolean] True if raw HTTP requests should be logged
  def log_http_requests=(_); end

  # @return [Fixnum] How long, in seconds, before failed connections time out
  def open_timeout_sec; end

  # @return [Fixnum] How long, in seconds, before failed connections time out
  def open_timeout_sec=(_); end

  # @return [String] URL of a proxy server
  def proxy_url; end

  # @return [String] URL of a proxy server
  def proxy_url=(_); end

  # @return [Fixnum] How long, in seconds, before requests time out
  def read_timeout_sec; end

  # @return [Fixnum] How long, in seconds, before requests time out
  def read_timeout_sec=(_); end

  # Returns the value of attribute send_timeout_sec
  #
  # @return [Object] the current value of send_timeout_sec
  def send_timeout_sec; end

  # Sets the attribute send_timeout_sec
  #
  # @param value [Object] the value to set the attribute send_timeout_sec to.
  # @return [Object] the newly set value
  def send_timeout_sec=(_); end

  # Get the default options
  #
  # @return [Boolean] True if gzip compression needs to be enabled
  # @return [Google::Apis::ClientOptions]
  def transparent_gzip_decompression; end

  # Get the default options
  #
  # @return [Boolean] True if gzip compression needs to be enabled
  # @return [Google::Apis::ClientOptions]
  def transparent_gzip_decompression=(_); end

  class << self
    def [](*_arg0); end

    # Get the default options
    #
    # @return [Boolean] True if gzip compression needs to be enabled
    # @return [Google::Apis::ClientOptions]
    def default; end

    def inspect; end
    def members; end
    def new(*_arg0); end
  end
end

module Google::Apis::Core; end

# Command for executing most basic API request with JSON requests/responses
class Google::Apis::Core::ApiCommand < ::Google::Apis::Core::HttpCommand
  # @param method [symbol] HTTP method
  # @param url [String, Addressable::URI, Addressable::Template] HTTP URL or template
  # @param body [String, #read] Request body
  # @return [ApiCommand] a new instance of ApiCommand
  def initialize(method, url, body: T.unsafe(nil), client_version: T.unsafe(nil)); end

  # @return [Boolean]
  def allow_form_encoding?; end

  # Check the response and raise error if needed
  #
  # @param status [Fixnum] HTTP status code of response
  # @param header [Hash] HTTP response headers
  # @param body [String] HTTP response body
  # @param message [String] Error message text
  # @raise [Google::Apis::ServerError] An error occurred on the server and the request can be retried
  # @raise [Google::Apis::ClientError] The request is invalid and should not be retried without modification
  # @raise [Google::Apis::AuthorizationError] Authorization is required
  # @return [void]
  def check_status(status, header = T.unsafe(nil), body = T.unsafe(nil), message = T.unsafe(nil)); end

  # Client library version.
  #
  # @return [String]
  def client_version; end

  # Client library version.
  #
  # @return [String]
  def client_version=(_arg0); end

  # Deserialize the response body if present
  #
  # noinspection RubyUnusedLocalVariable
  #
  # @param content_type [String] Content type of body
  # @param body [String, #read] Response body
  # @return [Object] Response object
  def decode_response_body(content_type, body); end

  # Serialize the request body
  #
  # @return [void]
  def prepare!; end

  # Request body to serialize
  #
  # @return [Object]
  def request_object; end

  # Request body to serialize
  #
  # @return [Object]
  def request_object=(_arg0); end

  # JSON serializer for request objects
  #
  # @return [Google::Apis::Core::JsonRepresentation]
  def request_representation; end

  # JSON serializer for request objects
  #
  # @return [Google::Apis::Core::JsonRepresentation]
  def request_representation=(_arg0); end

  # Class to instantiate when de-serializing responses
  #
  # @return [Object]
  def response_class; end

  # Class to instantiate when de-serializing responses
  #
  # @return [Object]
  def response_class=(_arg0); end

  # JSON serializer for response objects
  #
  # @return [Google::Apis::Core::JsonRepresentation]
  def response_representation; end

  # JSON serializer for response objects
  #
  # @return [Google::Apis::Core::JsonRepresentation]
  def response_representation=(_arg0); end

  private

  # Extracts details from a v1 error message
  #
  # @param error [Hash] Parsed JSON
  # @return [Array<(String, String)>] Error reason and message
  def extract_v1_error_details(error); end

  # Extracts details from a v2error message
  #
  # @param error [Hash] Parsed JSON
  # @return [Array<(String, String)>] Error reason and message
  def extract_v2_error_details(error); end

  # Convert field names from ruby conventions to original names in JSON
  #
  # @param fields [String] Value of 'fields' param
  # @return [String] Updated header value
  def normalize_fields_param(fields); end

  # Attempt to parse a JSON error message
  #
  # @param body [String] HTTP response body
  # @return [Array<(String, String)>] Error reason and message
  def parse_error(body); end

  def set_api_client_header; end
  def set_user_project_header; end
end

Google::Apis::Core::ApiCommand::ERROR_REASON_MAPPING = T.let(T.unsafe(nil), Hash)
Google::Apis::Core::ApiCommand::FIELDS_PARAM = T.let(T.unsafe(nil), String)
Google::Apis::Core::ApiCommand::JSON_CONTENT_TYPE = T.let(T.unsafe(nil), String)

# Base service for all APIs. Not to be used directly.
class Google::Apis::Core::BaseService
  include ::Google::Apis::Core::Logging

  # @api private
  # @param root_url [String, Addressable::URI] Root URL for the API
  # @param base_path [String, Addressable::URI] Additional path prefix for all API methods
  # @return [BaseService] a new instance of BaseService
  def initialize(root_url, base_path, client_name: T.unsafe(nil), client_version: T.unsafe(nil)); end

  # @return [Signet::OAuth2::Client] OAuth2 credentials
  def authorization; end

  # @return [Signet::OAuth2::Client] OAuth2 credentials
  def authorization=(authorization); end

  # Additional path prefix for all API methods
  #
  # @return [Addressable::URI]
  def base_path; end

  # Additional path prefix for all API methods
  #
  # @return [Addressable::URI]
  def base_path=(_arg0); end

  # Perform a batch request. Calls made within the block are sent in a single network
  # request to the server.
  #
  # @example
  #   service.batch do |s|
  #   s.get_item(id1) do |res, err|
  #   # process response for 1st call
  #   end
  #   # ...
  #   s.get_item(idN) do |res, err|
  #   # process response for Nth call
  #   end
  #   end
  # @param options [Hash, Google::Apis::RequestOptions] Request-specific options
  # @return [void]
  # @yield [self]
  def batch(options = T.unsafe(nil)); end

  # Alternate path prefix for all batch methods
  #
  # @return [Addressable::URI]
  def batch_path; end

  # Alternate path prefix for all batch methods
  #
  # @return [Addressable::URI]
  def batch_path=(_arg0); end

  # Perform a batch upload request. Calls made within the block are sent in a single network
  # request to the server. Batch uploads are useful for uploading multiple small files. For larger
  # files, use single requests which use a resumable upload protocol.
  #
  # @example
  #   service.batch do |s|
  #   s.insert_item(upload_source: 'file1.txt') do |res, err|
  #   # process response for 1st call
  #   end
  #   # ...
  #   s.insert_item(upload_source: 'fileN.txt') do |res, err|
  #   # process response for Nth call
  #   end
  #   end
  # @param options [Hash, Google::Apis::RequestOptions] Request-specific options
  # @return [void]
  # @yield [self]
  def batch_upload(options = T.unsafe(nil)); end

  # Get the current HTTP client
  #
  # @return [HTTPClient]
  def client; end

  # HTTP client
  #
  # @return [HTTPClient]
  def client=(_arg0); end

  # Client library name.
  #
  # @return [String]
  def client_name; end

  # Client library name.
  #
  # @return [String]
  def client_name=(_arg0); end

  # General settings
  #
  # @return [Google::Apis::ClientOptions]
  def client_options; end

  # General settings
  #
  # @return [Google::Apis::ClientOptions]
  def client_options=(_arg0); end

  # Client library version.
  #
  # @return [String]
  def client_version; end

  # Client library version.
  #
  # @return [String]
  def client_version=(_arg0); end

  # Executes a given query with paging, automatically retrieving
  # additional pages as necessary. Requires a block that returns the
  # result set of a page. The current page token is supplied as an argument
  # to the block.
  #
  # Note: The returned enumerable also contains a `last_result` field
  # containing the full result of the last query executed.
  #
  # @example Retrieve all files,
  #   file_list = service.fetch_all { |token, s| s.list_files(page_token: token) }
  #   file_list.each { |f| ... }
  # @param max [Fixnum] Maximum number of items to iterate over. Defaults to nil -- no upper bound.
  # @param items [Symbol] Name of the field in the result containing the items. Defaults to :items
  # @param cache [Boolean] True (default) if results should be cached so multiple iterations can be used.
  # @return [Enumerble]
  # @since 0.9.4
  # @yield [token, service] Current page token & service instance
  # @yieldparam token [String] Current page token to be used in the query
  # @yieldparam Current [service] service instance
  def fetch_all(max: T.unsafe(nil), items: T.unsafe(nil), cache: T.unsafe(nil), response_page_token: T.unsafe(nil), &block); end

  # Simple escape hatch for making API requests directly to a given
  # URL. This is not intended to be used as a generic HTTP client
  # and should be used only in cases where no service method exists
  # (e.g. fetching an export link for a Google Drive file.)
  #
  # @param method [Symbol] HTTP method as symbol (e.g. :get, :post, :put, ...)
  # @param url [String] URL to call
  # @param params [Hash<String,String>] Optional hash of query parameters
  # @param body [#read] Optional body for POST/PUT
  # @param download_dest [IO, String] IO stream or filename to receive content download
  # @param options [Google::Apis::RequestOptions] Request-specific options
  # @return [String] HTTP response body
  # @yield [result, err] Result & error if block supplied
  # @yieldparam result [String] HTTP response body
  # @yieldparam err [StandardError] error object if request failed
  def http(method, url, params: T.unsafe(nil), body: T.unsafe(nil), download_dest: T.unsafe(nil), options: T.unsafe(nil), &block); end

  # Default options for all requests
  #
  # @return [Google::Apis::RequestOptions]
  def request_options; end

  # Default options for all requests
  #
  # @return [Google::Apis::RequestOptions]
  def request_options=(_arg0); end

  # Root URL (host/port) for the API
  #
  # @return [Addressable::URI]
  def root_url; end

  # Root URL (host/port) for the API
  #
  # @return [Addressable::URI]
  def root_url=(_arg0); end

  # Alternate path prefix for media uploads
  #
  # @return [Addressable::URI]
  def upload_path; end

  # Alternate path prefix for media uploads
  #
  # @return [Addressable::URI]
  def upload_path=(_arg0); end

  protected

  # Update commands with service-specific options. To be implemented by subclasses
  #
  # @param _command [Google::Apis::Core::HttpCommand]
  def apply_command_defaults(_command); end

  # Execute the request. If a batch is in progress, the request is added to the batch instead.
  #
  # @param command [Google::Apis::Core::HttpCommand] Command to execute
  # @raise [Google::Apis::ServerError] An error occurred on the server and the request can be retried
  # @raise [Google::Apis::ClientError] The request is invalid and should not be retried without modification
  # @raise [Google::Apis::AuthorizationError] Authorization is required
  # @return [Object] response object if command executed and no callback supplied
  # @yield [result, err] Result & error if block supplied
  def execute_or_queue_command(command, &callback); end

  # Create a new download command.
  #
  # @param method [symbol] HTTP method for uploading (typically :get)
  # @param path [String] Additional path to download endpoint, appended to API base path
  # @param options [Hash, Google::Apis::RequestOptions] Request-specific options
  # @return [Google::Apis::Core::DownloadCommand]
  def make_download_command(method, path, options); end

  # Create a new command.
  #
  # @param method [symbol] HTTP method (:get, :post, :delete, etc...)
  # @param path [String] Additional path, appended to API base path
  # @param options [Hash, Google::Apis::RequestOptions] Request-specific options
  # @return [Google::Apis::Core::DownloadCommand]
  def make_simple_command(method, path, options); end

  # Create a new storage download command. This is specifically for storage because
  # we want to return response header too in the response.
  #
  # @param method [symbol] HTTP method for uploading (typically :get)
  # @param path [String] Additional path to download endpoint, appended to API base path
  # @param options [Hash, Google::Apis::RequestOptions] Request-specific options
  # @return [Google::Apis::Core::StorageDownloadCommand]
  def make_storage_download_command(method, path, options); end

  # Create a new upload command.
  #
  # @param method [symbol] HTTP method for uploading (typically :put or :post)
  # @param path [String] Additional path to upload endpoint, appended to API base path
  # @param options [Hash, Google::Apis::RequestOptions] Request-specific options
  # @return [Google::Apis::Core::UploadCommand]
  def make_upload_command(method, path, options); end

  private

  # Check if a batch is in progress
  #
  # @return [Boolean]
  def batch?; end

  # Get the current batch context
  #
  # @return [Google:Apis::Core::BatchRequest]
  def current_batch; end

  # Clear thread-local batch context
  def end_batch; end

  # Create a new HTTP client
  #
  # @return [HTTPClient]
  def new_client; end

  # Start a new thread-local batch context
  #
  # @param cmd [Google::Apis::Core::BatchCommand]
  def start_batch(cmd); end

  # Build the user agent header
  #
  # @return [String]
  def user_agent; end
end

# Base upload command. Not intended to be used directly
#
# @private
class Google::Apis::Core::BaseUploadCommand < ::Google::Apis::Core::ApiCommand
  # Ensure the content is readable and wrapped in an IO instance.
  #
  # @raise [Google::Apis::ClientError] if upload source is invalid
  # @return [void]
  def prepare!; end

  # Close IO stream when command done. Only closes the stream if it was opened by the command.
  def release!; end

  # Content type of the upload material
  #
  # @return [String]
  def upload_content_type; end

  # Content type of the upload material
  #
  # @return [String]
  def upload_content_type=(_arg0); end

  # Content, as UploadIO
  #
  # @return [Google::Apis::Core::UploadIO]
  def upload_io; end

  # Content, as UploadIO
  #
  # @return [Google::Apis::Core::UploadIO]
  def upload_io=(_arg0); end

  # File name or IO containing the content to upload
  #
  # @return [String, File, #read]
  def upload_source; end

  # File name or IO containing the content to upload
  #
  # @return [String, File, #read]
  def upload_source=(_arg0); end

  private

  # @return [Boolean]
  def streamable?(upload_source); end
end

Google::Apis::Core::BaseUploadCommand::CONTENT_TYPE_HEADER = T.let(T.unsafe(nil), String)
Google::Apis::Core::BaseUploadCommand::UPLOAD_CONTENT_LENGTH = T.let(T.unsafe(nil), String)
Google::Apis::Core::BaseUploadCommand::UPLOAD_CONTENT_TYPE_HEADER = T.let(T.unsafe(nil), String)
Google::Apis::Core::BaseUploadCommand::UPLOAD_PROTOCOL_HEADER = T.let(T.unsafe(nil), String)

# Wrapper request for batching multiple calls in a single server request
class Google::Apis::Core::BatchCommand < ::Google::Apis::Core::HttpCommand
  # @param method [symbol] HTTP method
  # @param url [String, Addressable::URI, Addressable::Template] HTTP URL or template
  # @return [BatchCommand] a new instance of BatchCommand
  def initialize(method, url); end

  # Add a new call to the batch request.
  #
  # @param call [Google::Apis::Core::HttpCommand] API Request to add
  # @return [Google::Apis::Core::BatchCommand] self
  # @yield [result, err] Result & error when response available
  def add(call, &block); end

  protected

  # Deconstruct the batch response and process the individual results
  #
  # @param content_type [String] Content type of body
  # @param body [String, #read] Response body
  # @return [Object] Response object
  def decode_response_body(content_type, body); end

  def ensure_valid_command(command); end
  def header_to_id(content_id); end
  def id_to_header(call_id); end

  # Encode the batch request
  #
  # @raise [Google::Apis::BatchError] if batch is empty
  # @return [void]
  def prepare!; end

  def split_parts(body, boundary); end
end

Google::Apis::Core::BatchCommand::MULTIPART_MIXED = T.let(T.unsafe(nil), String)

# Wrapper request for batching multiple uploads in a single server request
class Google::Apis::Core::BatchUploadCommand < ::Google::Apis::Core::BatchCommand
  def ensure_valid_command(command); end
  def prepare!; end
end

# Deconstructs a raw HTTP response part
#
# @private
class Google::Apis::Core::CallDeserializer
  # Parse a batched response.
  #
  # @param call_response [String] the response to parse.
  # @return [Array<(Fixnum, Hash, String)>] Status, header, and response body.
  def to_http_response(call_response); end

  protected

  # Auxiliary method to split the header from the body in an HTTP response.
  #
  # @param response [String] the response to parse.
  # @return [Array<(HTTP::Message::Headers, String)>] the header and the body, separately.
  def split_header_and_body(response); end
end

# Serializes a command for embedding in a multipart batch request
#
# @private
class Google::Apis::Core::CallSerializer
  # Serialize a single batched call for assembling the multipart message
  #
  # @param call [Google::Apis::Core::HttpCommand] the call to serialize.
  # @return [IO] the serialized request
  def to_part(call); end

  protected

  def build_body(call); end
  def build_head(call); end
end

class Google::Apis::Core::CompositeIO
  # @return [CompositeIO] a new instance of CompositeIO
  def initialize(*ios); end

  def length; end
  def pos; end
  def pos=(pos); end
  def read(length = T.unsafe(nil), buf = T.unsafe(nil)); end
  def rewind; end
  def size; end
end

# Streaming/resumable media download support
class Google::Apis::Core::DownloadCommand < ::Google::Apis::Core::ApiCommand
  # File or IO to write content to
  #
  # @return [String, File, #write]
  def download_dest; end

  # File or IO to write content to
  #
  # @return [String, File, #write]
  def download_dest=(_arg0); end

  # Execute the upload request once. Overrides the default implementation to handle streaming/chunking
  # of file content.
  #
  # @param client [HTTPClient] HTTP client
  # @private
  # @raise [Google::Apis::ServerError] An error occurred on the server and the request can be retried
  # @raise [Google::Apis::ClientError] The request is invalid and should not be retried without modification
  # @raise [Google::Apis::AuthorizationError] Authorization is required
  # @return [Object]
  # @yield [result, err] Result or error if block supplied
  def execute_once(client, &block); end

  # Ensure the download destination is a writable stream.
  #
  # @return [void]
  def prepare!; end

  # Close IO stream when command done. Only closes the stream if it was opened by the command.
  def release!; end
end

Google::Apis::Core::DownloadCommand::OK_STATUS = T.let(T.unsafe(nil), Array)
Google::Apis::Core::DownloadCommand::RANGE_HEADER = T.let(T.unsafe(nil), String)

# Part of a multipart request for holding arbitrary content.
#
# @private
class Google::Apis::Core::FilePart
  # @param io [IO] IO stream
  # @param header [Hash] Additional headers
  # @return [FilePart] a new instance of FilePart
  def initialize(io, header = T.unsafe(nil)); end

  def to_io(boundary); end
end

# Adds to_hash to objects
module Google::Apis::Core::Hashable
  # Convert object to hash representation
  #
  # @return [Hash]
  def to_h; end

  class << self
    # Recursively serialize an object
    #
    # @param val [Object]
    # @return [Hash]
    def process_value(val); end
  end
end

# Command for HTTP request/response.
class Google::Apis::Core::HttpCommand
  include ::Google::Apis::Core::Logging

  # @param method [symbol] HTTP method
  # @param url [String, Addressable::URI, Addressable::Template] HTTP URL or template
  # @param body [String, #read] Request body
  # @return [HttpCommand] a new instance of HttpCommand
  def initialize(method, url, body: T.unsafe(nil)); end

  # @return [Boolean]
  def allow_form_encoding?; end

  # Update the request with any specified options.
  #
  # @param req_header [Hash] HTTP headers
  # @return [void]
  def apply_request_options(req_header); end

  # Check if attached credentials can be automatically refreshed
  #
  # @return [Boolean]
  def authorization_refreshable?; end

  # Request body
  #
  # @return [#read]
  def body; end

  # Request body
  #
  # @return [#read]
  def body=(_arg0); end

  # Check the response and raise error if needed
  #
  # @param status [Fixnum] HTTP status code of response
  # @param header [Hash] HTTP response headers
  # @param body [String] HTTP response body
  # @param message [String] Error message text
  # @raise [Google::Apis::ServerError] An error occurred on the server and the request can be retried
  # @raise [Google::Apis::ClientError] The request is invalid and should not be retried without modification
  # @raise [Google::Apis::AuthorizationError] Authorization is required
  # @return [void]
  def check_status(status, header = T.unsafe(nil), body = T.unsafe(nil), message = T.unsafe(nil)); end

  # HTTP Client
  #
  # @return [HTTPClient]
  def connection; end

  # HTTP Client
  #
  # @return [HTTPClient]
  def connection=(_arg0); end

  # Process the actual response body. Intended to be overridden by subclasses
  #
  # @param _content_type [String] Content type of body
  # @param body [String, #read] Response body
  # @return [Object]
  def decode_response_body(_content_type, body); end

  # Process an error response
  #
  # @param err [StandardError] Error object
  # @param rethrow [Boolean] True if error should be raised again after handling
  # @raise [StandardError] if no block
  # @return [void]
  # @yield [nil, err] if block given
  def error(err, rethrow: T.unsafe(nil), &block); end

  # Execute the command, retrying as necessary
  #
  # @param client [HTTPClient] HTTP client
  # @raise [Google::Apis::ServerError] An error occurred on the server and the request can be retried
  # @raise [Google::Apis::ClientError] The request is invalid and should not be retried without modification
  # @raise [Google::Apis::AuthorizationError] Authorization is required
  # @return [Object]
  # @yield [result, err] Result or error if block supplied
  def execute(client); end

  # Execute the command once.
  #
  # @param client [HTTPClient] HTTP client
  # @private
  # @raise [Google::Apis::ServerError] An error occurred on the server and the request can be retried
  # @raise [Google::Apis::ClientError] The request is invalid and should not be retried without modification
  # @raise [Google::Apis::AuthorizationError] Authorization is required
  # @return [Object]
  def execute_once(client); end

  # HTTP headers
  #
  # @return [Hash]
  def header; end

  # HTTP headers
  #
  # @return [Hash]
  def header=(_arg0); end

  # HTTP method
  #
  # @return [symbol]
  def method; end

  # HTTP method
  #
  # @return [symbol]
  def method=(_arg0); end

  # Request options
  #
  # @return [Google::Apis::RequestOptions]
  def options; end

  # Request options
  #
  # @return [Google::Apis::RequestOptions]
  def options=(_arg0); end

  # Path params for URL Template
  #
  # @return [Hash]
  def params; end

  # Path params for URL Template
  #
  # @return [Hash]
  def params=(_arg0); end

  # Prepare the request (e.g. calculate headers, add query params, serialize data, etc) before sending
  #
  # @private
  # @return [void]
  def prepare!; end

  # Check the response and either decode body or raise error
  #
  # @param status [Fixnum] HTTP status code of response
  # @param header [Hash] Response headers
  # @param body [String, #read] Response body
  # @raise [Google::Apis::ServerError] An error occurred on the server and the request can be retried
  # @raise [Google::Apis::ClientError] The request is invalid and should not be retried without modification
  # @raise [Google::Apis::AuthorizationError] Authorization is required
  # @return [Object] Response object
  def process_response(status, header, body); end

  # Query params
  #
  # @return [Hash]
  def query; end

  # Query params
  #
  # @return [Hash]
  def query=(_arg0); end

  # Refresh the authorization authorization after a 401 error
  #
  # @private
  # @return [void]
  def refresh_authorization; end

  # Release any resources used by this command
  #
  # @private
  # @return [void]
  def release!; end

  # Process a success response
  #
  # @param result [Object] Result object
  # @return [Object] result if no block given
  # @yield [result, nil] if block given
  def success(result, &block); end

  # HTTP request URL
  #
  # @return [String, Addressable::URI]
  def url; end

  # HTTP request URL
  #
  # @return [String, Addressable::URI]
  def url=(_arg0); end

  private

  # @return [Boolean]
  def form_encoded?; end

  def map_http_status(http_status); end
  def normalize_query_value(v); end
  def normalize_query_values(input); end
  def opencensus_begin_span; end
  def opencensus_end_span; end
  def safe_object_representation(obj); end
  def safe_response_representation(http_res); end
end

Google::Apis::Core::HttpCommand::RETRIABLE_ERRORS = T.let(T.unsafe(nil), Array)
Google::Apis::Core::HttpCommand::UNSAFE_CLASS_NAMES = T.let(T.unsafe(nil), Array)

module Google::Apis::Core::JsonObjectSupport
  mixes_in_class_methods ::Google::Apis::Core::JsonObjectSupport::ClassMethods

  def to_json(*a); end

  class << self
    # @private
    def included(base); end
  end
end

module Google::Apis::Core::JsonObjectSupport::ClassMethods
  def from_json(json); end
end

# Part of a multipart request for holding JSON data
#
# @private
class Google::Apis::Core::JsonPart
  # @param value [String] JSON content
  # @param header [Hash] Additional headers
  # @return [JsonPart] a new instance of JsonPart
  def initialize(value, header = T.unsafe(nil)); end

  def to_io(boundary); end
end

# Base decorator for JSON representers
#
# @see https://github.com/apotonick/representable
class Google::Apis::Core::JsonRepresentation < ::Representable::Decorator
  include ::Representable::Hash
  include ::Representable::JSON
  include ::Google::Apis::Core::JsonRepresentationSupport
  extend ::Representable::JSON::ClassMethods
  extend ::Google::Apis::Core::JsonRepresentationSupport::JsonSupport
end

# Support for serializing hashes + property value/nil/unset tracking
# To be included in representers as a feature.
#
# @private
module Google::Apis::Core::JsonRepresentationSupport
  mixes_in_class_methods ::Google::Apis::Core::JsonRepresentationSupport::JsonSupport

  class << self
    # @private
    def included(base); end
  end
end

# @private
module Google::Apis::Core::JsonRepresentationSupport::JsonSupport
  # Define a collection property
  #
  # @param name [String] Property name
  # @param options [Hash]
  def collection(name, options = T.unsafe(nil)); end

  # Returns a customized getter function for Representable. Allows
  # indifferent hash/attribute access.
  #
  # @param name [String] Property name
  # @return [Proc]
  def getter_fn(name); end

  # Define a hash property
  #
  # @param name [String] Property name
  # @param options [Hash]
  def hash(name = T.unsafe(nil), options = T.unsafe(nil)); end

  # Returns a customized function for Representable that checks whether or not
  # an attribute should be serialized. Allows proper patch semantics by distinguishing
  # between nil & unset values
  #
  # @param name [String] Property name
  # @return [Proc]
  def if_fn(name); end

  # Define a single value property
  #
  # @param name [String] Property name
  # @param options [Hash]
  def property(name, options = T.unsafe(nil)); end

  def set_default_options(name, options); end
end

# Logging support
module Google::Apis::Core::Logging
  # Get the logger instance
  #
  # @return [Logger]
  def logger; end
end

# Helper for building multipart requests
class Google::Apis::Core::Multipart
  # @param content_type [String] Content type for the multipart request
  # @param boundary [String] Part delimiter
  # @return [Multipart] a new instance of Multipart
  def initialize(content_type: T.unsafe(nil), boundary: T.unsafe(nil)); end

  # Append JSON data part
  #
  # @param body [String] JSON text
  # @param content_id [String] Optional unique ID of this part
  # @return [self]
  def add_json(body, content_id: T.unsafe(nil)); end

  # Append arbitrary data as a part
  #
  # @param upload_io [IO] IO stream
  # @param content_id [String] Optional unique ID of this part
  # @return [self]
  def add_upload(upload_io, content_type: T.unsafe(nil), content_id: T.unsafe(nil)); end

  # Assemble the multipart requests
  #
  # @return [IO] IO stream
  def assemble; end

  # @return [String] Content type header
  def content_type; end
end

Google::Apis::Core::Multipart::MULTIPART_RELATED = T.let(T.unsafe(nil), String)

# Implementation of the multipart upload protocol
class Google::Apis::Core::MultipartUploadCommand < ::Google::Apis::Core::BaseUploadCommand
  # Encode the multipart request
  #
  # @raise [Google::Apis::ClientError] if upload source is invalid
  # @return [void]
  def prepare!; end
end

Google::Apis::Core::MultipartUploadCommand::MULTIPART_PROTOCOL = T.let(T.unsafe(nil), String)
Google::Apis::Core::MultipartUploadCommand::MULTIPART_RELATED = T.let(T.unsafe(nil), String)

# Helper class for enumerating over a result set requiring multiple fetches
class Google::Apis::Core::PagedResults
  include ::Enumerable

  # @param service [BaseService] Current service instance
  # @param max [Fixnum] Maximum number of items to iterate over. Nil if no limit
  # @param cache [Boolean] True (default) if results should be cached so multiple iterations can be used.
  # @param items [Symbol] Name of the field in the result containing the items. Defaults to :items
  # @return [PagedResults] a new instance of PagedResults
  def initialize(service, max: T.unsafe(nil), items: T.unsafe(nil), cache: T.unsafe(nil), response_page_token: T.unsafe(nil), &block); end

  # Iterates over result set, fetching additional pages as needed
  def each; end

  # Returns the value of attribute last_result.
  def last_result; end
end

# Implementation of the raw upload protocol
class Google::Apis::Core::RawUploadCommand < ::Google::Apis::Core::BaseUploadCommand
  # Ensure the content is readable and wrapped in an {{Google::Apis::Core::UploadIO}} instance.
  #
  # @raise [Google::Apis::ClientError] if upload source is invalid
  # @return [void]
  def prepare!; end
end

Google::Apis::Core::RawUploadCommand::RAW_PROTOCOL = T.let(T.unsafe(nil), String)

# Implementation of the resumable upload protocol
class Google::Apis::Core::ResumableUploadCommand < ::Google::Apis::Core::BaseUploadCommand
  # Execute the upload request once. This will typically perform two HTTP requests -- one to initiate or query
  # for the status of the upload, the second to send the (remaining) content.
  #
  # @param client [HTTPClient] HTTP client
  # @private
  # @raise [Google::Apis::ServerError] An error occurred on the server and the request can be retried
  # @raise [Google::Apis::ClientError] The request is invalid and should not be retried without modification
  # @raise [Google::Apis::AuthorizationError] Authorization is required
  # @return [Object]
  # @yield [result, err] Result or error if block supplied
  def execute_once(client, &block); end

  # Reset upload to initial state.
  #
  # @raise [Google::Apis::ClientError] if upload source is invalid
  # @return [void]
  def prepare!; end

  # Check the to see if the upload is complete or needs to be resumed.
  #
  # @param status [Fixnum] HTTP status code of response
  # @param header [HTTP::Message::Headers] Response headers
  # @param body [String, #read] Response body
  # @raise [Google::Apis::ServerError] An error occurred on the server and the request can be retried
  # @raise [Google::Apis::ClientError] The request is invalid and should not be retried without modification
  # @raise [Google::Apis::AuthorizationError] Authorization is required
  # @return [Object] Response object
  def process_response(status, header, body); end

  # Query for the status of an incomplete upload
  #
  # @param client [HTTPClient] HTTP client
  # @raise [Google::Apis::ServerError] Unable to send the request
  # @return [HTTP::Message]
  def send_query_command(client); end

  def send_start_command(client); end

  # Send the actual content
  #
  # @param client [HTTPClient] HTTP client
  # @raise [Google::Apis::ServerError] Unable to send the request
  # @return [HTTP::Message]
  def send_upload_command(client); end
end

Google::Apis::Core::ResumableUploadCommand::BYTES_RECEIVED_HEADER = T.let(T.unsafe(nil), String)
Google::Apis::Core::ResumableUploadCommand::QUERY_COMMAND = T.let(T.unsafe(nil), String)
Google::Apis::Core::ResumableUploadCommand::RESUMABLE = T.let(T.unsafe(nil), String)
Google::Apis::Core::ResumableUploadCommand::START_COMMAND = T.let(T.unsafe(nil), String)
Google::Apis::Core::ResumableUploadCommand::STATUS_ACTIVE = T.let(T.unsafe(nil), String)
Google::Apis::Core::ResumableUploadCommand::STATUS_CANCELLED = T.let(T.unsafe(nil), String)
Google::Apis::Core::ResumableUploadCommand::STATUS_FINAL = T.let(T.unsafe(nil), String)
Google::Apis::Core::ResumableUploadCommand::UPLOAD_COMMAND = T.let(T.unsafe(nil), String)
Google::Apis::Core::ResumableUploadCommand::UPLOAD_COMMAND_HEADER = T.let(T.unsafe(nil), String)
Google::Apis::Core::ResumableUploadCommand::UPLOAD_OFFSET_HEADER = T.let(T.unsafe(nil), String)
Google::Apis::Core::ResumableUploadCommand::UPLOAD_STATUS_HEADER = T.let(T.unsafe(nil), String)
Google::Apis::Core::ResumableUploadCommand::UPLOAD_URL_HEADER = T.let(T.unsafe(nil), String)

# Streaming/resumable media download support specifically for storage API so that
# we can respond with response headers too.
class Google::Apis::Core::StorageDownloadCommand < ::Google::Apis::Core::DownloadCommand
  # Execute the upload request once. Overrides the default implementation to handle streaming/chunking
  # of file content.
  # Note: This method is overriden from DownloadCommand in order to respond back with
  # http header. All changes made to `execute_once` of DownloadCommand, should be made
  # here too.
  #
  # @param client [HTTPClient] HTTP client
  # @private
  # @raise [Google::Apis::ServerError] An error occurred on the server and the request can be retried
  # @raise [Google::Apis::ClientError] The request is invalid and should not be retried without modification
  # @raise [Google::Apis::AuthorizationError] Authorization is required
  # @return [Object]
  # @yield [result, err] Result or error if block supplied
  def execute_once(client, &block); end
end

# Core version
Google::Apis::Core::VERSION = T.let(T.unsafe(nil), String)

# Base error, capable of wrapping another
class Google::Apis::Error < ::StandardError
  # @return [Error] a new instance of Error
  def initialize(err, status_code: T.unsafe(nil), header: T.unsafe(nil), body: T.unsafe(nil)); end

  def backtrace; end

  # Returns the value of attribute body.
  def body; end

  # Returns the value of attribute header.
  def header; end

  def inspect; end

  # Returns the value of attribute status_code.
  def status_code; end
end

# Current operating system
#
# @private
Google::Apis::OS_VERSION = T.let(T.unsafe(nil), String)

# A 403 HTTP error occurred.
class Google::Apis::ProjectNotLinkedError < ::Google::Apis::Error; end

Google::Apis::ROOT = T.let(T.unsafe(nil), String)

# A 429 HTTP error occurred.
class Google::Apis::RateLimitError < ::Google::Apis::Error; end

# An exception that is raised if a redirect is required
class Google::Apis::RedirectError < ::Google::Apis::Error; end

# Request options
class Google::Apis::RequestOptions < ::Struct
  # @return [Fixnum] Version of the error format to request/expect.
  def api_format_version; end

  # @return [Fixnum] Version of the error format to request/expect.
  def api_format_version=(_); end

  # @return [Signet::OAuth2::Client, #apply(Hash)] OAuth2 credentials.
  def authorization; end

  # @return [Signet::OAuth2::Client, #apply(Hash)] OAuth2 credentials.
  def authorization=(_); end

  # @return [Float] The initial interval in seconds between tries.
  def base_interval; end

  # @return [Float] The initial interval in seconds between tries.
  def base_interval=(_); end

  # @return [Hash<String,String>] Additional HTTP headers to include in requests.
  def header; end

  # @return [Hash<String,String>] Additional HTTP headers to include in requests.
  def header=(_); end

  # @return [Fixnum] Total time in seconds that requests are allowed to keep being retried.
  def max_elapsed_time; end

  # @return [Fixnum] Total time in seconds that requests are allowed to keep being retried.
  def max_elapsed_time=(_); end

  # @return [Fixnum] The maximum interval in seconds that any individual retry can reach.
  def max_interval; end

  # @return [Fixnum] The maximum interval in seconds that any individual retry can reach.
  def max_interval=(_); end

  def merge(options); end

  # @return [rw] Each successive interval grows by this factor. A multipler of 1.5 means the next interval
  #   will be 1.5x the current interval.
  def multiplier; end

  # @return [rw] Each successive interval grows by this factor. A multipler of 1.5 means the next interval
  #   will be 1.5x the current interval.
  def multiplier=(_); end

  # @return [Boolean] True if unicode strings should be normalized in path parameters.
  def normalize_unicode; end

  # @return [Boolean] True if unicode strings should be normalized in path parameters.
  def normalize_unicode=(_); end

  # @return [Hash<String,String>] Additional HTTP URL query parameters to include in requests.
  def query; end

  # @return [Hash<String,String>] Additional HTTP URL query parameters to include in requests.
  def query=(_); end

  # @return [String] Project ID to charge quota, or `nil` to default to the credentials-specified project.
  def quota_project; end

  # @return [String] Project ID to charge quota, or `nil` to default to the credentials-specified project.
  def quota_project=(_); end

  # @return [Fixnum] Number of times to retry requests on server error.
  def retries; end

  # @return [Fixnum] Number of times to retry requests on server error.
  def retries=(_); end

  # @return [Boolean] True if response should be returned in raw form instead of deserialized.
  def skip_deserialization; end

  # @return [Boolean] True if response should be returned in raw form instead of deserialized.
  def skip_deserialization=(_); end

  # @return [Boolean] True if body object should be treated as raw text instead of an object.
  def skip_serialization; end

  # @return [Boolean] True if body object should be treated as raw text instead of an object.
  def skip_serialization=(_); end

  # @return [Boolean] Whether OpenCensus spans should be generated for requests. Default is true.
  def use_opencensus; end

  # @return [Boolean] Whether OpenCensus spans should be generated for requests. Default is true.
  def use_opencensus=(_); end

  class << self
    def [](*_arg0); end

    # Get the default options
    #
    # @return [Google::Apis::RequestOptions]
    def default; end

    def inspect; end
    def members; end
    def new(*_arg0); end
  end
end

# A 408 HTTP error occurred.
class Google::Apis::RequestTimeOutError < ::Google::Apis::ClientError; end

# A 5xx class HTTP error occurred.
class Google::Apis::ServerError < ::Google::Apis::Error; end

# An error which is raised when there is an unexpected response or other
# transport error that prevents an operation from succeeding.
class Google::Apis::TransmissionError < ::Google::Apis::Error; end
