# typed: true

# DO NOT EDIT MANUALLY
# This is an autogenerated file for types exported from the `rack-mini-profiler` gem.
# Please instead update this file by running `bin/tapioca gem rack-mini-profiler`.

# The PostgreSQL connection class. The interface for this class is based on
# {libpq}[http://www.postgresql.org/docs/current/libpq.html], the C
# application programmer's interface to PostgreSQL. Some familiarity with libpq
# is recommended, but not necessary.
#
# For example, to send query to the database on the localhost:
#
#    require 'pg'
#    conn = PG::Connection.open(:dbname => 'test')
#    res = conn.exec_params('SELECT $1 AS a, $2 AS b, $3 AS c', [1, 2, nil])
#    # Equivalent to:
#    #  res  = conn.exec('SELECT 1 AS a, 2 AS b, NULL AS c')
#
# See the PG::Result class for information on working with the results of a query.
#
# Many methods of this class have three variants kind of:
# 1. #exec - the base method which is an alias to #async_exec .
#    This is the method that should be used in general.
# 2. #async_exec - the async aware version of the method, implemented by libpq's async API.
# 3. #sync_exec - the method version that is implemented by blocking function(s) of libpq.
#
# Sync and async version of the method can be switched by Connection.async_api= , however it is not recommended to change the default.
class PG::Connection
  include ::PG::Constants

  # call-seq:
  #    conn.cancel() -> String
  #
  # Requests cancellation of the command currently being
  # processed.
  #
  # Returns +nil+ on success, or a string containing the
  # error message if a failure occurs.
  def async_cancel; end

  def async_describe_portal(_arg0); end
  def async_describe_prepared(_arg0); end

  # call-seq:
  #    conn.encrypt_password( password, username, algorithm=nil ) -> String
  #
  # This function is intended to be used by client applications that wish to send commands like <tt>ALTER USER joe PASSWORD 'pwd'</tt>.
  # It is good practice not to send the original cleartext password in such a command, because it might be exposed in command logs, activity displays, and so on.
  # Instead, use this function to convert the password to encrypted form before it is sent.
  #
  # The +password+ and +username+ arguments are the cleartext password, and the SQL name of the user it is for.
  # +algorithm+ specifies the encryption algorithm to use to encrypt the password.
  # Currently supported algorithms are +md5+ and +scram-sha-256+ (+on+ and +off+ are also accepted as aliases for +md5+, for compatibility with older server versions).
  # Note that support for +scram-sha-256+ was introduced in PostgreSQL version 10, and will not work correctly with older server versions.
  # If algorithm is omitted or +nil+, this function will query the server for the current value of the +password_encryption+ setting.
  # That can block, and will fail if the current transaction is aborted, or if the connection is busy executing another query.
  # If you wish to use the default algorithm for the server but want to avoid blocking, query +password_encryption+ yourself before calling #encrypt_password, and pass that value as the algorithm.
  #
  # Return value is the encrypted password.
  # The caller can assume the string doesn't contain any special characters that would require escaping.
  #
  # Available since PostgreSQL-10.
  # See also corresponding {libpq function}[https://www.postgresql.org/docs/current/libpq-misc.html#LIBPQ-PQENCRYPTPASSWORDCONN].
  def async_encrypt_password(password, username, algorithm = T.unsafe(nil)); end

  def async_exec(*args, &blk); end
  def async_exec_params(*_arg0); end
  def async_exec_prepared(*_arg0); end
  def async_exec_without_profiling(*_arg0); end
  def async_flush; end

  # call-seq:
  #    conn.get_copy_data( [ nonblock = false [, decoder = nil ]] ) -> Object
  #
  # Return one row of data, +nil+
  # if the copy is done, or +false+ if the call would
  # block (only possible if _nonblock_ is true).
  #
  # If _decoder_ is not set or +nil+, data is returned as binary string.
  #
  # If _decoder_ is set to a PG::Coder derivation, the return type depends on this decoder.
  # PG::TextDecoder::CopyRow decodes the received data fields from one row of PostgreSQL's
  # COPY text format to an Array of Strings.
  # Optionally the decoder can type cast the single fields to various Ruby types in one step,
  # if PG::TextDecoder::CopyRow#type_map is set accordingly.
  #
  # See also #copy_data.
  def async_get_copy_data(async = T.unsafe(nil), decoder = T.unsafe(nil)); end

  def async_get_last_result; end

  # call-seq:
  #    conn.get_result() -> PG::Result
  #    conn.get_result() {|pg_result| block }
  #
  # Blocks waiting for the next result from a call to
  # #send_query (or another asynchronous command), and returns
  # it. Returns +nil+ if no more results are available.
  #
  # Note: call this function repeatedly until it returns +nil+, or else
  # you will not be able to issue further commands.
  #
  # If the optional code block is given, it will be passed <i>result</i> as an argument,
  # and the PG::Result object will  automatically be cleared when the block terminates.
  # In this instance, <code>conn.exec</code> returns the value of the block.
  def async_get_result; end

  # call-seq:
  #    conn.isnonblocking() -> Boolean
  #
  # Returns the blocking status of the database connection.
  # Returns +true+ if the connection is set to nonblocking mode and +false+ if blocking.
  def async_isnonblocking; end

  def async_prepare(*_arg0); end

  # call-seq:
  #    conn.put_copy_data( buffer [, encoder] ) -> Boolean
  #
  # Transmits _buffer_ as copy data to the server.
  # Returns true if the data was sent, false if it was
  # not sent (false is only possible if the connection
  # is in nonblocking mode, and this command would block).
  #
  # _encoder_ can be a PG::Coder derivation (typically PG::TextEncoder::CopyRow).
  # This encodes the data fields given as _buffer_ from an Array of Strings to
  # PostgreSQL's COPY text format inclusive proper escaping. Optionally
  # the encoder can type cast the fields from various Ruby types in one step,
  # if PG::TextEncoder::CopyRow#type_map is set accordingly.
  #
  # Raises an exception if an error occurs.
  #
  # See also #copy_data.
  def async_put_copy_data(buffer, encoder = T.unsafe(nil)); end

  # call-seq:
  #    conn.put_copy_end( [ error_message ] ) -> Boolean
  #
  # Sends end-of-data indication to the server.
  #
  # _error_message_ is an optional parameter, and if set,
  # forces the COPY command to fail with the string
  # _error_message_.
  #
  # Returns true if the end-of-data was sent, #false* if it was
  # not sent (*false* is only possible if the connection
  # is in nonblocking mode, and this command would block).
  def async_put_copy_end(*args); end

  def async_query(*_arg0); end

  # call-seq:
  #   conn.reset()
  #
  # Resets the backend connection. This method closes the
  # backend connection and tries to re-connect.
  def async_reset; end

  def async_set_client_encoding(_arg0); end

  # call-seq:
  #    conn.setnonblocking(Boolean) -> nil
  #
  # Sets the nonblocking status of the connection.
  # In the blocking state, calls to #send_query
  # will block until the message is sent to the server,
  # but will not wait for the query results.
  # In the nonblocking state, calls to #send_query
  # will return an error if the socket is not ready for
  # writing.
  # Note: This function does not affect #exec, because
  # that function doesn't return until the server has
  # processed the query and returned the results.
  #
  # Returns +nil+.
  def async_setnonblocking(enabled); end

  def backend_key; end
  def backend_pid; end
  def block(*_arg0); end

  # call-seq:
  #    conn.cancel() -> String
  #
  # Requests cancellation of the command currently being
  # processed.
  #
  # Returns +nil+ on success, or a string containing the
  # error message if a failure occurs.
  def cancel; end

  def client_encoding=(_arg0); end
  def close; end

  # Returns an array of Hashes with connection defaults. See ::conndefaults
  # for details.
  def conndefaults; end

  # Returns a Hash with connection defaults. See ::conndefaults_hash
  # for details.
  def conndefaults_hash; end

  def connect_poll; end
  def connection_needs_password; end
  def connection_used_password; end
  def conninfo; end

  # Return the Postgres connection info structure as a Hash keyed by option
  # keyword (as a Symbol).
  #
  # See also #conninfo
  def conninfo_hash; end

  def consume_input; end

  # call-seq:
  #     conn.copy_data( sql [, coder] ) {|sql_result| ... } -> PG::Result
  #
  # Execute a copy process for transferring data to or from the server.
  #
  # This issues the SQL COPY command via #exec. The response to this
  # (if there is no error in the command) is a PG::Result object that
  # is passed to the block, bearing a status code of PGRES_COPY_OUT or
  # PGRES_COPY_IN (depending on the specified copy direction).
  # The application should then use #put_copy_data or #get_copy_data
  # to receive or transmit data rows and should return from the block
  # when finished.
  #
  # #copy_data returns another PG::Result object when the data transfer
  # is complete. An exception is raised if some problem was encountered,
  # so it isn't required to make use of any of them.
  # At this point further SQL commands can be issued via #exec.
  # (It is not possible to execute other SQL commands using the same
  # connection while the COPY operation is in progress.)
  #
  # This method ensures, that the copy process is properly terminated
  # in case of client side or server side failures. Therefore, in case
  # of blocking mode of operation, #copy_data is preferred to raw calls
  # of #put_copy_data, #get_copy_data and #put_copy_end.
  #
  # _coder_ can be a PG::Coder derivation
  # (typically PG::TextEncoder::CopyRow or PG::TextDecoder::CopyRow).
  # This enables encoding of data fields given to #put_copy_data
  # or decoding of fields received by #get_copy_data.
  #
  # Example with CSV input format:
  #   conn.exec "create table my_table (a text,b text,c text,d text)"
  #   conn.copy_data "COPY my_table FROM STDIN CSV" do
  #     conn.put_copy_data "some,data,to,copy\n"
  #     conn.put_copy_data "more,data,to,copy\n"
  #   end
  # This creates +my_table+ and inserts two CSV rows.
  #
  # The same with text format encoder PG::TextEncoder::CopyRow
  # and Array input:
  #   enco = PG::TextEncoder::CopyRow.new
  #   conn.copy_data "COPY my_table FROM STDIN", enco do
  #     conn.put_copy_data ['some', 'data', 'to', 'copy']
  #     conn.put_copy_data ['more', 'data', 'to', 'copy']
  #   end
  #
  # Example with CSV output format:
  #   conn.copy_data "COPY my_table TO STDOUT CSV" do
  #     while row=conn.get_copy_data
  #       p row
  #     end
  #   end
  # This prints all rows of +my_table+ to stdout:
  #   "some,data,to,copy\n"
  #   "more,data,to,copy\n"
  #
  # The same with text format decoder PG::TextDecoder::CopyRow
  # and Array output:
  #   deco = PG::TextDecoder::CopyRow.new
  #   conn.copy_data "COPY my_table TO STDOUT", deco do
  #     while row=conn.get_copy_data
  #       p row
  #     end
  #   end
  # This receives all rows of +my_table+ as ruby array:
  #   ["some", "data", "to", "copy"]
  #   ["more", "data", "to", "copy"]
  #
  # @raise [PG::NotInBlockingMode]
  def copy_data(sql, coder = T.unsafe(nil)); end

  def db; end
  def decoder_for_get_copy_data; end
  def decoder_for_get_copy_data=(_arg0); end
  def describe_portal(_arg0); end
  def describe_prepared(_arg0); end
  def discard_results; end
  def encoder_for_put_copy_data; end
  def encoder_for_put_copy_data=(_arg0); end

  # call-seq:
  #    conn.encrypt_password( password, username, algorithm=nil ) -> String
  #
  # This function is intended to be used by client applications that wish to send commands like <tt>ALTER USER joe PASSWORD 'pwd'</tt>.
  # It is good practice not to send the original cleartext password in such a command, because it might be exposed in command logs, activity displays, and so on.
  # Instead, use this function to convert the password to encrypted form before it is sent.
  #
  # The +password+ and +username+ arguments are the cleartext password, and the SQL name of the user it is for.
  # +algorithm+ specifies the encryption algorithm to use to encrypt the password.
  # Currently supported algorithms are +md5+ and +scram-sha-256+ (+on+ and +off+ are also accepted as aliases for +md5+, for compatibility with older server versions).
  # Note that support for +scram-sha-256+ was introduced in PostgreSQL version 10, and will not work correctly with older server versions.
  # If algorithm is omitted or +nil+, this function will query the server for the current value of the +password_encryption+ setting.
  # That can block, and will fail if the current transaction is aborted, or if the connection is busy executing another query.
  # If you wish to use the default algorithm for the server but want to avoid blocking, query +password_encryption+ yourself before calling #encrypt_password, and pass that value as the algorithm.
  #
  # Return value is the encrypted password.
  # The caller can assume the string doesn't contain any special characters that would require escaping.
  #
  # Available since PostgreSQL-10.
  # See also corresponding {libpq function}[https://www.postgresql.org/docs/current/libpq-misc.html#LIBPQ-PQENCRYPTPASSWORDCONN].
  def encrypt_password(password, username, algorithm = T.unsafe(nil)); end

  def enter_pipeline_mode; end
  def error_message; end
  def escape(_arg0); end
  def escape_bytea(_arg0); end
  def escape_identifier(_arg0); end
  def escape_literal(_arg0); end
  def escape_string(_arg0); end
  def exec(*args, &blk); end
  def exec_params(*args, &blk); end
  def exec_params_without_profiling(*_arg0); end
  def exec_prepared(*args, &blk); end
  def exec_prepared_without_profiling(*_arg0); end
  def exec_without_profiling(*_arg0); end
  def exit_pipeline_mode; end
  def external_encoding; end
  def field_name_type; end
  def field_name_type=(_arg0); end
  def finish; end
  def finished?; end
  def flush; end
  def get_client_encoding; end

  # call-seq:
  #    conn.get_copy_data( [ nonblock = false [, decoder = nil ]] ) -> Object
  #
  # Return one row of data, +nil+
  # if the copy is done, or +false+ if the call would
  # block (only possible if _nonblock_ is true).
  #
  # If _decoder_ is not set or +nil+, data is returned as binary string.
  #
  # If _decoder_ is set to a PG::Coder derivation, the return type depends on this decoder.
  # PG::TextDecoder::CopyRow decodes the received data fields from one row of PostgreSQL's
  # COPY text format to an Array of Strings.
  # Optionally the decoder can type cast the single fields to various Ruby types in one step,
  # if PG::TextDecoder::CopyRow#type_map is set accordingly.
  #
  # See also #copy_data.
  def get_copy_data(async = T.unsafe(nil), decoder = T.unsafe(nil)); end

  def get_last_result; end

  # call-seq:
  #    conn.get_result() -> PG::Result
  #    conn.get_result() {|pg_result| block }
  #
  # Blocks waiting for the next result from a call to
  # #send_query (or another asynchronous command), and returns
  # it. Returns +nil+ if no more results are available.
  #
  # Note: call this function repeatedly until it returns +nil+, or else
  # you will not be able to issue further commands.
  #
  # If the optional code block is given, it will be passed <i>result</i> as an argument,
  # and the PG::Result object will  automatically be cleared when the block terminates.
  # In this instance, <code>conn.exec</code> returns the value of the block.
  def get_result; end

  def host; end
  def internal_encoding; end
  def internal_encoding=(_arg0); end
  def is_busy; end

  # call-seq:
  #    conn.isnonblocking() -> Boolean
  #
  # Returns the blocking status of the database connection.
  # Returns +true+ if the connection is set to nonblocking mode and +false+ if blocking.
  def isnonblocking; end

  def lo_close(_arg0); end
  def lo_creat(*_arg0); end
  def lo_create(_arg0); end
  def lo_export(_arg0, _arg1); end
  def lo_import(_arg0); end
  def lo_lseek(_arg0, _arg1, _arg2); end
  def lo_open(*_arg0); end
  def lo_read(_arg0, _arg1); end
  def lo_seek(_arg0, _arg1, _arg2); end
  def lo_tell(_arg0); end
  def lo_truncate(_arg0, _arg1); end
  def lo_unlink(_arg0); end
  def lo_write(_arg0, _arg1); end
  def loclose(_arg0); end
  def locreat(*_arg0); end
  def locreate(_arg0); end
  def loexport(_arg0, _arg1); end
  def loimport(_arg0); end
  def lolseek(_arg0, _arg1, _arg2); end
  def loopen(*_arg0); end
  def loread(_arg0, _arg1); end
  def loseek(_arg0, _arg1, _arg2); end
  def lotell(_arg0); end
  def lotruncate(_arg0, _arg1); end
  def lounlink(_arg0); end
  def lowrite(_arg0, _arg1); end
  def make_empty_pgresult(_arg0); end

  # call-seq:
  #    conn.isnonblocking() -> Boolean
  #
  # Returns the blocking status of the database connection.
  # Returns +true+ if the connection is set to nonblocking mode and +false+ if blocking.
  def nonblocking?; end

  def notifies; end
  def notifies_wait(*_arg0); end
  def options; end
  def parameter_status(_arg0); end
  def pass; end
  def pipeline_status; end
  def pipeline_sync; end
  def port; end
  def prepare(*args, &blk); end
  def prepare_without_profiling(*_arg0); end
  def protocol_version; end

  # call-seq:
  #    conn.put_copy_data( buffer [, encoder] ) -> Boolean
  #
  # Transmits _buffer_ as copy data to the server.
  # Returns true if the data was sent, false if it was
  # not sent (false is only possible if the connection
  # is in nonblocking mode, and this command would block).
  #
  # _encoder_ can be a PG::Coder derivation (typically PG::TextEncoder::CopyRow).
  # This encodes the data fields given as _buffer_ from an Array of Strings to
  # PostgreSQL's COPY text format inclusive proper escaping. Optionally
  # the encoder can type cast the fields from various Ruby types in one step,
  # if PG::TextEncoder::CopyRow#type_map is set accordingly.
  #
  # Raises an exception if an error occurs.
  #
  # See also #copy_data.
  def put_copy_data(buffer, encoder = T.unsafe(nil)); end

  # call-seq:
  #    conn.put_copy_end( [ error_message ] ) -> Boolean
  #
  # Sends end-of-data indication to the server.
  #
  # _error_message_ is an optional parameter, and if set,
  # forces the COPY command to fail with the string
  # _error_message_.
  #
  # Returns true if the end-of-data was sent, #false* if it was
  # not sent (*false* is only possible if the connection
  # is in nonblocking mode, and this command would block).
  def put_copy_end(*args); end

  def query(*args, &blk); end
  def quote_ident(_arg0); end

  # call-seq:
  #   conn.reset()
  #
  # Resets the backend connection. This method closes the
  # backend connection and tries to re-connect.
  def reset; end

  def reset_poll; end
  def reset_start; end
  def send_describe_portal(_arg0); end
  def send_describe_prepared(_arg0); end
  def send_flush_request; end
  def send_prepare(*_arg0); end
  def send_query(*_arg0); end
  def send_query_params(*_arg0); end
  def send_query_prepared(*args, &blk); end
  def send_query_prepared_without_profiling(*_arg0); end
  def server_version; end
  def set_client_encoding(_arg0); end
  def set_default_encoding; end
  def set_error_context_visibility(_arg0); end
  def set_error_verbosity(_arg0); end
  def set_notice_processor; end
  def set_notice_receiver; end
  def set_single_row_mode; end

  # call-seq:
  #    conn.setnonblocking(Boolean) -> nil
  #
  # Sets the nonblocking status of the connection.
  # In the blocking state, calls to #send_query
  # will block until the message is sent to the server,
  # but will not wait for the query results.
  # In the nonblocking state, calls to #send_query
  # will return an error if the socket is not ready for
  # writing.
  # Note: This function does not affect #exec, because
  # that function doesn't return until the server has
  # processed the query and returned the results.
  #
  # Returns +nil+.
  def setnonblocking(enabled); end

  def socket; end
  def socket_io; end
  def ssl_attribute(_arg0); end
  def ssl_attribute_names; end

  # call-seq:
  #   conn.ssl_attributes -> Hash<String,String>
  #
  # Returns SSL-related information about the connection as key/value pairs
  #
  # The available attributes varies depending on the SSL library being used,
  # and the type of connection.
  #
  # See also #ssl_attribute
  def ssl_attributes; end

  def ssl_in_use?; end
  def status; end
  def sync_cancel; end
  def sync_describe_portal(_arg0); end
  def sync_describe_prepared(_arg0); end
  def sync_encrypt_password(*_arg0); end
  def sync_exec(*_arg0); end
  def sync_exec_params(*_arg0); end
  def sync_exec_prepared(*_arg0); end
  def sync_flush; end
  def sync_get_copy_data(*_arg0); end
  def sync_get_last_result; end
  def sync_get_result; end
  def sync_isnonblocking; end
  def sync_prepare(*_arg0); end
  def sync_put_copy_data(*_arg0); end
  def sync_put_copy_end(*_arg0); end
  def sync_reset; end
  def sync_set_client_encoding(_arg0); end
  def sync_setnonblocking(_arg0); end
  def trace(_arg0); end

  # call-seq:
  #    conn.transaction { |conn| ... } -> result of the block
  #
  # Executes a +BEGIN+ at the start of the block,
  # and a +COMMIT+ at the end of the block, or
  # +ROLLBACK+ if any exception occurs.
  def transaction; end

  def transaction_status; end
  def tty; end
  def type_map_for_queries; end
  def type_map_for_queries=(_arg0); end
  def type_map_for_results; end
  def type_map_for_results=(_arg0); end
  def unescape_bytea(_arg0); end
  def untrace; end
  def user; end
  def wait_for_notify(*_arg0); end

  private

  def async_connect_or_reset(poll_meth); end
  def flush_data=(_arg0); end

  class << self
    # Switch between sync and async libpq API.
    #
    #   PG::Connection.async_api = true
    # this is the default.
    # It sets an alias from #exec to #async_exec, #reset to #async_reset and so on.
    #
    #   PG::Connection.async_api = false
    # sets an alias from #exec to #sync_exec, #reset to #sync_reset and so on.
    #
    # pg-1.1.0+ defaults to libpq's async API for query related blocking methods.
    # pg-1.3.0+ defaults to libpq's async API for all possibly blocking methods.
    #
    # _PLEASE_ _NOTE_: This method is not part of the public API and is for debug and development use only.
    # Do not use this method in production code.
    # Any issues with the default setting of <tt>async_api=true</tt> should be reported to the maintainers instead.
    def async_api=(enable); end

    # call-seq:
    #    PG::Connection.new -> conn
    #    PG::Connection.new(connection_hash) -> conn
    #    PG::Connection.new(connection_string) -> conn
    #    PG::Connection.new(host, port, options, tty, dbname, user, password) ->  conn
    #
    # Create a connection to the specified server.
    #
    # +connection_hash+ must be a ruby Hash with connection parameters.
    # See the {list of valid parameters}[https://www.postgresql.org/docs/current/libpq-connect.html#LIBPQ-PARAMKEYWORDS] in the PostgreSQL documentation.
    #
    # There are two accepted formats for +connection_string+: plain <code>keyword = value</code> strings and URIs.
    # See the documentation of {connection strings}[https://www.postgresql.org/docs/current/libpq-connect.html#LIBPQ-CONNSTRING].
    #
    # The positional parameter form has the same functionality except that the missing parameters will always take on default values. The parameters are:
    # [+host+]
    #   server hostname
    # [+port+]
    #   server port number
    # [+options+]
    #   backend options
    # [+tty+]
    #   (ignored in all versions of PostgreSQL)
    # [+dbname+]
    #   connecting database name
    # [+user+]
    #   login user name
    # [+password+]
    #   login password
    #
    # Examples:
    #
    #   # Connect using all defaults
    #   PG::Connection.new
    #
    #   # As a Hash
    #   PG::Connection.new( dbname: 'test', port: 5432 )
    #
    #   # As a String
    #   PG::Connection.new( "dbname=test port=5432" )
    #
    #   # As an Array
    #   PG::Connection.new( nil, 5432, nil, nil, 'test', nil, nil )
    #
    #   # As an URI
    #   PG::Connection.new( "postgresql://user:pass@pgsql.example.com:5432/testdb?sslmode=require" )
    #
    # If the Ruby default internal encoding is set (i.e., <code>Encoding.default_internal != nil</code>), the
    # connection will have its +client_encoding+ set accordingly.
    #
    # Raises a PG::Error if the connection fails.
    #
    # @raise [PG::ConnectionBad]
    def async_connect(*args, **kwargs); end

    # call-seq:
    #    PG::Connection.ping(connection_hash)       -> Integer
    #    PG::Connection.ping(connection_string)     -> Integer
    #    PG::Connection.ping(host, port, options, tty, dbname, login, password) ->  Integer
    #
    # Check server status.
    #
    # See PG::Connection.new for a description of the parameters.
    #
    # Returns one of:
    # [+PQPING_OK+]
    #   server is accepting connections
    # [+PQPING_REJECT+]
    #   server is alive but rejecting connections
    # [+PQPING_NO_RESPONSE+]
    #   could not establish connection
    # [+PQPING_NO_ATTEMPT+]
    #   connection not attempted (bad params)
    def async_ping(*args); end

    def async_send_api=(enable); end
    def conndefaults; end

    # Return the Postgres connection defaults structure as a Hash keyed by option
    # keyword (as a Symbol).
    #
    # See also #conndefaults
    def conndefaults_hash; end

    # call-seq:
    #    PG::Connection.new -> conn
    #    PG::Connection.new(connection_hash) -> conn
    #    PG::Connection.new(connection_string) -> conn
    #    PG::Connection.new(host, port, options, tty, dbname, user, password) ->  conn
    #
    # Create a connection to the specified server.
    #
    # +connection_hash+ must be a ruby Hash with connection parameters.
    # See the {list of valid parameters}[https://www.postgresql.org/docs/current/libpq-connect.html#LIBPQ-PARAMKEYWORDS] in the PostgreSQL documentation.
    #
    # There are two accepted formats for +connection_string+: plain <code>keyword = value</code> strings and URIs.
    # See the documentation of {connection strings}[https://www.postgresql.org/docs/current/libpq-connect.html#LIBPQ-CONNSTRING].
    #
    # The positional parameter form has the same functionality except that the missing parameters will always take on default values. The parameters are:
    # [+host+]
    #   server hostname
    # [+port+]
    #   server port number
    # [+options+]
    #   backend options
    # [+tty+]
    #   (ignored in all versions of PostgreSQL)
    # [+dbname+]
    #   connecting database name
    # [+user+]
    #   login user name
    # [+password+]
    #   login password
    #
    # Examples:
    #
    #   # Connect using all defaults
    #   PG::Connection.new
    #
    #   # As a Hash
    #   PG::Connection.new( dbname: 'test', port: 5432 )
    #
    #   # As a String
    #   PG::Connection.new( "dbname=test port=5432" )
    #
    #   # As an Array
    #   PG::Connection.new( nil, 5432, nil, nil, 'test', nil, nil )
    #
    #   # As an URI
    #   PG::Connection.new( "postgresql://user:pass@pgsql.example.com:5432/testdb?sslmode=require" )
    #
    # If the Ruby default internal encoding is set (i.e., <code>Encoding.default_internal != nil</code>), the
    # connection will have its +client_encoding+ set accordingly.
    #
    # Raises a PG::Error if the connection fails.
    #
    # @raise [PG::ConnectionBad]
    def connect(*args, **kwargs); end

    # Convert Hash options to connection String
    #
    # Values are properly quoted and escaped.
    def connect_hash_to_string(hash); end

    def connect_start(*_arg0); end

    # Decode a connection string to Hash options
    #
    # Value are properly unquoted and unescaped.
    def connect_string_to_hash(str); end

    def encrypt_password(_arg0, _arg1); end
    def escape(_arg0); end
    def escape_bytea(_arg0); end
    def escape_string(_arg0); end
    def isthreadsafe; end

    # call-seq:
    #    PG::Connection.new -> conn
    #    PG::Connection.new(connection_hash) -> conn
    #    PG::Connection.new(connection_string) -> conn
    #    PG::Connection.new(host, port, options, tty, dbname, user, password) ->  conn
    #
    # Create a connection to the specified server.
    #
    # +connection_hash+ must be a ruby Hash with connection parameters.
    # See the {list of valid parameters}[https://www.postgresql.org/docs/current/libpq-connect.html#LIBPQ-PARAMKEYWORDS] in the PostgreSQL documentation.
    #
    # There are two accepted formats for +connection_string+: plain <code>keyword = value</code> strings and URIs.
    # See the documentation of {connection strings}[https://www.postgresql.org/docs/current/libpq-connect.html#LIBPQ-CONNSTRING].
    #
    # The positional parameter form has the same functionality except that the missing parameters will always take on default values. The parameters are:
    # [+host+]
    #   server hostname
    # [+port+]
    #   server port number
    # [+options+]
    #   backend options
    # [+tty+]
    #   (ignored in all versions of PostgreSQL)
    # [+dbname+]
    #   connecting database name
    # [+user+]
    #   login user name
    # [+password+]
    #   login password
    #
    # Examples:
    #
    #   # Connect using all defaults
    #   PG::Connection.new
    #
    #   # As a Hash
    #   PG::Connection.new( dbname: 'test', port: 5432 )
    #
    #   # As a String
    #   PG::Connection.new( "dbname=test port=5432" )
    #
    #   # As an Array
    #   PG::Connection.new( nil, 5432, nil, nil, 'test', nil, nil )
    #
    #   # As an URI
    #   PG::Connection.new( "postgresql://user:pass@pgsql.example.com:5432/testdb?sslmode=require" )
    #
    # If the Ruby default internal encoding is set (i.e., <code>Encoding.default_internal != nil</code>), the
    # connection will have its +client_encoding+ set accordingly.
    #
    # Raises a PG::Error if the connection fails.
    #
    # @raise [PG::ConnectionBad]
    def new(*args, **kwargs); end

    # call-seq:
    #    PG::Connection.new -> conn
    #    PG::Connection.new(connection_hash) -> conn
    #    PG::Connection.new(connection_string) -> conn
    #    PG::Connection.new(host, port, options, tty, dbname, user, password) ->  conn
    #
    # Create a connection to the specified server.
    #
    # +connection_hash+ must be a ruby Hash with connection parameters.
    # See the {list of valid parameters}[https://www.postgresql.org/docs/current/libpq-connect.html#LIBPQ-PARAMKEYWORDS] in the PostgreSQL documentation.
    #
    # There are two accepted formats for +connection_string+: plain <code>keyword = value</code> strings and URIs.
    # See the documentation of {connection strings}[https://www.postgresql.org/docs/current/libpq-connect.html#LIBPQ-CONNSTRING].
    #
    # The positional parameter form has the same functionality except that the missing parameters will always take on default values. The parameters are:
    # [+host+]
    #   server hostname
    # [+port+]
    #   server port number
    # [+options+]
    #   backend options
    # [+tty+]
    #   (ignored in all versions of PostgreSQL)
    # [+dbname+]
    #   connecting database name
    # [+user+]
    #   login user name
    # [+password+]
    #   login password
    #
    # Examples:
    #
    #   # Connect using all defaults
    #   PG::Connection.new
    #
    #   # As a Hash
    #   PG::Connection.new( dbname: 'test', port: 5432 )
    #
    #   # As a String
    #   PG::Connection.new( "dbname=test port=5432" )
    #
    #   # As an Array
    #   PG::Connection.new( nil, 5432, nil, nil, 'test', nil, nil )
    #
    #   # As an URI
    #   PG::Connection.new( "postgresql://user:pass@pgsql.example.com:5432/testdb?sslmode=require" )
    #
    # If the Ruby default internal encoding is set (i.e., <code>Encoding.default_internal != nil</code>), the
    # connection will have its +client_encoding+ set accordingly.
    #
    # Raises a PG::Error if the connection fails.
    #
    # @raise [PG::ConnectionBad]
    def open(*args, **kwargs); end

    # Parse the connection +args+ into a connection-parameter string.
    # See PG::Connection.new for valid arguments.
    #
    # It accepts:
    # * an option String kind of "host=name port=5432"
    # * an option Hash kind of {host: "name", port: 5432}
    # * URI string
    # * URI object
    # * positional arguments
    #
    # The method adds the option "hostaddr" and "fallback_application_name" if they aren't already set.
    # The URI and the options string is passed through and "hostaddr" as well as "fallback_application_name"
    # are added to the end.
    def parse_connect_args(*args); end

    # call-seq:
    #    PG::Connection.ping(connection_hash)       -> Integer
    #    PG::Connection.ping(connection_string)     -> Integer
    #    PG::Connection.ping(host, port, options, tty, dbname, login, password) ->  Integer
    #
    # Check server status.
    #
    # See PG::Connection.new for a description of the parameters.
    #
    # Returns one of:
    # [+PQPING_OK+]
    #   server is accepting connections
    # [+PQPING_REJECT+]
    #   server is alive but rejecting connections
    # [+PQPING_NO_RESPONSE+]
    #   could not establish connection
    # [+PQPING_NO_ATTEMPT+]
    #   connection not attempted (bad params)
    def ping(*args); end

    # Quote a single +value+ for use in a connection-parameter string.
    def quote_connstr(value); end

    def quote_ident(_arg0); end

    # call-seq:
    #    PG::Connection.new -> conn
    #    PG::Connection.new(connection_hash) -> conn
    #    PG::Connection.new(connection_string) -> conn
    #    PG::Connection.new(host, port, options, tty, dbname, user, password) ->  conn
    #
    # Create a connection to the specified server.
    #
    # +connection_hash+ must be a ruby Hash with connection parameters.
    # See the {list of valid parameters}[https://www.postgresql.org/docs/current/libpq-connect.html#LIBPQ-PARAMKEYWORDS] in the PostgreSQL documentation.
    #
    # There are two accepted formats for +connection_string+: plain <code>keyword = value</code> strings and URIs.
    # See the documentation of {connection strings}[https://www.postgresql.org/docs/current/libpq-connect.html#LIBPQ-CONNSTRING].
    #
    # The positional parameter form has the same functionality except that the missing parameters will always take on default values. The parameters are:
    # [+host+]
    #   server hostname
    # [+port+]
    #   server port number
    # [+options+]
    #   backend options
    # [+tty+]
    #   (ignored in all versions of PostgreSQL)
    # [+dbname+]
    #   connecting database name
    # [+user+]
    #   login user name
    # [+password+]
    #   login password
    #
    # Examples:
    #
    #   # Connect using all defaults
    #   PG::Connection.new
    #
    #   # As a Hash
    #   PG::Connection.new( dbname: 'test', port: 5432 )
    #
    #   # As a String
    #   PG::Connection.new( "dbname=test port=5432" )
    #
    #   # As an Array
    #   PG::Connection.new( nil, 5432, nil, nil, 'test', nil, nil )
    #
    #   # As an URI
    #   PG::Connection.new( "postgresql://user:pass@pgsql.example.com:5432/testdb?sslmode=require" )
    #
    # If the Ruby default internal encoding is set (i.e., <code>Encoding.default_internal != nil</code>), the
    # connection will have its +client_encoding+ set accordingly.
    #
    # Raises a PG::Error if the connection fails.
    #
    # @raise [PG::ConnectionBad]
    def setdb(*args, **kwargs); end

    # call-seq:
    #    PG::Connection.new -> conn
    #    PG::Connection.new(connection_hash) -> conn
    #    PG::Connection.new(connection_string) -> conn
    #    PG::Connection.new(host, port, options, tty, dbname, user, password) ->  conn
    #
    # Create a connection to the specified server.
    #
    # +connection_hash+ must be a ruby Hash with connection parameters.
    # See the {list of valid parameters}[https://www.postgresql.org/docs/current/libpq-connect.html#LIBPQ-PARAMKEYWORDS] in the PostgreSQL documentation.
    #
    # There are two accepted formats for +connection_string+: plain <code>keyword = value</code> strings and URIs.
    # See the documentation of {connection strings}[https://www.postgresql.org/docs/current/libpq-connect.html#LIBPQ-CONNSTRING].
    #
    # The positional parameter form has the same functionality except that the missing parameters will always take on default values. The parameters are:
    # [+host+]
    #   server hostname
    # [+port+]
    #   server port number
    # [+options+]
    #   backend options
    # [+tty+]
    #   (ignored in all versions of PostgreSQL)
    # [+dbname+]
    #   connecting database name
    # [+user+]
    #   login user name
    # [+password+]
    #   login password
    #
    # Examples:
    #
    #   # Connect using all defaults
    #   PG::Connection.new
    #
    #   # As a Hash
    #   PG::Connection.new( dbname: 'test', port: 5432 )
    #
    #   # As a String
    #   PG::Connection.new( "dbname=test port=5432" )
    #
    #   # As an Array
    #   PG::Connection.new( nil, 5432, nil, nil, 'test', nil, nil )
    #
    #   # As an URI
    #   PG::Connection.new( "postgresql://user:pass@pgsql.example.com:5432/testdb?sslmode=require" )
    #
    # If the Ruby default internal encoding is set (i.e., <code>Encoding.default_internal != nil</code>), the
    # connection will have its +client_encoding+ set accordingly.
    #
    # Raises a PG::Error if the connection fails.
    #
    # @raise [PG::ConnectionBad]
    def setdblogin(*args, **kwargs); end

    def sync_connect(*_arg0); end
    def sync_ping(*_arg0); end
    def unescape_bytea(_arg0); end
  end
end

# The order the options are passed to the ::connect method.
PG::Connection::CONNECT_ARGUMENT_ORDER = T.let(T.unsafe(nil), Array)

# URI defined in RFC3986
# This regexp is modified to allow host to specify multiple comma separated components captured as <hostports> and to disallow comma in hostnames.
# Taken from: https://github.com/ruby/ruby/blob/be04006c7d2f9aeb7e9d8d09d945b3a9c7850202/lib/uri/rfc3986_parser.rb#L6
PG::Connection::HOST_AND_PORT = T.let(T.unsafe(nil), Regexp)

PG::Connection::POSTGRESQL_URI = T.let(T.unsafe(nil), Regexp)

# PG patches, keep in mind exec and async_exec have a exec{|r| } semantics that is yet to be implemented
class PG::Result
  include ::Enumerable
  include ::PG::Constants

  def [](_arg0); end
  def autoclear?; end
  def check; end
  def check_result; end
  def clear; end
  def cleared?; end
  def cmd_status; end
  def cmd_tuples; end
  def cmdtuples; end
  def column_values(_arg0); end
  def each(*args, &blk); end
  def each_row; end
  def each_without_profiling; end
  def error_field(_arg0); end
  def error_message; end
  def fformat(_arg0); end
  def field_name_type; end
  def field_name_type=(_arg0); end

  # Set the data type for all field name returning methods.
  #
  # +type+: a Symbol defining the field name type.
  #
  # This method is equal to #field_name_type= , but returns self, so that calls can be chained.
  def field_names_as(type); end

  def field_values(_arg0); end
  def fields; end
  def fmod(_arg0); end
  def fname(_arg0); end
  def fnumber(_arg0); end
  def fsize(_arg0); end
  def ftable(_arg0); end
  def ftablecol(_arg0); end
  def ftype(_arg0); end
  def getisnull(_arg0, _arg1); end
  def getlength(_arg0, _arg1); end
  def getvalue(_arg0, _arg1); end

  # Return a String representation of the object suitable for debugging.
  def inspect; end

  # Apply a type map for all value retrieving methods.
  #
  # +type_map+: a PG::TypeMap instance.
  #
  # This method is equal to #type_map= , but returns self, so that calls can be chained.
  #
  # See also PG::BasicTypeMapForResults
  def map_types!(type_map); end

  def mp_report_sql(&block); end
  def nfields; end
  def nparams; end
  def ntuples; end
  def num_fields; end
  def num_tuples; end
  def oid_value; end
  def paramtype(_arg0); end
  def res_status(_arg0); end
  def result_error_field(_arg0); end
  def result_error_message; end
  def result_status; end
  def result_verbose_error_message(_arg0, _arg1); end
  def stream_each; end
  def stream_each_row; end
  def stream_each_tuple; end
  def tuple(_arg0); end
  def tuple_values(_arg0); end
  def type_map; end
  def type_map=(_arg0); end
  def values(*args, &blk); end
  def values_without_profiling; end
  def verbose_error_message(_arg0, _arg1); end
end

# based off https://github.com/newrelic/rpm/blob/master/lib/new_relic/agent/instrumentation/active_record.rb
# fallback for alls sorts of weird dbs
module Rack
  class << self
    # Return the Rack release as a dotted string.
    def release; end

    # Return the Rack protocol version as a dotted string.
    def version; end
  end
end

Rack::CACHE_CONTROL = T.let(T.unsafe(nil), String)
Rack::CONTENT_LENGTH = T.let(T.unsafe(nil), String)
Rack::CONTENT_TYPE = T.let(T.unsafe(nil), String)
Rack::DELETE = T.let(T.unsafe(nil), String)
Rack::ETAG = T.let(T.unsafe(nil), String)
Rack::EXPIRES = T.let(T.unsafe(nil), String)
Rack::File = Rack::Files

# HTTP method verbs
Rack::GET = T.let(T.unsafe(nil), String)

Rack::HEAD = T.let(T.unsafe(nil), String)
Rack::HTTPS = T.let(T.unsafe(nil), String)
Rack::HTTP_COOKIE = T.let(T.unsafe(nil), String)
Rack::HTTP_HOST = T.let(T.unsafe(nil), String)
Rack::HTTP_PORT = T.let(T.unsafe(nil), String)
Rack::HTTP_VERSION = T.let(T.unsafe(nil), String)
Rack::LINK = T.let(T.unsafe(nil), String)

class Rack::MiniProfiler
  extend ::Rack::MiniProfiler::ProfilingMethods

  # options:
  # :auto_inject - should script be automatically injected on every html page (not xhr)
  #
  # @return [MiniProfiler] a new instance of MiniProfiler
  def initialize(app, config = T.unsafe(nil)); end

  # @return [Boolean]
  def advanced_debugging_enabled?; end

  def analyze_memory; end
  def cache_control_value; end
  def call(env); end

  # cancels automatic injection of profile script for the current page
  def cancel_auto_inject(env); end

  def config; end
  def current; end
  def current=(c); end
  def dump_env(env); end
  def dump_exceptions(exceptions); end
  def flamegraph(graph, path); end
  def generate_html(page_struct, env, result_json = T.unsafe(nil)); end

  # get_profile_script returns script to be injected inside current html page
  # By default, profile_script is appended to the end of all html requests automatically.
  # Calling get_profile_script cancels automatic append for the current page
  # Use it when:
  # * you have disabled auto append behaviour throught :auto_inject => false flag
  # * you do not want script to be automatically appended for the current page. You can also call cancel_auto_inject
  def get_profile_script(env); end

  def help(client_settings, env); end
  def ids(env); end
  def ids_comma_separated(env); end
  def inject(fragment, script); end
  def inject_profiler(env, status, headers, body); end
  def make_link(postfix, env); end
  def serve_html(env); end
  def serve_results(env); end
  def text_result(body); end
  def tool_disabled_message(client_settings); end
  def trim_strings(strings, max_size); end
  def user(env); end

  private

  def handle_snapshots_request(env); end
  def rails_route_from_path(path, method); end
  def serve_flamegraph(env); end
  def take_snapshot(env, start); end

  # @return [Boolean]
  def take_snapshot?(path); end

  def url_for_snapshot(id, group_name); end
  def url_for_snapshots_group(group_name); end

  class << self
    def add_snapshot_custom_field(key, value); end
    def advanced_tools_message; end
    def authorize_request; end
    def binds_to_params(binds); end

    # So we can change the configuration if we want
    def config; end

    def create_current(env = T.unsafe(nil), options = T.unsafe(nil)); end
    def current; end
    def current=(c); end
    def deauthorize_request; end

    # discard existing results, don't track this request
    def discard_results; end

    def generate_id; end
    def get_snapshot_custom_fields; end

    # @return [Boolean]
    def patch_rails?; end

    # @return [Boolean]
    def redact_sql_queries?; end

    # @return [Boolean]
    def request_authorized?; end

    def reset_config; end
    def resources_root; end
    def share_template; end

    # @return [Boolean]
    def snapshots_transporter?; end

    # Returns the value of attribute subscribe_sql_active_record.
    def subscribe_sql_active_record; end

    # Sets the attribute subscribe_sql_active_record
    #
    # @param value the value to set the attribute subscribe_sql_active_record to.
    def subscribe_sql_active_record=(_arg0); end
  end
end

Rack::MiniProfiler::ASSET_VERSION = T.let(T.unsafe(nil), String)

class Rack::MiniProfiler::AbstractStore
  # a list of tokens that are permitted to access profiler in explicit mode
  #
  # @raise [NotImplementedError]
  def allowed_tokens; end

  def diagnostics(user); end

  # @param group_name [String]
  # @raise [NotImplementedError]
  # @return [Array<Rack::MiniProfiler::TimerStruct::Page>] list of snapshots of the group. Blank array if the group doesn't exist.
  def fetch_snapshots_group(group_name); end

  # returns a hash where the keys are group names and the values
  # are hashes that contain 3 keys:
  #   1. `:worst_score` => the duration of the worst/slowest snapshot in the group (float)
  #   2. `:best_score` => the duration of the best/fastest snapshot in the group (float)
  #   3. `:snapshots_count` => the number of snapshots in the group (integer)
  #
  # @raise [NotImplementedError]
  def fetch_snapshots_overview; end

  # @raise [NotImplementedError]
  def get_unviewed_ids(user); end

  # @raise [NotImplementedError]
  def load(id); end

  # @raise [NotImplementedError]
  def load_snapshot(id, group_name); end

  # @raise [NotImplementedError]
  def push_snapshot(page_struct, group_name, config); end

  # @raise [NotImplementedError]
  def save(page_struct); end

  # @raise [NotImplementedError]
  def set_all_unviewed(user, ids); end

  # @raise [NotImplementedError]
  def set_unviewed(user, id); end

  # @raise [NotImplementedError]
  def set_viewed(user, id); end

  # @raise [NotImplementedError]
  # @return [Boolean]
  def should_take_snapshot?(period); end

  def snapshots_group(group_name); end
  def snapshots_overview; end
end

# maximum age of allowed tokens before cycling in seconds
Rack::MiniProfiler::AbstractStore::MAX_TOKEN_AGE = T.let(T.unsafe(nil), Integer)

class Rack::MiniProfiler::ClientSettings
  # @return [ClientSettings] a new instance of ClientSettings
  def initialize(env, store, start); end

  # @return [Boolean]
  def backtrace_default?; end

  # @return [Boolean]
  def backtrace_full?; end

  # Returns the value of attribute backtrace_level.
  def backtrace_level; end

  # Sets the attribute backtrace_level
  #
  # @param value the value to set the attribute backtrace_level to.
  def backtrace_level=(_arg0); end

  # @return [Boolean]
  def backtrace_none?; end

  # Returns the value of attribute disable_profiling.
  def disable_profiling; end

  # Sets the attribute disable_profiling
  #
  # @param value the value to set the attribute disable_profiling to.
  def disable_profiling=(_arg0); end

  # @return [Boolean]
  def disable_profiling?; end

  def discard_cookie!(headers); end
  def handle_cookie(result); end

  # @return [Boolean]
  def has_valid_cookie?; end

  def write!(headers); end
end

Rack::MiniProfiler::ClientSettings::BACKTRACE_FULL = T.let(T.unsafe(nil), Integer)
Rack::MiniProfiler::ClientSettings::BACKTRACE_NONE = T.let(T.unsafe(nil), Integer)
Rack::MiniProfiler::ClientSettings::COOKIE_NAME = T.let(T.unsafe(nil), String)

class Rack::MiniProfiler::Config
  # Returns the value of attribute assets_url.
  def assets_url; end

  def assets_url=(lmbda); end

  # Returns the value of attribute authorization_mode.
  def authorization_mode; end

  # Sets the attribute authorization_mode
  #
  # @param value the value to set the attribute authorization_mode to.
  def authorization_mode=(mode); end

  # Returns the value of attribute auto_inject.
  def auto_inject; end

  # Sets the attribute auto_inject
  #
  # @param value the value to set the attribute auto_inject to.
  def auto_inject=(_arg0); end

  # Returns the value of attribute backtrace_ignores.
  def backtrace_ignores; end

  # Sets the attribute backtrace_ignores
  #
  # @param value the value to set the attribute backtrace_ignores to.
  def backtrace_ignores=(_arg0); end

  # Returns the value of attribute backtrace_includes.
  def backtrace_includes; end

  # Sets the attribute backtrace_includes
  #
  # @param value the value to set the attribute backtrace_includes to.
  def backtrace_includes=(_arg0); end

  # Returns the value of attribute backtrace_remove.
  def backtrace_remove; end

  # Sets the attribute backtrace_remove
  #
  # @param value the value to set the attribute backtrace_remove to.
  def backtrace_remove=(_arg0); end

  # Returns the value of attribute backtrace_threshold_ms.
  def backtrace_threshold_ms; end

  # Sets the attribute backtrace_threshold_ms
  #
  # @param value the value to set the attribute backtrace_threshold_ms to.
  def backtrace_threshold_ms=(_arg0); end

  # Returns the value of attribute base_url_path.
  def base_url_path; end

  # Sets the attribute base_url_path
  #
  # @param value the value to set the attribute base_url_path to.
  def base_url_path=(_arg0); end

  # ui accessors
  def collapse_results; end

  # ui accessors
  def collapse_results=(_arg0); end

  # Returns the value of attribute content_security_policy_nonce.
  def content_security_policy_nonce; end

  # Sets the attribute content_security_policy_nonce
  #
  # @param value the value to set the attribute content_security_policy_nonce to.
  def content_security_policy_nonce=(_arg0); end

  # Returns the value of attribute cookie_path.
  def cookie_path; end

  # Sets the attribute cookie_path
  #
  # @param value the value to set the attribute cookie_path to.
  def cookie_path=(_arg0); end

  # Returns the value of attribute disable_caching.
  def disable_caching; end

  # Sets the attribute disable_caching
  #
  # @param value the value to set the attribute disable_caching to.
  def disable_caching=(_arg0); end

  # Returns the value of attribute enable_advanced_debugging_tools.
  def enable_advanced_debugging_tools; end

  # Sets the attribute enable_advanced_debugging_tools
  #
  # @param value the value to set the attribute enable_advanced_debugging_tools to.
  def enable_advanced_debugging_tools=(_arg0); end

  # Returns the value of attribute enable_hotwire_turbo_drive_support.
  def enable_hotwire_turbo_drive_support; end

  # Sets the attribute enable_hotwire_turbo_drive_support
  #
  # @param value the value to set the attribute enable_hotwire_turbo_drive_support to.
  def enable_hotwire_turbo_drive_support=(_arg0); end

  # Returns the value of attribute enabled.
  def enabled; end

  # Sets the attribute enabled
  #
  # @param value the value to set the attribute enabled to.
  def enabled=(_arg0); end

  # Returns the value of attribute flamegraph_mode.
  def flamegraph_mode; end

  # Sets the attribute flamegraph_mode
  #
  # @param value the value to set the attribute flamegraph_mode to.
  def flamegraph_mode=(_arg0); end

  # Returns the value of attribute flamegraph_sample_rate.
  def flamegraph_sample_rate; end

  # Sets the attribute flamegraph_sample_rate
  #
  # @param value the value to set the attribute flamegraph_sample_rate to.
  def flamegraph_sample_rate=(_arg0); end

  def horizontal_position; end

  # ui accessors
  def html_container; end

  # ui accessors
  def html_container=(_arg0); end

  # Returns the value of attribute logger.
  def logger; end

  # Sets the attribute logger
  #
  # @param value the value to set the attribute logger to.
  def logger=(_arg0); end

  # snapshot related config
  def max_snapshot_groups; end

  # snapshot related config
  def max_snapshot_groups=(_arg0); end

  # snapshot related config
  def max_snapshots_per_group; end

  # snapshot related config
  def max_snapshots_per_group=(_arg0); end

  # Returns the value of attribute max_sql_param_length.
  def max_sql_param_length; end

  # Sets the attribute max_sql_param_length
  #
  # @param value the value to set the attribute max_sql_param_length to.
  def max_sql_param_length=(_arg0); end

  # ui accessors
  def max_traces_to_show; end

  # ui accessors
  def max_traces_to_show=(_arg0); end

  def merge!(config); end

  # ui accessors
  def position; end

  # ui accessors
  def position=(_arg0); end

  # Returns the value of attribute pre_authorize_cb.
  def pre_authorize_cb; end

  # Sets the attribute pre_authorize_cb
  #
  # @param value the value to set the attribute pre_authorize_cb to.
  def pre_authorize_cb=(_arg0); end

  # ui accessors
  def show_children; end

  # ui accessors
  def show_children=(_arg0); end

  # ui accessors
  def show_controls; end

  # ui accessors
  def show_controls=(_arg0); end

  # ui accessors
  def show_total_sql_count; end

  # ui accessors
  def show_total_sql_count=(_arg0); end

  # ui accessors
  def show_trivial; end

  # ui accessors
  def show_trivial=(_arg0); end

  # Returns the value of attribute skip_paths.
  def skip_paths; end

  # Sets the attribute skip_paths
  #
  # @param value the value to set the attribute skip_paths to.
  def skip_paths=(_arg0); end

  # Returns the value of attribute skip_schema_queries.
  def skip_schema_queries; end

  # Sets the attribute skip_schema_queries
  #
  # @param value the value to set the attribute skip_schema_queries to.
  def skip_schema_queries=(_arg0); end

  # Returns the value of attribute skip_sql_param_names.
  def skip_sql_param_names; end

  # Sets the attribute skip_sql_param_names
  #
  # @param value the value to set the attribute skip_sql_param_names to.
  def skip_sql_param_names=(_arg0); end

  # snapshot related config
  def snapshot_every_n_requests; end

  # snapshot related config
  def snapshot_every_n_requests=(_arg0); end

  # snapshot related config
  def snapshot_hidden_custom_fields; end

  # snapshot related config
  def snapshot_hidden_custom_fields=(_arg0); end

  # snapshot related config
  def snapshots_redact_sql_queries; end

  # snapshot related config
  def snapshots_redact_sql_queries=(_arg0); end

  # snapshot related config
  def snapshots_transport_auth_key; end

  # snapshot related config
  def snapshots_transport_auth_key=(_arg0); end

  # snapshot related config
  def snapshots_transport_destination_url; end

  # snapshot related config
  def snapshots_transport_destination_url=(_arg0); end

  # snapshot related config
  def snapshots_transport_gzip_requests; end

  # snapshot related config
  def snapshots_transport_gzip_requests=(_arg0); end

  # ui accessors
  def start_hidden; end

  # ui accessors
  def start_hidden=(_arg0); end

  # Returns the value of attribute storage.
  def storage; end

  # Sets the attribute storage
  #
  # @param value the value to set the attribute storage to.
  def storage=(_arg0); end

  # Returns the value of attribute storage_failure.
  def storage_failure; end

  # Sets the attribute storage_failure
  #
  # @param value the value to set the attribute storage_failure to.
  def storage_failure=(_arg0); end

  # Returns the value of attribute storage_instance.
  def storage_instance; end

  # Sets the attribute storage_instance
  #
  # @param value the value to set the attribute storage_instance to.
  def storage_instance=(_arg0); end

  # Returns the value of attribute storage_options.
  def storage_options; end

  # Sets the attribute storage_options
  #
  # @param value the value to set the attribute storage_options to.
  def storage_options=(_arg0); end

  # Returns the value of attribute suppress_encoding.
  def suppress_encoding; end

  # Sets the attribute suppress_encoding
  #
  # @param value the value to set the attribute suppress_encoding to.
  def suppress_encoding=(_arg0); end

  # ui accessors
  def toggle_shortcut; end

  # ui accessors
  def toggle_shortcut=(_arg0); end

  # Deprecated options
  def use_existing_jquery; end

  # Deprecated options
  def use_existing_jquery=(_arg0); end

  # Returns the value of attribute user_provider.
  def user_provider; end

  # Sets the attribute user_provider
  #
  # @param value the value to set the attribute user_provider to.
  def user_provider=(_arg0); end

  def vertical_position; end

  class << self
    def attr_accessor(*vars); end
    def attributes; end
    def default; end
  end
end

class Rack::MiniProfiler::Context
  # @return [Context] a new instance of Context
  def initialize(opts = T.unsafe(nil)); end

  # Returns the value of attribute current_timer.
  def current_timer; end

  # Sets the attribute current_timer
  #
  # @param value the value to set the attribute current_timer to.
  def current_timer=(_arg0); end

  # Returns the value of attribute discard.
  def discard; end

  # Sets the attribute discard
  #
  # @param value the value to set the attribute discard to.
  def discard=(_arg0); end

  # Returns the value of attribute full_backtrace.
  def full_backtrace; end

  # Sets the attribute full_backtrace
  #
  # @param value the value to set the attribute full_backtrace to.
  def full_backtrace=(_arg0); end

  # Returns the value of attribute inject_js.
  def inject_js; end

  # Sets the attribute inject_js
  #
  # @param value the value to set the attribute inject_js to.
  def inject_js=(_arg0); end

  # Returns the value of attribute measure.
  def measure; end

  # Sets the attribute measure
  #
  # @param value the value to set the attribute measure to.
  def measure=(_arg0); end

  # Returns the value of attribute mpt_init.
  def mpt_init; end

  # Sets the attribute mpt_init
  #
  # @param value the value to set the attribute mpt_init to.
  def mpt_init=(_arg0); end

  # Returns the value of attribute page_struct.
  def page_struct; end

  # Sets the attribute page_struct
  #
  # @param value the value to set the attribute page_struct to.
  def page_struct=(_arg0); end

  # Returns the value of attribute skip_backtrace.
  def skip_backtrace; end

  # Sets the attribute skip_backtrace
  #
  # @param value the value to set the attribute skip_backtrace to.
  def skip_backtrace=(_arg0); end
end

class Rack::MiniProfiler::FileStore < ::Rack::MiniProfiler::AbstractStore
  # @return [FileStore] a new instance of FileStore
  def initialize(args = T.unsafe(nil)); end

  def allowed_tokens; end
  def cleanup_cache; end
  def flush_tokens; end
  def get_unviewed_ids(user); end
  def load(id); end
  def save(page_struct); end
  def set_all_unviewed(user, ids); end
  def set_unviewed(user, id); end
  def set_viewed(user, id); end
end

# Sub-class thread so we have a named thread (useful for debugging in Thread.list).
class Rack::MiniProfiler::FileStore::CacheCleanupThread < ::Thread; end

Rack::MiniProfiler::FileStore::EXPIRES_IN_SECONDS = T.let(T.unsafe(nil), Integer)

class Rack::MiniProfiler::FileStore::FileCache
  # @return [FileCache] a new instance of FileCache
  def initialize(path, prefix); end

  def [](key); end
  def []=(key, val); end

  private

  def path(key); end
end

class Rack::MiniProfiler::GCProfiler
  # @return [GCProfiler] a new instance of GCProfiler
  def initialize; end

  def analyze_growth(ids_before, ids_after); end
  def analyze_initial_state(ids_before); end
  def analyze_strings(ids_before, ids_after); end
  def diff_object_stats(before, after); end
  def object_space_stats; end
  def profile_gc(app, env); end
end

class Rack::MiniProfiler::MemcacheStore < ::Rack::MiniProfiler::AbstractStore
  # @return [MemcacheStore] a new instance of MemcacheStore
  def initialize(args = T.unsafe(nil)); end

  def allowed_tokens; end
  def flush_tokens; end
  def get_unviewed_ids(user); end
  def load(id); end
  def save(page_struct); end
  def set_all_unviewed(user, ids); end
  def set_unviewed(user, id); end
  def set_viewed(user, id); end
end

Rack::MiniProfiler::MemcacheStore::EXPIRES_IN_SECONDS = T.let(T.unsafe(nil), Integer)
Rack::MiniProfiler::MemcacheStore::MAX_RETRIES = T.let(T.unsafe(nil), Integer)

class Rack::MiniProfiler::MemoryStore < ::Rack::MiniProfiler::AbstractStore
  # @return [MemoryStore] a new instance of MemoryStore
  def initialize(args = T.unsafe(nil)); end

  def allowed_tokens; end
  def cleanup_cache; end
  def fetch_snapshots_group(group_name); end
  def fetch_snapshots_overview; end
  def get_unviewed_ids(user); end

  # FIXME: use weak ref, trouble it may be broken in 1.9 so need to use the 'ref' gem
  def initialize_cleanup_thread(args = T.unsafe(nil)); end

  def initialize_locks; end
  def load(id); end
  def load_snapshot(id, group_name); end
  def push_snapshot(page_struct, group_name, config); end
  def save(page_struct); end
  def set_all_unviewed(user, ids); end
  def set_unviewed(user, id); end
  def set_viewed(user, id); end

  # @return [Boolean]
  def should_take_snapshot?(period); end

  private

  # used in tests only
  def wipe_snapshots_data; end
end

Rack::MiniProfiler::MemoryStore::CLEANUP_CYCLE = T.let(T.unsafe(nil), Integer)
Rack::MiniProfiler::MemoryStore::CLEANUP_INTERVAL = T.let(T.unsafe(nil), Integer)

# Sub-class thread so we have a named thread (useful for debugging in Thread.list).
class Rack::MiniProfiler::MemoryStore::CacheCleanupThread < ::Thread
  # @return [CacheCleanupThread] a new instance of CacheCleanupThread
  def initialize(interval, cycle, store); end

  def cleanup; end
  def cycle_count; end
  def increment_cycle; end

  # @return [Boolean]
  def should_cleanup?; end

  # We don't want to hit the filesystem every 10s to clean up the cache so we need to do a bit of
  # accounting to avoid sleeping that entire time.  We don't want to sleep for the entire period because
  # it means the thread will stay live in hot deployment scenarios, keeping a potentially large memory
  # graph from being garbage collected upon undeploy.
  def sleepy_run; end
end

Rack::MiniProfiler::MemoryStore::EXPIRES_IN_SECONDS = T.let(T.unsafe(nil), Integer)

module Rack::MiniProfiler::ProfilingMethods
  # Add a custom timing. These are displayed similar to SQL/query time in
  # columns expanding to the right.
  #
  # type        - String counter type. Each distinct type gets its own column.
  # duration_ms - Duration of the call in ms. Either this or a block must be
  #               given but not both.
  #
  # When a block is given, calculate the duration by yielding to the block
  # and keeping a record of its run time.
  #
  # Returns the result of the block, or nil when no block is given.
  def counter(type, duration_ms = T.unsafe(nil)); end

  def counter_method(klass, method, &blk); end
  def finish_step(obj); end
  def profile_method(klass, method, type = T.unsafe(nil), &blk); end
  def profile_singleton_method(klass, method, type = T.unsafe(nil), &blk); end
  def record_sql(query, elapsed_ms, params = T.unsafe(nil)); end
  def start_step(name); end

  # perform a profiling step on given block
  def step(name, opts = T.unsafe(nil)); end

  def uncounter_method(klass, method); end
  def unprofile_method(klass, method); end
  def unprofile_singleton_method(klass, method); end

  private

  def clean_method_name(method); end
end

class Rack::MiniProfiler::RedisStore < ::Rack::MiniProfiler::AbstractStore
  # @return [RedisStore] a new instance of RedisStore
  def initialize(args = T.unsafe(nil)); end

  def allowed_tokens; end
  def diagnostics(user); end
  def fetch_snapshots_group(group_name); end
  def fetch_snapshots_overview; end
  def flush_tokens; end

  # Remove expired ids from the unviewed sorted set and return the remaining ids
  def get_unviewed_ids(user); end

  def load(id); end
  def load_snapshot(id, group_name); end

  # Returns the value of attribute prefix.
  def prefix; end

  def push_snapshot(page_struct, group_name, config); end
  def save(page_struct); end
  def set_all_unviewed(user, ids); end
  def set_unviewed(user, id); end
  def set_viewed(user, id); end

  # @return [Boolean]
  def should_take_snapshot?(period); end

  # Only used for testing
  def simulate_expire; end

  private

  def cached_redis_eval(script, script_sha, reraise: T.unsafe(nil), argv: T.unsafe(nil), keys: T.unsafe(nil)); end
  def cleanup_corrupt_snapshots(corrupt_snapshots_ids, group_name); end
  def group_snapshot_hash_key(group_name); end
  def group_snapshot_zset_key(group_name); end
  def prefixed_id(id); end
  def redis; end
  def snapshot_counter_key; end
  def snapshot_overview_zset_key; end
  def user_key(user); end

  # only used in tests
  def wipe_snapshots_data; end
end

Rack::MiniProfiler::RedisStore::COUNTER_LUA = T.let(T.unsafe(nil), String)
Rack::MiniProfiler::RedisStore::COUNTER_LUA_SHA = T.let(T.unsafe(nil), String)
Rack::MiniProfiler::RedisStore::EXPIRES_IN_SECONDS = T.let(T.unsafe(nil), Integer)
Rack::MiniProfiler::SOURCE_CODE_URI = T.let(T.unsafe(nil), String)

class Rack::MiniProfiler::SnapshotsTransporter
  # @return [SnapshotsTransporter] a new instance of SnapshotsTransporter
  def initialize(config); end

  # Returns the value of attribute buffer.
  def buffer; end

  def flush_buffer; end

  # Returns the value of attribute gzip_requests.
  def gzip_requests; end

  # Sets the attribute gzip_requests
  #
  # @param value the value to set the attribute gzip_requests to.
  def gzip_requests=(_arg0); end

  # Returns the value of attribute max_buffer_size.
  def max_buffer_size; end

  # Sets the attribute max_buffer_size
  #
  # @param value the value to set the attribute max_buffer_size to.
  def max_buffer_size=(_arg0); end

  def requests_interval; end
  def ship(snapshot); end

  private

  def backoff_delay; end
  def start_thread; end

  class << self
    def failed_http_requests_count; end
    def successful_http_requests_count; end
    def transport(snapshot); end
    def transported_snapshots_count; end
  end
end

# Timing system for a SQL query
module Rack::MiniProfiler::TimerStruct; end

# A base class for timing structures
class Rack::MiniProfiler::TimerStruct::Base
  # @return [Base] a new instance of Base
  def initialize(attrs = T.unsafe(nil)); end

  def [](name); end
  def []=(name, val); end
  def as_json(options = T.unsafe(nil)); end
  def attributes; end
  def to_json(*a); end
end

# This class holds the client timings
class Rack::MiniProfiler::TimerStruct::Client < ::Rack::MiniProfiler::TimerStruct::Base
  # @return [Client] a new instance of Client
  def initialize(env = T.unsafe(nil)); end

  def redirect_count; end
  def timings; end

  class << self
    def init_from_form_data(env, page_struct); end
    def init_instrumentation; end

    # used by Railtie to instrument asset_tag for JS / CSS
    def instrument(name, orig); end
  end
end

# Timing system for a custom timers such as cache, redis, RPC, external API
# calls, etc.
class Rack::MiniProfiler::TimerStruct::Custom < ::Rack::MiniProfiler::TimerStruct::Base
  # @return [Custom] a new instance of Custom
  def initialize(type, duration_ms, page, parent); end

  # Returns the value of attribute parent.
  def parent; end

  # Sets the attribute parent
  #
  # @param value the value to set the attribute parent to.
  def parent=(_arg0); end
end

# TimerStruct::Page
#   Root: TimerStruct::Request
#     :has_many TimerStruct::Request children
#     :has_many TimerStruct::Sql children
#     :has_many TimerStruct::Custom children
class Rack::MiniProfiler::TimerStruct::Page < ::Rack::MiniProfiler::TimerStruct::Base
  # @return [Page] a new instance of Page
  def initialize(env); end

  def as_json(options = T.unsafe(nil)); end

  # Returns the value of attribute attributes.
  def attributes; end

  def attributes_to_serialize; end
  def duration_ms; end
  def duration_ms_in_sql; end
  def extra_json; end
  def name; end
  def root; end
  def to_json(*a); end

  class << self
    def from_hash(hash); end

    private

    def symbolize_array(array); end
    def symbolize_hash(hash); end
  end
end

class Rack::MiniProfiler::TimerStruct::Request < ::Rack::MiniProfiler::TimerStruct::Base
  # @return [Request] a new instance of Request
  def initialize(name, page, parent); end

  def add_child(name); end
  def add_custom(type, elapsed_ms, page); end
  def add_sql(query, elapsed_ms, page, params = T.unsafe(nil), skip_backtrace = T.unsafe(nil), full_backtrace = T.unsafe(nil)); end
  def adjust_depth; end
  def children; end

  # Returns the value of attribute children_duration.
  def children_duration; end

  # Sets the attribute children_duration
  #
  # @param value the value to set the attribute children_duration to.
  def children_duration=(_arg0); end

  def custom_timings; end
  def depth; end
  def duration_ms; end
  def duration_ms_in_sql; end
  def move_child(child, destination); end
  def move_custom(type, custom, destination); end
  def move_sql(sql, destination); end
  def name; end

  # Returns the value of attribute parent.
  def parent; end

  # Sets the attribute parent
  #
  # @param value the value to set the attribute parent to.
  def parent=(_arg0); end

  def record_time(milliseconds = T.unsafe(nil)); end
  def sql_timings; end

  # Returns the value of attribute start.
  def start; end

  # Sets the attribute start
  #
  # @param value the value to set the attribute start to.
  def start=(_arg0); end

  def start_ms; end

  class << self
    def createRoot(name, page); end
  end
end

class Rack::MiniProfiler::TimerStruct::Sql < ::Rack::MiniProfiler::TimerStruct::Base
  # @return [Sql] a new instance of Sql
  def initialize(query, duration_ms, page, parent, params = T.unsafe(nil), skip_backtrace = T.unsafe(nil), full_backtrace = T.unsafe(nil)); end

  # Returns the value of attribute parent.
  def parent; end

  # Sets the attribute parent
  #
  # @param value the value to set the attribute parent to.
  def parent=(_arg0); end

  def report_reader_duration(elapsed_ms); end
  def trim_binds(binds); end
end

Rack::MiniProfiler::VERSION = T.let(T.unsafe(nil), String)

module Rack::MiniProfilerRails
  extend ::Rack::MiniProfilerRailsMethods

  class << self
    def create_engine; end
    def get_key(payload); end

    # call direct if needed to do a defer init
    def initialize!(app); end

    # @return [Boolean]
    def serves_static_assets?(app); end

    def shorten_identifier(identifier); end
    def subscribe(event, &blk); end
  end
end

class Rack::MiniProfilerRails::Railtie < ::Rails::Railtie; end

module Rack::MiniProfilerRailsMethods
  extend ::Rack::MiniProfilerRailsMethods

  def get_webpacker_assets_path; end
  def render_notification_handler(name, finish, start, name_as_description: T.unsafe(nil)); end

  # @return [Boolean]
  def should_measure?; end

  # @return [Boolean]
  def should_move?(child, node); end
end

Rack::OPTIONS = T.let(T.unsafe(nil), String)
Rack::PATCH = T.let(T.unsafe(nil), String)
Rack::PATH_INFO = T.let(T.unsafe(nil), String)
Rack::POST = T.let(T.unsafe(nil), String)
Rack::PUT = T.let(T.unsafe(nil), String)
Rack::QUERY_STRING = T.let(T.unsafe(nil), String)
Rack::RACK_ERRORS = T.let(T.unsafe(nil), String)
Rack::RACK_HIJACK = T.let(T.unsafe(nil), String)
Rack::RACK_HIJACK_IO = T.let(T.unsafe(nil), String)
Rack::RACK_INPUT = T.let(T.unsafe(nil), String)
Rack::RACK_IS_HIJACK = T.let(T.unsafe(nil), String)
Rack::RACK_LOGGER = T.let(T.unsafe(nil), String)
Rack::RACK_METHODOVERRIDE_ORIGINAL_METHOD = T.let(T.unsafe(nil), String)
Rack::RACK_MULTIPART_BUFFER_SIZE = T.let(T.unsafe(nil), String)
Rack::RACK_MULTIPART_TEMPFILE_FACTORY = T.let(T.unsafe(nil), String)
Rack::RACK_MULTIPROCESS = T.let(T.unsafe(nil), String)
Rack::RACK_MULTITHREAD = T.let(T.unsafe(nil), String)
Rack::RACK_RECURSIVE_INCLUDE = T.let(T.unsafe(nil), String)
Rack::RACK_REQUEST_COOKIE_HASH = T.let(T.unsafe(nil), String)
Rack::RACK_REQUEST_COOKIE_STRING = T.let(T.unsafe(nil), String)
Rack::RACK_REQUEST_FORM_HASH = T.let(T.unsafe(nil), String)
Rack::RACK_REQUEST_FORM_INPUT = T.let(T.unsafe(nil), String)
Rack::RACK_REQUEST_FORM_VARS = T.let(T.unsafe(nil), String)
Rack::RACK_REQUEST_QUERY_HASH = T.let(T.unsafe(nil), String)
Rack::RACK_REQUEST_QUERY_STRING = T.let(T.unsafe(nil), String)
Rack::RACK_RUNONCE = T.let(T.unsafe(nil), String)
Rack::RACK_SESSION = T.let(T.unsafe(nil), String)
Rack::RACK_SESSION_OPTIONS = T.let(T.unsafe(nil), String)
Rack::RACK_SESSION_UNPACKED_COOKIE_DATA = T.let(T.unsafe(nil), String)
Rack::RACK_SHOWSTATUS_DETAIL = T.let(T.unsafe(nil), String)
Rack::RACK_TEMPFILES = T.let(T.unsafe(nil), String)
Rack::RACK_URL_SCHEME = T.let(T.unsafe(nil), String)

# Rack environment variables
Rack::RACK_VERSION = T.let(T.unsafe(nil), String)

Rack::RELEASE = T.let(T.unsafe(nil), String)
Rack::REQUEST_METHOD = T.let(T.unsafe(nil), String)
Rack::REQUEST_PATH = T.let(T.unsafe(nil), String)
Rack::SCRIPT_NAME = T.let(T.unsafe(nil), String)
Rack::SERVER_NAME = T.let(T.unsafe(nil), String)
Rack::SERVER_PORT = T.let(T.unsafe(nil), String)
Rack::SERVER_PROTOCOL = T.let(T.unsafe(nil), String)
Rack::SET_COOKIE = T.let(T.unsafe(nil), String)
Rack::TRACE = T.let(T.unsafe(nil), String)
Rack::TRANSFER_ENCODING = T.let(T.unsafe(nil), String)
Rack::UNLINK = T.let(T.unsafe(nil), String)

# The Rack protocol version number implemented.
Rack::VERSION = T.let(T.unsafe(nil), Array)

class SqlPatches
  class << self
    def all_patch_files; end

    # @return [Boolean]
    def correct_version?(required_version, klass); end

    def elapsed_time(start_time); end
    def other_patches; end
    def patch(patch_files = T.unsafe(nil)); end

    # @return [Boolean]
    def patch_rails?; end

    def record_sql(statement, parameters = T.unsafe(nil), &block); end

    # @return [Boolean]
    def should_measure?; end

    def sql_patches; end
  end
end
