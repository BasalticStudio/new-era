# typed: true

# DO NOT EDIT MANUALLY
# This is an autogenerated file for types exported from the `dry-system` gem.
# Please instead update this file by running `bin/tapioca gem dry-system`.

# source://dry-system//lib/dry/system.rb#6
module Dry
  class << self
    # source://dry-auto_inject/0.9.0/lib/dry/auto_inject.rb#43
    def AutoInject(container, options = T.unsafe(nil)); end

    # source://dry-configurable/0.16.1/lib/dry/configurable.rb#11
    def Configurable(**options); end

    # source://dry-core/0.9.1/lib/dry/core.rb#40
    def Equalizer(*keys, **options); end
  end
end

# source://dry-system//lib/dry/system.rb#7
module Dry::System
  include ::Dry::Core::Constants
  extend ::Dry::Core::Deprecations::Interface

  class << self
    # @api private
    #
    # source://dry-system//lib/dry/system.rb#9
    def loader; end

    # @api private
    #
    # source://dry-system//lib/dry/system.rb#73
    def provider_sources; end

    # source://dry-system//lib/dry/system.rb#61
    def register_component(name, provider:, &block); end

    # source://dry-system//lib/dry/system.rb#30
    def register_provider(_name, options); end

    # Registers a provider source, which can be used as the basis for other providers
    #
    # @api public
    #
    # source://dry-system//lib/dry/system.rb#44
    def register_provider_source(name, group:, source: T.unsafe(nil), &block); end

    # Registers the provider sources in the files under the given path
    #
    # @api public
    #
    # source://dry-system//lib/dry/system.rb#26
    def register_provider_sources(path); end
  end
end

# Default auto-registration implementation
#
# This is currently configured by default for every System::Container.
# Auto-registrar objects are responsible for loading files from configured
# auto-register paths and registering components automatically within the
# container.
#
# @api private
#
# source://dry-system//lib/dry/system/auto_registrar.rb#15
class Dry::System::AutoRegistrar
  # @api private
  # @return [AutoRegistrar] a new instance of AutoRegistrar
  #
  # source://dry-system//lib/dry/system/auto_registrar.rb#18
  def initialize(container); end

  # @api private
  #
  # source://dry-system//lib/dry/system/auto_registrar.rb#30
  def call(component_dir); end

  # @api private
  #
  # source://dry-system//lib/dry/system/auto_registrar.rb#16
  def container; end

  # @api private
  #
  # source://dry-system//lib/dry/system/auto_registrar.rb#23
  def finalize!; end

  private

  # @api private
  # @return [Boolean]
  #
  # source://dry-system//lib/dry/system/auto_registrar.rb#40
  def register_component?(component); end
end

# Components are objects providing information about auto-registered files.
# They expose an API to query this information and use a configurable
# loader object to initialize class instances.
#
# @api public
#
# source://dry-system//lib/dry/system/component.rb#15
class Dry::System::Component
  include ::Dry::Core::Equalizer::Methods

  # @api private
  # @return [Component] a new instance of Component
  #
  # source://dry-system//lib/dry/system/component.rb#40
  def initialize(identifier, file_path:, namespace:, **options); end

  # @api private
  # @return [Boolean]
  #
  # source://dry-system//lib/dry/system/component.rb#160
  def auto_register?; end

  # Returns an "underscored", path-delimited representation of the component,
  # appropriate for passing to the inflector for constantizing
  #
  # The const path takes into account the rules of the namespace used to load the
  # component.
  #
  # @api public
  # @example Component from a namespace with `const: nil`
  #   component.key # => "articles.create_article"
  #   component.const_path # => "articles/create_article"
  #   component.inflector.constantize(component.const_path) # => Articles::CreateArticle
  # @example Component from a namespace with `const: "admin"`
  #   component.key # => "articles.create_article"
  #   component.const_path # => "admin/articles/create_article"
  #   component.inflector.constantize(component.const_path) # => Admin::Articles::CreateArticle
  # @return [String] the const path
  # @see Config::Namespaces#add
  # @see Config::Namespace
  #
  # source://dry-system//lib/dry/system/component.rb#139
  def const_path; end

  # @api public
  #
  # source://dry-system//lib/dry/system/component.rb#29
  def file_path; end

  # @api public
  #
  # source://dry-system//lib/dry/system/component.rb#25
  def identifier; end

  # @api private
  #
  # source://dry-system//lib/dry/system/component.rb#155
  def inflector; end

  # Returns the component's instance
  #
  # @api public
  # @return [Object] component's class instance
  #
  # source://dry-system//lib/dry/system/component.rb#63
  def instance(*args, **_arg1); end

  # Returns the component's unique key
  #
  # @api public
  # @return [String] the key
  # @see Identifier#key
  #
  # source://dry-system//lib/dry/system/component.rb#75
  def key; end

  # Returns true, indicating that the component is directly loadable from the files
  # managed by the container
  #
  # This is the inverse of {IndirectComponent#loadable?}
  #
  # @api private
  # @return [TrueClass]
  #
  # source://dry-system//lib/dry/system/component.rb#55
  def loadable?; end

  # @api private
  #
  # source://dry-system//lib/dry/system/component.rb#150
  def loader; end

  # @api private
  # @return [Boolean]
  #
  # source://dry-system//lib/dry/system/component.rb#165
  def memoize?; end

  # @api public
  #
  # source://dry-system//lib/dry/system/component.rb#33
  def namespace; end

  # @api public
  #
  # source://dry-system//lib/dry/system/component.rb#37
  def options; end

  # Returns a path-delimited representation of the compnent, appropriate for passing
  # to `Kernel#require` to require its source file
  #
  # The path takes into account the rules of the namespace used to load the component.
  #
  # @api public
  # @example Component from a root namespace
  #   component.key # => "articles.create"
  #   component.require_path # => "articles/create"
  # @example Component from an "admin/" path namespace (with `key: nil`)
  #   component.key # => "articles.create"
  #   component.require_path # => "admin/articles/create"
  # @return [String] the require path
  # @see Config::Namespaces#add
  # @see Config::Namespace
  #
  # source://dry-system//lib/dry/system/component.rb#109
  def require_path; end

  # Returns the root namespace segment of the component's key, as a symbol
  #
  # @api public
  # @return [Symbol] the root key
  # @see Identifier#root_key
  #
  # source://dry-system//lib/dry/system/component.rb#86
  def root_key; end

  private

  # @api public
  # @return [Boolean]
  #
  # source://dry-system//lib/dry/system/component.rb#182
  def callable_option?(value); end

  # @api public
  #
  # source://dry-system//lib/dry/system/component.rb#171
  def path_in_namespace; end
end

# @api public
#
# source://dry-system//lib/dry/system/component.rb#18
Dry::System::Component::DEFAULT_OPTIONS = T.let(T.unsafe(nil), Hash)

# A configured component directory within the container's root. Provides access to the
# component directory's configuration, as well as methods for locating component files
# within the directory
#
# @api private
# @see Dry::System::Config::ComponentDir
#
# source://dry-system//lib/dry/system/component_dir.rb#14
class Dry::System::ComponentDir
  # @api private
  # @return [ComponentDir] a new instance of ComponentDir
  #
  # source://dry-system//lib/dry/system/component_dir.rb#26
  def initialize(config:, container:); end

  # Returns a component for the given key if a matching source file is found within
  # the component dir
  #
  # This searches according to the component dir's configured namespaces, in order of
  # definition, with the first match returned as the component.
  #
  # @api private
  # @param key [String] the component's key
  # @return [Dry::System::Component, nil] the component, if found
  #
  # source://dry-system//lib/dry/system/component_dir.rb#41
  def component_for_key(key); end

  # @api private
  #
  # source://dry-system//lib/dry/system/component_dir.rb#18
  def config; end

  # @api private
  #
  # source://dry-system//lib/dry/system/component_dir.rb#23
  def container; end

  # @api private
  #
  # source://dry-system//lib/dry/system/component_dir.rb#55
  def each_component; end

  private

  # @api private
  #
  # source://dry-system//lib/dry/system/component_dir.rb#134
  def build_component(identifier, namespace, file_path); end

  # Returns a component for a full path to a Ruby source file within the component dir
  #
  # @api private
  # @param path [String] the full path to the file
  # @return [Dry::System::Component] the component
  #
  # source://dry-system//lib/dry/system/component_dir.rb#100
  def component_for_path(path, namespace); end

  # @api private
  #
  # source://dry-system//lib/dry/system/component_dir.rb#149
  def component_options; end

  # @api private
  # @raise [ComponentDirNotFoundError]
  #
  # source://dry-system//lib/dry/system/component_dir.rb#65
  def each_file; end

  # @api private
  #
  # source://dry-system//lib/dry/system/component_dir.rb#77
  def files(namespace); end

  # @api private
  #
  # source://dry-system//lib/dry/system/component_dir.rb#115
  def find_component_file(identifier, namespace); end

  # Returns the full path of the component directory
  #
  # @api private
  # @return [Pathname]
  #
  # source://dry-system//lib/dry/system/component_dir.rb#92
  def full_path; end

  # @api private
  #
  # source://dry-system//lib/dry/system/component_dir.rb#158
  def method_missing(name, *args, &block); end

  # @api private
  # @return [Boolean]
  #
  # source://dry-system//lib/dry/system/component_dir.rb#166
  def respond_to_missing?(name, include_all = T.unsafe(nil)); end
end

# Error raised when a component dir is added to configuration more than once
#
# @api public
#
# source://dry-system//lib/dry/system/errors.rb#10
class Dry::System::ComponentDirAlreadyAddedError < ::StandardError
  # source://dry-system//lib/dry/system/errors.rb#11
  def initialize(dir); end
end

# Error raised when a configured component directory could not be found
#
# @api public
#
# source://dry-system//lib/dry/system/errors.rb#19
class Dry::System::ComponentDirNotFoundError < ::StandardError
  # source://dry-system//lib/dry/system/errors.rb#20
  def initialize(dir); end
end

# Exception raised when auto-registerable component is not loadable
#
# @api public
#
# source://dry-system//lib/dry/system/errors.rb#97
class Dry::System::ComponentNotLoadableError < ::NameError
  # source://dry-system//lib/dry/system/errors.rb#99
  def initialize(component, error, corrections: T.unsafe(nil)); end
end

# source://dry-system//lib/dry/system/container.rb#0
module Dry::System::Config; end

# @api public
#
# source://dry-system//lib/dry/system/config/component_dir.rb#9
class Dry::System::Config::ComponentDir
  include ::Dry::Configurable::Initializer
  include ::Dry::Core::Constants
  include ::Dry::Configurable
  include ::Dry::Configurable::Methods
  include ::Dry::Configurable::InstanceMethods
  extend ::Dry::Configurable::Methods
  extend ::Dry::Configurable::ClassMethods

  # @api public
  # @return [ComponentDir] a new instance of ComponentDir
  # @yield [_self]
  # @yieldparam _self [Dry::System::Config::ComponentDir] the object that the method was called on
  #
  # source://dry-configurable/0.16.1/lib/dry/configurable/instance_methods.rb#14
  def initialize(*_arg0, **_arg1); end

  # @api private
  # @return [Boolean]
  #
  # source://dry-system//lib/dry/system/config/component_dir.rb#242
  def auto_register?; end

  # @api public
  #
  # source://dry-system//lib/dry/system/config/component_dir.rb#212
  def default_namespace; end

  # @api public
  #
  # source://dry-system//lib/dry/system/config/component_dir.rb#194
  def default_namespace=(namespace); end

  # Returns the component dir path, relative to the configured container root
  #
  # @api public
  # @return [String] the path
  #
  # source://dry-system//lib/dry/system/config/component_dir.rb#232
  def path; end

  private

  # @api public
  #
  # source://dry-system//lib/dry/system/config/component_dir.rb#248
  def method_missing(name, *args, &block); end

  # @api public
  # @return [Boolean]
  #
  # source://dry-system//lib/dry/system/config/component_dir.rb#256
  def respond_to_missing?(name, include_all = T.unsafe(nil)); end
end

# The configured component dirs for a container
#
# @api public
#
# source://dry-system//lib/dry/system/config/component_dirs.rb#12
class Dry::System::Config::ComponentDirs
  # Creates a new component dirs
  #
  # @api private
  # @return [ComponentDirs] a new instance of ComponentDirs
  #
  # source://dry-system//lib/dry/system/config/component_dirs.rb#106
  def initialize; end

  # Returns and optionally yields a previously added component dir
  #
  # @api public
  # @param path [String] the path for the component dir
  # @return [ComponentDir] the component dir
  # @yieldparam dir [ComponentDir] the component dir
  #
  # source://dry-system//lib/dry/system/config/component_dirs.rb#125
  def [](path); end

  # @api public
  # @overload add
  # @overload add
  # @raise [ComponentDirAlreadyAddedError]
  #
  # source://dry-system//lib/dry/system/config/component_dirs.rb#164
  def add(path_or_dir); end

  # A ComponentDir for configuring the default values to apply to all added
  # component dirs
  #
  # @api private
  # @see #method_missing
  #
  # source://dry-system//lib/dry/system/config/component_dirs.rb#101
  def defaults; end

  # Deletes and returns a previously added component dir
  #
  # @api public
  # @param path [String] the path for the component dir
  # @return [ComponentDir] the removed component dir
  #
  # source://dry-system//lib/dry/system/config/component_dirs.rb#185
  def delete(path); end

  # Returns and optionally yields a previously added component dir
  #
  # @api public
  # @param path [String] the path for the component dir
  # @return [ComponentDir] the component dir
  # @yieldparam dir [ComponentDir] the component dir
  #
  # source://dry-system//lib/dry/system/config/component_dirs.rb#125
  def dir(path); end

  # Calls the given block once for each added component dir, passing the dir as an
  # argument.
  #
  # @api public
  # @yieldparam dir [ComponentDir] the yielded component dir
  #
  # source://dry-system//lib/dry/system/config/component_dirs.rb#224
  def each(&block); end

  # Returns the count of component dirs
  #
  # @api public
  # @return [Integer]
  #
  # source://dry-system//lib/dry/system/config/component_dirs.rb#203
  def length; end

  # Returns the paths of the component dirs
  #
  # @api public
  # @return [Array<String>] the component dir paths
  #
  # source://dry-system//lib/dry/system/config/component_dirs.rb#194
  def paths; end

  # Returns the count of component dirs
  #
  # @api public
  # @return [Integer]
  #
  # source://dry-system//lib/dry/system/config/component_dirs.rb#203
  def size; end

  # Returns the added component dirs, with default settings applied
  #
  # @api public
  # @return [Array<ComponentDir>]
  #
  # source://dry-system//lib/dry/system/config/component_dirs.rb#213
  def to_a; end

  protected

  # Returns the hash of component dirs, keyed by their paths
  #
  # Recently changed default configuration may not be applied to these dirs. Use
  # #to_a or #each to access dirs with default configuration fully applied.
  #
  # This method exists to encapsulate the instance variable and to serve the needs
  # of #initialize_copy
  #
  # @api private
  # @return [Hash{String => ComponentDir}]
  #
  # source://dry-system//lib/dry/system/config/component_dirs.rb#241
  def dirs; end

  private

  # Applies default settings to a component dir. This is run every time the dirs are
  # accessed to ensure defaults are applied regardless of when new component dirs
  # are added. This method must be idempotent.
  #
  # @api public
  # @return [void]
  #
  # source://dry-system//lib/dry/system/config/component_dirs.rb#267
  def apply_defaults_to_dir(dir); end

  # @api private
  #
  # source://dry-system//lib/dry/system/config/component_dirs.rb#112
  def initialize_copy(source); end

  # @api public
  #
  # source://dry-system//lib/dry/system/config/component_dirs.rb#275
  def method_missing(name, *args, &block); end

  # Converts a path string or pre-built component dir into a path and dir tuple
  #
  # @api public
  # @param path_or_dir [String, ComponentDir]
  # @return [Array<(String, ComponentDir)>]
  # @see #add
  #
  # source://dry-system//lib/dry/system/config/component_dirs.rb#252
  def path_and_dir(path_or_dir); end

  # @api public
  # @return [Boolean]
  #
  # source://dry-system//lib/dry/system/config/component_dirs.rb#283
  def respond_to_missing?(name, include_all = T.unsafe(nil)); end
end

# A configured namespace for a component dir
#
# Namespaces consist of three elements:
#
# - The `path` within the component dir to which its namespace rules should apply.
# - A `key`, which determines the leading part of the key used to register
#   each component in the container.
# - A `const`, which is the Ruby namespace expected to contain the class constants
#   defined within each component's source file. This value is expected to be an
#   "underscored" string, intended to be run through the configured inflector to be
#   converted into a real constant (e.g. `"foo_bar/baz"` will become `FooBar::Baz`)
#
# Namespaces are added and configured for a component dir via {Namespaces#add}.
#
# @api public
# @see Namespaces#add
#
# source://dry-system//lib/dry/system/config/namespace.rb#25
class Dry::System::Config::Namespace
  include ::Dry::Core::Equalizer::Methods

  # @api private
  # @return [Namespace] a new instance of Namespace
  #
  # source://dry-system//lib/dry/system/config/namespace.rb#55
  def initialize(path:, key:, const:); end

  # @api public
  #
  # source://dry-system//lib/dry/system/config/namespace.rb#37
  def const; end

  # @api public
  #
  # source://dry-system//lib/dry/system/config/namespace.rb#34
  def key; end

  # @api public
  #
  # source://dry-system//lib/dry/system/config/namespace.rb#31
  def path; end

  # @api public
  # @return [Boolean]
  #
  # source://dry-system//lib/dry/system/config/namespace.rb#69
  def path?; end

  # @api public
  # @return [Boolean]
  #
  # source://dry-system//lib/dry/system/config/namespace.rb#64
  def root?; end

  class << self
    # Returns a namespace configured to serve as the default root namespace for a
    # component dir, ensuring that all code within the dir can be loaded, regardless
    # of any other explictly configured namespaces
    #
    # @api private
    # @return [Namespace] the root namespace
    #
    # source://dry-system//lib/dry/system/config/namespace.rb#46
    def default_root; end
  end
end

# @api public
#
# source://dry-system//lib/dry/system/config/namespace.rb#26
Dry::System::Config::Namespace::ROOT_PATH = T.let(T.unsafe(nil), T.untyped)

# The configured namespaces for a ComponentDir
#
# @api private
# @see Config::ComponentDir#namespaces
#
# source://dry-system//lib/dry/system/config/namespaces.rb#13
class Dry::System::Config::Namespaces
  include ::Dry::Core::Equalizer::Methods

  # @api private
  # @return [Namespaces] a new instance of Namespaces
  #
  # source://dry-system//lib/dry/system/config/namespaces.rb#20
  def initialize; end

  # Returns the namespace configured for the path, or nil if no such namespace has
  # been configured
  #
  # @api public
  # @return [Namespace, nil] the namespace, if configured
  #
  # source://dry-system//lib/dry/system/config/namespaces.rb#36
  def [](path); end

  # Adds a component dir namespace
  #
  # A namespace encompasses a given sub-directory of the component dir, and
  # determines (1) the leading segments of its components' registered identifiers,
  # and (2) the expected constant namespace of their class constants.
  #
  # A namespace for a path can only be added once.
  #
  # @api public
  # @example Adding a namespace with top-level identifiers
  #   # Components defined within admin/ (e.g. admin/my_component.rb) will be:
  #   #
  #   # - Registered with top-level identifiers ("my_component")
  #   # - Expected to have constants in `Admin`, matching the namespace's path (Admin::MyComponent)
  #
  #   namespaces.add "admin", key: nil
  # @example Adding a namespace with top-level class constants
  #   # Components defined within adapters/ (e.g. adapters/my_adapter.rb) will be:
  #   #
  #   # - Registered with leading identifiers matching the namespace's path ("adapters.my_adapter")
  #   # - Expected to have top-level constants (::MyAdapter)
  #
  #   namespaces.add "adapters", const: nil
  # @example Adding a namespace with distinct identifiers and class constants
  #   # Components defined within `bananas/` (e.g. bananas/banana_split.rb) will be:
  #   #
  #   # - Registered with the given leading identifier ("desserts.banana_split")
  #   # - Expected to have constants within the given namespace (EatMe::Now::BananaSplit)
  #
  #   namespaces.add "bananas", key: "desserts", const: "eat_me/now"
  # @param key [String, nil] the leading namespace to apply to the container keys
  #   for the components. Set `nil` for the keys to be top-level.
  # @param path [String] the path to the sub-directory of source files to which this
  #   namespace should apply, relative to the component dir
  # @param const [String, nil] the Ruby constant namespace to expect for constants
  #   defined within the components. This should be provided in underscored string
  #   form, e.g. "hello_there/world" for a Ruby constant of `HelloThere::World`. Set
  #   `nil` for the constants to be top-level.
  # @raise [NamespaceAlreadyAddedError]
  # @return [Namespace] the added namespace
  # @see Namespace
  #
  # source://dry-system//lib/dry/system/config/namespaces.rb#111
  def add(path, key: T.unsafe(nil), const: T.unsafe(nil)); end

  # Adds a root component dir namespace
  #
  # @api public
  # @see #add
  #
  # source://dry-system//lib/dry/system/config/namespaces.rb#124
  def add_root(key: T.unsafe(nil), const: T.unsafe(nil)); end

  # Deletes the configured namespace for the given path and returns the namespace
  #
  # If no namespace was previously configured for the given path, returns nil
  #
  # @api public
  # @param path [String] the path for the namespace
  # @return [Namespace, nil]
  #
  # source://dry-system//lib/dry/system/config/namespaces.rb#137
  def delete(path); end

  # Deletes the configured root namespace and returns the namespace
  #
  # If no root namespace was previously configured, returns nil
  #
  # @api public
  # @return [Namespace, nil]
  #
  # source://dry-system//lib/dry/system/config/namespaces.rb#148
  def delete_root; end

  # Calls the given block once for each configured namespace, passing the namespace
  # as an argument.
  #
  # @api public
  # @yieldparam namespace [Namespace] the yielded namespace
  #
  # source://dry-system//lib/dry/system/config/namespaces.rb#202
  def each(&block); end

  # Returns true if there are no configured namespaces
  #
  # @api public
  # @return [Boolean]
  #
  # source://dry-system//lib/dry/system/config/namespaces.rb#177
  def empty?; end

  # Returns the count of configured namespaces
  #
  # @api public
  # @return [Integer]
  #
  # source://dry-system//lib/dry/system/config/namespaces.rb#167
  def length; end

  # Returns the namespace configured for the path, or nil if no such namespace has
  # been configured
  #
  # @api public
  # @return [Namespace, nil] the namespace, if configured
  #
  # source://dry-system//lib/dry/system/config/namespaces.rb#36
  def namespace(path); end

  # @api private
  #
  # source://dry-system//lib/dry/system/config/namespaces.rb#17
  def namespaces; end

  # Returns the paths of the configured namespaces
  #
  # @api public
  # @return [Array<String,nil>] the namespace paths, with nil representing the root
  #   namespace
  #
  # source://dry-system//lib/dry/system/config/namespaces.rb#158
  def paths; end

  # Returns the namespace configured for the root path, or nil if the root namespace
  # has not been configured
  #
  # @api public
  # @return [Namespace, nil] the root namespace, if configured
  #
  # source://dry-system//lib/dry/system/config/namespaces.rb#47
  def root(**options); end

  # Returns the count of configured namespaces
  #
  # @api public
  # @return [Integer]
  #
  # source://dry-system//lib/dry/system/config/namespaces.rb#167
  def size; end

  # Returns the configured namespaces as an array
  #
  # Adds a default root namespace to the end of the array if one was not added
  # explicitly. This fallback ensures that all components in the component dir can
  # be loaded.
  #
  # @api public
  # @return [Array<Namespace>] the namespaces
  #
  # source://dry-system//lib/dry/system/config/namespaces.rb#190
  def to_a; end

  private

  # @api private
  #
  # source://dry-system//lib/dry/system/config/namespaces.rb#25
  def initialize_copy(source); end
end

# Abstract container class to inherit from
#
# Container class is treated as a global registry with all system components.
# Container can also import dependencies from other containers, which is
# useful in complex systems that are split into sub-systems.
#
# Container can be finalized, which triggers loading of all the defined
# components within a system, after finalization it becomes frozen. This
# typically happens in cases like booting a web application.
#
# Before finalization, Container can lazy-load components on demand. A
# component can be a simple class defined in a single file, or a complex
# component which has init/start/stop lifecycle, and it's defined in a boot
# file. Components which specify their dependencies using Import module can
# be safely required in complete isolation, and Container will resolve and
# load these dependencies automatically.
#
# Furthermore, Container supports auto-registering components based on
# dir/file naming conventions. This reduces a lot of boilerplate code as all
# you have to do is to put your classes under configured directories and
# their instances will be automatically registered within a container.
#
# Every container needs to be configured with following settings:
#
# * `:name` - a unique container name
# * `:root` - a system root directory (defaults to `pwd`)
#
# @api public
# @example
#   class MyApp < Dry::System::Container
#   configure do |config|
#   config.name = :my_app
#
#   # this will auto-register classes from 'lib/components'. ie if you add
#   # `lib/components/repo.rb` which defines `Repo` class, then it's
#   # instance will be automatically available as `MyApp['repo']`
#   config.auto_register = %w(lib/components)
#   end
#
#   # this will configure $LOAD_PATH to include your `lib` dir
#   add_dirs_to_load_paths!('lib')
#   end
#
# source://dry-system//lib/dry/system/container.rb#55
class Dry::System::Container
  extend ::Dry::Container::Mixin
  extend ::Dry::Container::Configuration
  extend ::Dry::Core::Constants
  extend ::Dry::Configurable
  extend ::Dry::Configurable::Methods
  extend ::Dry::Configurable::ClassMethods
  extend ::Dry::System::Plugins

  class << self
    # Finalizes the config for this container
    #
    # @api private
    #
    # source://dry-configurable/0.16.1/lib/dry/configurable/methods.rb#22
    def _configurable_finalize!(freeze_values: T.unsafe(nil)); end

    # Adds the directories (relative to the container's root) to the Ruby load path
    #
    # @api public
    # @example
    #   class MyApp < Dry::System::Container
    #   configure do |config|
    #   # ...
    #   end
    #
    #   add_to_load_path!('lib')
    #   end
    # @param dirs [Array<String>]
    # @return [self]
    #
    # source://dry-system//lib/dry/system/container.rb#445
    def add_to_load_path!(*dirs); end

    # Registers a callback hook to run after container lifecycle events.
    #
    # The supported events are:
    #
    # - `:configured`, called when you run {configure} or {configured!}, or when
    #   running {finalize!} and neither of the prior two methods have been called.
    # - `:finalized`, called when you run {finalize!}.
    #
    # When the given block is called, `self` is the container class, and no block
    # arguments are given.
    #
    # @api public
    # @param event [Symbol] the event name
    # @param block [Proc] the callback hook to run
    # @return [self]
    #
    # source://dry-system//lib/dry/system/container.rb#619
    def after(event, &block); end

    # @api private
    #
    # source://dry-system//lib/dry/system/container.rb#569
    def auto_registrar; end

    # Registers a callback hook to run before container lifecycle events.
    #
    # Currently, the only supported event is `:finalized`. This hook is called when
    # you run `{finalize!}`.
    #
    # When the given block is called, `self` is the container class, and no block
    # arguments are given.
    #
    # @api public
    # @param event [Symbol] the event name
    # @param block [Proc] the callback hook to run
    # @return [self]
    #
    # source://dry-system//lib/dry/system/container.rb#597
    def before(event, &block); end

    # @api public
    # @see .register_provider
    #
    # source://dry-system//lib/dry/system/container.rb#296
    def boot(name, **opts, &block); end

    # source://dry-core/0.9.1/lib/dry/core/deprecations.rb#168
    def booter(*args, &block); end

    # @api private
    #
    # source://dry-system//lib/dry/system/container.rb#558
    def component_dirs; end

    # Yields a configuration object for the container, which you can use to modify the
    # configuration, then runs the after-`configured` hooks and finalizes (freezes)
    # the {config}.
    #
    # Does not finalize the config when given `finalize_config: false`
    #
    # @api public
    # @example
    #   class MyApp < Dry::System::Container
    #   configure do |config|
    #   config.root = Pathname("/path/to/app")
    #   config.name = :my_app
    #   end
    #   end
    # @param finalize_config [Boolean]
    # @return [self]
    # @see after
    #
    # source://dry-system//lib/dry/system/container.rb#110
    def configure(finalize_config: T.unsafe(nil), &block); end

    # Marks the container as configured, runs the after-`configured` hooks, then
    # finalizes (freezes) the {config}.
    #
    # This method is useful to call if you're modifying the container's {config}
    # directly, rather than via the config object yielded when calling {configure}.
    #
    # Does not finalize the config if given `finalize_config: false`.
    #
    # @api public
    # @param finalize_config [Boolean]
    # @return [self]
    # @see after
    #
    # source://dry-system//lib/dry/system/container.rb#130
    def configured!(finalize_config: T.unsafe(nil)); end

    # @api public
    # @return [Boolean]
    #
    # source://dry-system//lib/dry/system/container.rb#147
    def configured?; end

    # source://dry-core/0.9.1/lib/dry/core/deprecations.rb#168
    def finalize(*args, &block); end

    # Finalizes the container
    #
    # This triggers importing components from other containers, booting
    # registered components and auto-registering components. It should be
    # called only in places where you want to finalize your system as a
    # whole, ie when booting a web application
    #
    # @api public
    # @example
    #   # system/container.rb
    #   class MyApp < Dry::System::Container
    #   configure do |config|
    #   config.root = Pathname("/path/to/app")
    #   config.name = :my_app
    #   config.auto_register = %w(lib/apis lib/core)
    #   end
    #   end
    #
    #   # You can put finalization file anywhere you want, ie system/boot.rb
    #   MyApp.finalize!
    #
    #   # If you need last-moment adjustments just before the finalization
    #   # you can pass a block and do it there
    #   MyApp.finalize! do |container|
    #   # stuff that only needs to happen for finalization
    #   end
    # @return [self] frozen container
    # @yield [_self]
    # @yieldparam _self [Dry::System::Container] the object that the method was called on
    #
    # source://dry-system//lib/dry/system/container.rb#352
    def finalize!(freeze: T.unsafe(nil), &block); end

    # Return if a container was finalized
    #
    # @api public
    # @return [TrueClass, FalseClass]
    #
    # source://dry-system//lib/dry/system/container.rb#319
    def finalized?; end

    # @api private
    #
    # source://dry-system//lib/dry/system/container.rb#625
    def hooks; end

    # Registers another container for import
    #
    # @api public
    # @example
    #   # system/container.rb
    #   class Core < Dry::System::Container
    #   configure do |config|
    #   config.root = Pathname("/path/to/app")
    #   config.auto_register = %w(lib/apis lib/core)
    #   end
    #   end
    #
    #   # apps/my_app/system/container.rb
    #   require 'system/container'
    #
    #   class MyApp < Dry::System::Container
    #   configure do |config|
    #   config.root = Pathname("/path/to/app")
    #   config.auto_register = %w(lib/apis lib/core)
    #   end
    #
    #   import core: Core
    #   end
    # @param other [Hash, Dry::Container::Namespace]
    #
    # source://dry-system//lib/dry/system/container.rb#177
    def import(keys: T.unsafe(nil), from: T.unsafe(nil), as: T.unsafe(nil), **deprecated_import_hash); end

    # @api private
    #
    # source://dry-system//lib/dry/system/container.rb#579
    def importer; end

    # @api private
    # @private
    #
    # source://dry-system//lib/dry/system/container.rb#630
    def inherited(klass); end

    # source://dry-core/0.9.1/lib/dry/core/deprecations.rb#168
    def init(*args, &block); end

    # Builds injector for this container
    #
    # An injector is a useful mixin which injects dependencies into
    # automatically defined constructor.
    #
    # @api public
    # @example
    #   # Define an injection mixin
    #   #
    #   # system/import.rb
    #   Import = MyApp.injector
    #
    #   # Use it in your auto-registered classes
    #   #
    #   # lib/user_repo.rb
    #   require 'import'
    #
    #   class UserRepo
    #   include Import['persistence.db']
    #   end
    #
    #   MyApp['user_repo].db # instance under 'persistence.db' key
    # @param options [Hash] injector options
    #
    # source://dry-system//lib/dry/system/container.rb#483
    def injector(**options); end

    # Check if identifier is registered.
    # If not, try to load the component
    #
    # @api public
    # @param key [String, Symbol] Identifier
    # @return [Boolean]
    #
    # source://dry-system//lib/dry/system/container.rb#548
    def key?(key); end

    # @api public
    #
    # source://dry-system//lib/dry/system/container.rb#453
    def load_registrations!(name); end

    # @api private
    #
    # source://dry-system//lib/dry/system/container.rb#574
    def manifest_registrar; end

    # Prepares a provider using its `prepare` lifecycle trigger
    #
    # Preparing (as opposed to starting) a provider is useful in places where some
    # aspects of a heavier dependency are needed, but its fully started environment
    #
    # @api public
    # @example
    #   MyApp.prepare(:persistence)
    # @param name [Symbol] The name of the registered provider to prepare
    # @return [self]
    #
    # source://dry-system//lib/dry/system/container.rb#402
    def prepare(name); end

    # @api private
    #
    # source://dry-system//lib/dry/system/container.rb#563
    def providers; end

    # @api public
    # @overload register_provider
    #
    # source://dry-system//lib/dry/system/container.rb#288
    def register_provider(*_arg0, **_arg1, &_arg2); end

    # Whether a +key+ is registered (doesn't trigger loading)
    #
    # @api public
    # @param key [String, Symbol] The key
    # @return [Boolean]
    #
    # source://dry-container/0.11.0/lib/dry/container/mixin.rb#224
    def registered?(key); end

    # Requires one or more files relative to the container's root
    #
    # @api public
    # @example
    #   # single file
    #   MyApp.require_from_root('lib/core')
    #
    #   # glob
    #   MyApp.require_from_root('lib/**/*')
    # @param paths [Array<String>] one or more paths, supports globs too
    #
    # source://dry-system//lib/dry/system/container.rb#499
    def require_from_root(*paths); end

    # @api public
    #
    # source://dry-system//lib/dry/system/container.rb#526
    def resolve(key); end

    # Returns container's root path
    #
    # @api public
    # @example
    #   class MyApp < Dry::System::Container
    #   configure do |config|
    #   config.root = Pathname('/my/app')
    #   end
    #   end
    #
    #   MyApp.root # returns '/my/app' pathname
    # @return [Pathname]
    #
    # source://dry-system//lib/dry/system/container.rb#521
    def root; end

    # @api public
    #
    # source://dry-system//lib/dry/system/container.rb#424
    def shutdown!; end

    # Starts a provider
    #
    # As a result, the provider's `prepare` and `start` lifecycle triggers are called
    #
    # @api public
    # @example
    #   MyApp.start(:persistence)
    # @param name [Symbol] the name of a registered provider to start
    # @return [self]
    #
    # source://dry-system//lib/dry/system/container.rb#384
    def start(name); end

    # Stop a specific component but calls only `stop` lifecycle trigger
    #
    # @api public
    # @example
    #   MyApp.stop(:persistence)
    # @param name [Symbol] The name of a registered bootable component
    # @return [self]
    #
    # source://dry-system//lib/dry/system/container.rb#418
    def stop(name); end

    protected

    # @api private
    #
    # source://dry-system//lib/dry/system/container.rb#645
    def load_component(key); end

    private

    # @api public
    #
    # source://dry-system//lib/dry/system/container.rb#688
    def find_component(key); end

    # @api public
    #
    # source://dry-system//lib/dry/system/container.rb#680
    def load_imported_component(identifier, namespace:); end

    # @api public
    #
    # source://dry-system//lib/dry/system/container.rb#674
    def load_local_component(component); end
  end
end

Dry::System::DuplicatedComponentKeyError = Dry::System::ProviderAlreadyRegisteredError

# source://dry-core/0.9.1/lib/dry/core/constants.rb#112
Dry::System::EMPTY_ARRAY = T.let(T.unsafe(nil), Array)

# source://dry-core/0.9.1/lib/dry/core/constants.rb#112
Dry::System::EMPTY_HASH = T.let(T.unsafe(nil), Hash)

# source://dry-core/0.9.1/lib/dry/core/constants.rb#112
Dry::System::EMPTY_OPTS = T.let(T.unsafe(nil), Hash)

# source://dry-core/0.9.1/lib/dry/core/constants.rb#112
Dry::System::EMPTY_SET = T.let(T.unsafe(nil), Set)

# source://dry-core/0.9.1/lib/dry/core/constants.rb#112
Dry::System::EMPTY_STRING = T.let(T.unsafe(nil), String)

# source://dry-core/0.9.1/lib/dry/core/constants.rb#112
Dry::System::IDENTITY = T.let(T.unsafe(nil), Proc)

# An identifier representing a component to be registered.
#
# Components are eventually registered in the container using plain string
# identifiers, available as the `identifier` or `key` attribute here. Additional
# methods are provided to make it easier to evaluate or manipulate these identifiers.
#
# @api public
#
# source://dry-system//lib/dry/system/identifier.rb#14
class Dry::System::Identifier
  include ::Dry::Core::Equalizer::Methods

  # @api private
  # @return [Identifier] a new instance of Identifier
  #
  # source://dry-system//lib/dry/system/identifier.rb#22
  def initialize(key); end

  # Returns true if the given trailing segments string is the end part of the {key}.
  #
  # Also returns true if nil or an empty string is given.
  #
  # @api public
  # @example
  #   identifier.key # => "articles.operations.create"
  #
  #   identifier.end_with?("create") # => true
  #   identifier.end_with?("operations.create") # => true
  #   identifier.end_with?("ate") # => false, not a whole segment
  #   identifier.end_with?("nup") # => false, not in key at all
  # @param trailing_segments [String] the one or more trailing key segments to check
  # @return [Boolean]
  #
  # source://dry-system//lib/dry/system/identifier.rb#82
  def end_with?(trailing_segments); end

  # Returns true if the given segments string matches whole segments within the {key}.
  #
  # @api public
  # @example
  #   identifier.key # => "articles.operations.create"
  #
  #   identifier.include?("operations") # => true
  #   identifier.include?("articles.operations") # => true
  #   identifier.include?("operations.create") # => true
  #
  #   identifier.include?("article") # => false, not a whole segment
  #   identifier.include?("update") # => false, not in key at all
  # @param segments [String] the one of more key segments to check
  # @return [Boolean]
  #
  # source://dry-system//lib/dry/system/identifier.rb#103
  def include?(segments); end

  # @api public
  # @return [String] the identifier's string key
  #
  # source://dry-system//lib/dry/system/identifier.rb#19
  def key; end

  # Returns the key with its segments separated by the given separator
  #
  # @api private
  # @example
  #   identifier.key # => "articles.operations.create"
  #   identifier.key_with_separator("/") # => "articles/operations/create"
  # @return [String] the key using the separator
  #
  # source://dry-system//lib/dry/system/identifier.rb#124
  def key_with_separator(separator); end

  # Returns a copy of the identifier with the key's leading namespace(s) replaced
  #
  # @api private
  # @example Changing a namespace
  #   identifier.key # => "articles.operations.create"
  #   identifier.namespaced(from: "articles", to: "posts").key # => "posts.commands.create"
  # @example Removing a namespace
  #   identifier.key # => "articles.operations.create"
  #   identifier.namespaced(from: "articles", to: nil).key # => "operations.create"
  # @example Adding a namespace
  #   identifier.key # => "articles.operations.create"
  #   identifier.namespaced(from: nil, to: "admin").key # => "admin.articles.operations.create"
  # @param from [String, nil] the leading namespace(s) to replace
  # @param to [String, nil] the replacement for the leading namespace
  # @return [Dry::System::Identifier] the copy of the identifier
  # @see #initialize
  #
  # source://dry-system//lib/dry/system/identifier.rb#149
  def namespaced(from:, to:); end

  # Returns the root namespace segment of the identifier string, as a symbol
  #
  # @api public
  # @example
  #   identifier.key # => "articles.operations.create"
  #   identifier.root_key # => :articles
  # @return [Symbol] the root key
  #
  # source://dry-system//lib/dry/system/identifier.rb#42
  def root_key; end

  # Returns true if the given leading segments string is a leading part of the {key}.
  #
  # Also returns true if nil or an empty string is given.
  #
  # @api public
  # @example
  #   identifier.key # => "articles.operations.create"
  #
  #   identifier.start_with?("articles.operations") # => true
  #   identifier.start_with?("articles") # => true
  #   identifier.start_with?("article") # => false
  #   identifier.start_with?(nil) # => true
  # @param leading_segments [String] the one or more leading segments to check
  # @return [Boolean]
  #
  # source://dry-system//lib/dry/system/identifier.rb#61
  def start_with?(leading_segments); end

  # @api public
  # @return [String] the identifier's string key
  #
  # source://dry-system//lib/dry/system/identifier.rb#19
  def to_s; end

  private

  # @api public
  #
  # source://dry-system//lib/dry/system/identifier.rb#171
  def segments; end
end

# Default importer implementation
#
# This is currently configured by default for every System::Container.
# Importer objects are responsible for importing components from one
# container to another. This is used in cases where an application is split
# into multiple sub-systems.
#
# @api private
#
# source://dry-system//lib/dry/system/importer.rb#16
class Dry::System::Importer
  # @api private
  # @return [Importer] a new instance of Importer
  #
  # source://dry-system//lib/dry/system/importer.rb#33
  def initialize(container); end

  # @api private
  #
  # source://dry-system//lib/dry/system/importer.rb#48
  def [](name); end

  # @api private
  #
  # source://dry-system//lib/dry/system/importer.rb#28
  def container; end

  # @api private
  #
  # source://dry-system//lib/dry/system/importer.rb#59
  def finalize!; end

  # @api private
  #
  # source://dry-system//lib/dry/system/importer.rb#65
  def import(namespace, keys: T.unsafe(nil)); end

  # @api private
  # @return [Boolean]
  #
  # source://dry-system//lib/dry/system/importer.rb#53
  def key?(name); end

  # @api private
  # @return [Boolean]
  #
  # source://dry-system//lib/dry/system/importer.rb#53
  def namespace?(name); end

  # @api private
  #
  # source://dry-system//lib/dry/system/importer.rb#39
  def register(namespace:, container:, keys: T.unsafe(nil)); end

  # @api private
  #
  # source://dry-system//lib/dry/system/importer.rb#30
  def registry; end

  private

  # @api private
  #
  # source://dry-system//lib/dry/system/importer.rb#108
  def build_merge_container(other, keys); end

  # @api private
  #
  # source://dry-system//lib/dry/system/importer.rb#90
  def import_all(other, namespace); end

  # @api private
  #
  # source://dry-system//lib/dry/system/importer.rb#86
  def import_keys(other, namespace, keys); end

  # @api private
  #
  # source://dry-system//lib/dry/system/importer.rb#80
  def keys_to_import(keys, item); end

  # Merges `other` into `container`, favoring the container's existing registrations
  #
  # @api private
  #
  # source://dry-system//lib/dry/system/importer.rb#102
  def merge(container, other, namespace:); end
end

# @api private
#
# source://dry-system//lib/dry/system/importer.rb#18
class Dry::System::Importer::Item
  # @api private
  # @return [Item] a new instance of Item
  #
  # source://dry-system//lib/dry/system/importer.rb#21
  def initialize(namespace:, container:, import_keys:); end

  # @api private
  #
  # source://dry-system//lib/dry/system/importer.rb#19
  def container; end

  # @api private
  #
  # source://dry-system//lib/dry/system/importer.rb#19
  def import_keys; end

  # @api private
  #
  # source://dry-system//lib/dry/system/importer.rb#19
  def namespace; end
end

# An indirect component is a component that cannot be directly from a source file
# directly managed by the container. It may be component that needs to be loaded
# indirectly, either via a registration manifest file or an imported container
#
# Indirect components are an internal abstraction and, unlike ordinary components, are
# not exposed to users via component dir configuration hooks.
#
# @api private
# @see Container#load_component
# @see Container#find_component
#
# source://dry-system//lib/dry/system/indirect_component.rb#16
class Dry::System::IndirectComponent
  include ::Dry::Core::Equalizer::Methods

  # @api private
  # @return [IndirectComponent] a new instance of IndirectComponent
  #
  # source://dry-system//lib/dry/system/indirect_component.rb#24
  def initialize(identifier); end

  # @api private
  #
  # source://dry-system//lib/dry/system/indirect_component.rb#21
  def identifier; end

  # Returns the component's unique key
  #
  # @api private
  # @return [String] the key
  # @see Identifier#key
  #
  # source://dry-system//lib/dry/system/indirect_component.rb#47
  def key; end

  # Returns false, indicating that the component is not directly loadable from the
  # files managed by the container
  #
  # This is the inverse of {Component#loadable?}
  #
  # @api private
  # @return [FalseClass]
  #
  # source://dry-system//lib/dry/system/indirect_component.rb#36
  def loadable?; end

  # Returns the root namespace segment of the component's key, as a symbol
  #
  # @api private
  # @return [Symbol] the root key
  # @see Identifier#root_key
  #
  # source://dry-system//lib/dry/system/indirect_component.rb#58
  def root_key; end
end

Dry::System::InvalidComponentError = Dry::System::ProviderNotFoundError

# source://dry-system//lib/dry/system/constants.rb#10
Dry::System::KEY_SEPARATOR = T.let(T.unsafe(nil), String)

# Default component loader implementation
#
# This class is configured by default for every System::Container. You can
# provide your own and use it in your containers too.
#
# @api public
# @example
#   class MyLoader < Dry::System::Loader
#   def call(*args)
#   constant.build(*args)
#   end
#   end
#
#   class MyApp < Dry::System::Container
#   configure do |config|
#   # ...
#   config.component_dirs.loader = MyLoader
#   end
#   end
#
# source://dry-system//lib/dry/system/loader.rb#27
class Dry::System::Loader
  class << self
    # Returns an instance of the component
    #
    # Provided optional args are passed to object's constructor
    #
    # @api public
    # @param args [Array] Optional constructor args
    # @return [Object]
    #
    # source://dry-system//lib/dry/system/loader.rb#46
    def call(component, *args, **_arg2); end

    # Returns the component's class constant
    #
    # @api public
    # @return [Class]
    #
    # source://dry-system//lib/dry/system/loader.rb#64
    def constant(component); end

    # Requires the component's source file
    #
    # @api public
    #
    # source://dry-system//lib/dry/system/loader.rb#32
    def require!(component); end

    private

    # @api public
    # @return [Boolean]
    #
    # source://dry-system//lib/dry/system/loader.rb#74
    def singleton?(constant); end
  end
end

# Component loader for autoloading-enabled applications
#
# This behaves like the default loader, except instead of requiring the given path,
# it loads the respective constant, allowing the autoloader to load the
# corresponding file per its own configuration.
#
# @api public
# @see Loader
#
# source://dry-system//lib/dry/system/loader/autoloading.rb#14
class Dry::System::Loader::Autoloading < ::Dry::System::Loader
  class << self
    # @api public
    #
    # source://dry-system//lib/dry/system/loader/autoloading.rb#16
    def require!(component); end
  end
end

# source://dry-system//lib/dry/system/magic_comments_parser.rb#5
class Dry::System::MagicCommentsParser
  class << self
    # source://dry-system//lib/dry/system/magic_comments_parser.rb#14
    def call(file_name); end

    # source://dry-system//lib/dry/system/magic_comments_parser.rb#26
    def coerce(value); end
  end
end

# source://dry-system//lib/dry/system/magic_comments_parser.rb#9
Dry::System::MagicCommentsParser::COERCIONS = T.let(T.unsafe(nil), Hash)

# source://dry-system//lib/dry/system/magic_comments_parser.rb#7
Dry::System::MagicCommentsParser::COMMENT_RE = T.let(T.unsafe(nil), Regexp)

# source://dry-system//lib/dry/system/magic_comments_parser.rb#6
Dry::System::MagicCommentsParser::VALID_LINE_RE = T.let(T.unsafe(nil), Regexp)

# Default manifest registration implementation
#
# This is configured by default for every System::Container. The manifest registrar is
# responsible for loading manifest files that contain code to manually register
# certain objects with the container.
#
# @api private
#
# source://dry-system//lib/dry/system/manifest_registrar.rb#14
class Dry::System::ManifestRegistrar
  # @api private
  # @return [ManifestRegistrar] a new instance of ManifestRegistrar
  #
  # source://dry-system//lib/dry/system/manifest_registrar.rb#22
  def initialize(container); end

  # @api private
  #
  # source://dry-system//lib/dry/system/manifest_registrar.rb#35
  def call(component); end

  # @api private
  #
  # source://dry-system//lib/dry/system/manifest_registrar.rb#19
  def config; end

  # @api private
  #
  # source://dry-system//lib/dry/system/manifest_registrar.rb#16
  def container; end

  # @api private
  # @return [Boolean]
  #
  # source://dry-system//lib/dry/system/manifest_registrar.rb#40
  def file_exists?(component); end

  # @api private
  #
  # source://dry-system//lib/dry/system/manifest_registrar.rb#28
  def finalize!; end

  private

  # @api private
  #
  # source://dry-system//lib/dry/system/manifest_registrar.rb#47
  def registrations_dir; end

  # @api private
  #
  # source://dry-system//lib/dry/system/manifest_registrar.rb#52
  def root; end
end

# Error raised when a namespace for a component dir is added to configuration more
# than once
#
# @api public
#
# source://dry-system//lib/dry/system/errors.rb#29
class Dry::System::NamespaceAlreadyAddedError < ::StandardError
  # source://dry-system//lib/dry/system/errors.rb#30
  def initialize(path); end
end

# source://dry-system//lib/dry/system/constants.rb#9
Dry::System::PATH_SEPARATOR = T.let(T.unsafe(nil), String)

# Exception raise when a plugin dependency failed to load
#
# @api public
#
# source://dry-system//lib/dry/system/errors.rb#86
class Dry::System::PluginDependencyMissing < ::StandardError
  # source://dry-system//lib/dry/system/errors.rb#88
  def initialize(plugin, message, gem = T.unsafe(nil)); end
end

# Error raised when trying to use a plugin that does not exist.
#
# @api public
#
# source://dry-system//lib/dry/system/errors.rb#77
class Dry::System::PluginNotFoundError < ::StandardError
  # source://dry-system//lib/dry/system/errors.rb#78
  def initialize(plugin_name); end
end

# source://dry-system//lib/dry/system/plugins.rb#5
module Dry::System::Plugins
  # @api private
  #
  # source://dry-system//lib/dry/system/plugins.rb#57
  def enabled_plugins; end

  # @api private
  #
  # source://dry-system//lib/dry/system/plugins.rb#51
  def inherited(klass); end

  # Enables a plugin if not already enabled.
  # Raises error if plugin cannot be found in the plugin registry.
  #
  # @api public
  # @param name [Symbol] The plugin name
  # @param options [Hash] Plugin options
  # @raise [PluginNotFoundError]
  # @return [self]
  #
  # source://dry-system//lib/dry/system/plugins.rb#37
  def use(name, **options); end

  class << self
    # @api private
    #
    # source://dry-system//lib/dry/system/plugins.rb#24
    def loaded_dependencies; end

    # Register a plugin
    #
    # @api public
    # @param name [Symbol] The name of a plugin
    # @param plugin [Class] Plugin module
    # @return [Plugins]
    #
    # source://dry-system//lib/dry/system/plugins.rb#14
    def register(name, plugin, &block); end

    # @api private
    #
    # source://dry-system//lib/dry/system/plugins.rb#19
    def registry; end
  end
end

# source://dry-system//lib/dry/system/plugins/bootsnap.rb#6
module Dry::System::Plugins::Bootsnap
  # @api private
  # @return [Boolean]
  #
  # source://dry-system//lib/dry/system/plugins/bootsnap.rb#39
  def bootsnap_available?; end

  # Set up bootsnap for faster booting
  #
  # @api public
  #
  # source://dry-system//lib/dry/system/plugins/bootsnap.rb#32
  def setup_bootsnap; end

  class << self
    # @api private
    #
    # source://dry-system//lib/dry/system/plugins/bootsnap.rb#25
    def dependencies; end

    # @api private
    # @private
    #
    # source://dry-system//lib/dry/system/plugins/bootsnap.rb#16
    def extended(system); end
  end
end

# source://dry-system//lib/dry/system/plugins/bootsnap.rb#7
Dry::System::Plugins::Bootsnap::DEFAULT_OPTIONS = T.let(T.unsafe(nil), Hash)

# @api public
#
# source://dry-system//lib/dry/system/plugins/dependency_graph.rb#7
module Dry::System::Plugins::DependencyGraph
  # @api private
  #
  # source://dry-system//lib/dry/system/plugins/dependency_graph.rb#32
  def injector(**options); end

  # @api private
  #
  # source://dry-system//lib/dry/system/plugins/dependency_graph.rb#37
  def register(key, contents = T.unsafe(nil), options = T.unsafe(nil), &block); end

  class << self
    # @api private
    #
    # source://dry-system//lib/dry/system/plugins/dependency_graph.rb#27
    def dependencies; end

    # @api private
    # @private
    #
    # source://dry-system//lib/dry/system/plugins/dependency_graph.rb#9
    def extended(system); end
  end
end

# @api private
#
# source://dry-system//lib/dry/system/plugins/dependency_graph/strategies.rb#8
class Dry::System::Plugins::DependencyGraph::Strategies
  extend ::Dry::Container::Mixin
  extend ::Dry::Container::Configuration
  extend ::Dry::Core::Constants
  extend ::Dry::Configurable
  extend ::Dry::Configurable::Methods
  extend ::Dry::Configurable::ClassMethods
end

# @api private
#
# source://dry-system//lib/dry/system/plugins/dependency_graph/strategies.rb#28
class Dry::System::Plugins::DependencyGraph::Strategies::Args < ::Dry::AutoInject::Strategies::Args
  private

  # @api private
  #
  # source://dry-system//lib/dry/system/plugins/dependency_graph/strategies.rb#32
  def define_initialize(klass); end
end

# @api private
#
# source://dry-system//lib/dry/system/plugins/dependency_graph/strategies.rb#43
class Dry::System::Plugins::DependencyGraph::Strategies::Hash < ::Dry::AutoInject::Strategies::Hash
  private

  # @api private
  #
  # source://dry-system//lib/dry/system/plugins/dependency_graph/strategies.rb#47
  def define_initialize(klass); end
end

# @api private
#
# source://dry-system//lib/dry/system/plugins/dependency_graph/strategies.rb#12
class Dry::System::Plugins::DependencyGraph::Strategies::Kwargs < ::Dry::AutoInject::Strategies::Kwargs
  private

  # @api private
  #
  # source://dry-system//lib/dry/system/plugins/dependency_graph/strategies.rb#16
  def define_initialize(klass); end
end

# @api public
#
# source://dry-system//lib/dry/system/plugins/env.rb#7
class Dry::System::Plugins::Env < ::Module
  # @api private
  # @return [Env] a new instance of Env
  #
  # source://dry-system//lib/dry/system/plugins/env.rb#13
  def initialize(**options); end

  # @api private
  #
  # source://dry-system//lib/dry/system/plugins/env.rb#23
  def extended(system); end

  # @api public
  #
  # source://dry-system//lib/dry/system/plugins/env.rb#18
  def inferrer; end

  # @api public
  #
  # source://dry-system//lib/dry/system/plugins/env.rb#10
  def options; end
end

# @api public
#
# source://dry-system//lib/dry/system/plugins/env.rb#8
Dry::System::Plugins::Env::DEFAULT_INFERRER = T.let(T.unsafe(nil), Proc)

# source://dry-system//lib/dry/system/plugins/logging.rb#8
module Dry::System::Plugins::Logging
  # @api private
  #
  # source://dry-system//lib/dry/system/plugins/logging.rb#57
  def log_dir_path; end

  # @api private
  #
  # source://dry-system//lib/dry/system/plugins/logging.rb#67
  def log_file_name; end

  # @api private
  #
  # source://dry-system//lib/dry/system/plugins/logging.rb#62
  def log_file_path; end

  # @api private
  #
  # source://dry-system//lib/dry/system/plugins/logging.rb#52
  def log_level; end

  # Set a logger
  #
  # This is invoked automatically when a container is being configured
  #
  # @api private
  # @return [self]
  #
  # source://dry-system//lib/dry/system/plugins/logging.rb#37
  def register_logger; end

  class << self
    # @api private
    # @private
    #
    # source://dry-system//lib/dry/system/plugins/logging.rb#10
    def extended(system); end
  end
end

# @api public
#
# source://dry-system//lib/dry/system/plugins/monitoring.rb#9
module Dry::System::Plugins::Monitoring
  # @api private
  #
  # source://dry-system//lib/dry/system/plugins/monitoring.rb#27
  def monitor(key, **options, &block); end

  class << self
    # @api private
    #
    # source://dry-system//lib/dry/system/plugins/monitoring.rb#22
    def dependencies; end

    # @api private
    # @private
    #
    # source://dry-system//lib/dry/system/plugins/monitoring.rb#11
    def extended(system); end
  end
end

# @api private
#
# source://dry-system//lib/dry/system/plugins/monitoring/proxy.rb#11
class Dry::System::Plugins::Monitoring::Proxy < ::SimpleDelegator
  # @api private
  # @return [Proxy] a new instance of Proxy
  #
  # source://dry-system//lib/dry/system/plugins/monitoring/proxy.rb#43
  def initialize(target, notifications); end

  class << self
    # @api private
    #
    # source://dry-system//lib/dry/system/plugins/monitoring/proxy.rb#12
    def for(target, key:, methods: T.unsafe(nil)); end
  end
end

# @api public
#
# source://dry-system//lib/dry/system/plugins/notifications.rb#7
module Dry::System::Plugins::Notifications
  # @api private
  #
  # source://dry-system//lib/dry/system/plugins/notifications.rb#19
  def register_notifications; end

  class << self
    # @api private
    #
    # source://dry-system//lib/dry/system/plugins/notifications.rb#14
    def dependencies; end

    # @api private
    # @private
    #
    # source://dry-system//lib/dry/system/plugins/notifications.rb#9
    def extended(system); end
  end
end

# @api private
#
# source://dry-system//lib/dry/system/plugins/plugin.rb#7
class Dry::System::Plugins::Plugin
  # @api private
  # @return [Plugin] a new instance of Plugin
  #
  # source://dry-system//lib/dry/system/plugins/plugin.rb#15
  def initialize(name, mod, &block); end

  # @api private
  #
  # source://dry-system//lib/dry/system/plugins/plugin.rb#22
  def apply_to(system, **options); end

  # @api private
  #
  # source://dry-system//lib/dry/system/plugins/plugin.rb#12
  def block; end

  # @api private
  #
  # source://dry-system//lib/dry/system/plugins/plugin.rb#29
  def load_dependencies(dependencies = T.unsafe(nil), gem = T.unsafe(nil)); end

  # @api private
  #
  # source://dry-system//lib/dry/system/plugins/plugin.rb#40
  def load_dependency(dependency, gem); end

  # @api private
  #
  # source://dry-system//lib/dry/system/plugins/plugin.rb#10
  def mod; end

  # @api private
  #
  # source://dry-system//lib/dry/system/plugins/plugin.rb#53
  def mod_dependencies; end

  # @api private
  #
  # source://dry-system//lib/dry/system/plugins/plugin.rb#8
  def name; end

  # @api private
  # @return [Boolean]
  #
  # source://dry-system//lib/dry/system/plugins/plugin.rb#48
  def stateful?; end
end

# @api private
#
# source://dry-system//lib/dry/system/plugins/zeitwerk.rb#10
class Dry::System::Plugins::Zeitwerk < ::Module
  # @api private
  # @return [Zeitwerk] a new instance of Zeitwerk
  #
  # source://dry-system//lib/dry/system/plugins/zeitwerk.rb#23
  def initialize(loader: T.unsafe(nil), run_setup: T.unsafe(nil), eager_load: T.unsafe(nil), debug: T.unsafe(nil)); end

  # @api private
  #
  # source://dry-system//lib/dry/system/plugins/zeitwerk.rb#20
  def debug; end

  # @api private
  #
  # source://dry-system//lib/dry/system/plugins/zeitwerk.rb#20
  def eager_load; end

  # @api private
  #
  # source://dry-system//lib/dry/system/plugins/zeitwerk.rb#32
  def extended(system); end

  # @api private
  #
  # source://dry-system//lib/dry/system/plugins/zeitwerk.rb#20
  def loader; end

  # @api private
  #
  # source://dry-system//lib/dry/system/plugins/zeitwerk.rb#20
  def run_setup; end

  private

  # Build a zeitwerk loader with the configured component directories
  #
  # @api private
  # @return [Zeitwerk::Loader]
  #
  # source://dry-system//lib/dry/system/plugins/zeitwerk.rb#61
  def configure_loader(loader, system); end

  # @api private
  # @return [Boolean]
  #
  # source://dry-system//lib/dry/system/plugins/zeitwerk.rb#101
  def eager_load?(system); end

  # @api private
  #
  # source://dry-system//lib/dry/system/plugins/zeitwerk.rb#95
  def get_or_define_module(parent_mod, name); end

  # @api private
  #
  # source://dry-system//lib/dry/system/plugins/zeitwerk.rb#83
  def module_for_namespace(namespace, inflector); end

  # Add component dirs to the zeitwerk loader
  #
  # @api private
  # @return [Zeitwerk::Loader]
  #
  # source://dry-system//lib/dry/system/plugins/zeitwerk.rb#70
  def push_component_dirs_to_loader(system, loader); end

  # @api private
  #
  # source://dry-system//lib/dry/system/plugins/zeitwerk.rb#46
  def setup_autoloader(system); end

  class << self
    # @api private
    #
    # source://dry-system//lib/dry/system/plugins/zeitwerk.rb#11
    def dependencies; end
  end
end

# @api private
#
# source://dry-system//lib/dry/system/plugins/zeitwerk/compat_inflector.rb#8
class Dry::System::Plugins::Zeitwerk::CompatInflector
  # @api private
  # @return [CompatInflector] a new instance of CompatInflector
  #
  # source://dry-system//lib/dry/system/plugins/zeitwerk/compat_inflector.rb#11
  def initialize(config); end

  # @api private
  #
  # source://dry-system//lib/dry/system/plugins/zeitwerk/compat_inflector.rb#15
  def camelize(string, _); end

  # @api private
  #
  # source://dry-system//lib/dry/system/plugins/zeitwerk/compat_inflector.rb#9
  def config; end
end

# Providers can prepare and register one or more objects and typically work with third
# party code. A typical provider might be for a database library, or an API client.
#
# The particular behavior for any provider is defined in a {Provider::Source}, which
# is a subclass created when you run {Container.register_provider} or
# {Dry::System.register_provider_source}. The Source provides this behavior through
# methods for each of the steps in the provider lifecycle: `prepare`, `start`, and
# `run`. These methods typically create and configure various objects, then register
# them with the {#provider_container}.
#
# The Provider manages this lifecycle by implementing common behavior around the
# lifecycle steps, such as running step callbacks, and only running steps when
# appropriate for the current status of the lifecycle.
#
# Providers can be registered via {Container.register_provider}.
#
# @api public
# @example Simple provider
#   class App < Dry::System::Container
#   register_provider(:logger) do
#   prepare do
#   require "logger"
#   end
#
#   start do
#   register(:logger, Logger.new($stdout))
#   end
#   end
#   end
#
#   App[:logger] # returns configured logger
# @example Using an external Provider Source
#   class App < Dry::System::Container
#   register_provider(:logger, from: :some_external_provider_source) do
#   configure do |config|
#   config.log_level = :debug
#   end
#
#   after :start do
#   register(:my_extra_logger, resolve(:logger))
#   end
#   end
#   end
#
#   App[:my_extra_logger] # returns the extra logger registered in the callback
#
# source://dry-system//lib/dry/system/provider.rb#54
class Dry::System::Provider
  # @api private
  # @return [Provider] a new instance of Provider
  #
  # source://dry-system//lib/dry/system/provider.rb#130
  def initialize(name:, target_container:, source_class:, namespace: T.unsafe(nil), &block); end

  # Returns the container for the provider.
  #
  # This is where the provider's source will register its components, which are then
  # later marged into the target container after the `prepare` and `start` lifecycle
  # steps.
  #
  # @api public
  # @return [Dry::Container]
  #
  # source://dry-system//lib/dry/system/provider.rb#96
  def container; end

  # Returns the provider's unique name.
  #
  # @api public
  # @return [Symbol]
  #
  # source://dry-system//lib/dry/system/provider.rb#60
  def name; end

  # Returns the default namespace for the provider's container keys.
  #
  # @api public
  # @return [Symbol, String]
  #
  # source://dry-system//lib/dry/system/provider.rb#67
  def namespace; end

  # Runs the `prepare` lifecycle step.
  #
  # Also runs any callbacks for the step, and then merges any registered components
  # from the provider container into the target container.
  #
  # @api public
  # @return [self]
  #
  # source://dry-system//lib/dry/system/provider.rb#154
  def prepare; end

  # Returns true if the provider's `prepare` lifecycle step has run
  #
  # @api public
  # @return [Boolean]
  #
  # source://dry-system//lib/dry/system/provider.rb#187
  def prepared?; end

  # Returns the container for the provider.
  #
  # This is where the provider's source will register its components, which are then
  # later marged into the target container after the `prepare` and `start` lifecycle
  # steps.
  #
  # @api public
  # @return [Dry::Container]
  #
  # source://dry-system//lib/dry/system/provider.rb#96
  def provider_container; end

  # Returns the provider's source
  #
  # The source provides the specific behavior for the provider via methods
  # implementing the lifecycle steps.
  #
  # The provider's source is defined when registering a provider with the container,
  # or an external provider source.
  #
  # @api private
  # @return [Dry::System::Provider::Source]
  # @see Dry::System::Container.register_provider
  # @see Dry::System.register_provider_source
  #
  # source://dry-system//lib/dry/system/provider.rb#127
  def source; end

  # Runs the `start` lifecycle step.
  #
  # Also runs any callbacks for the step, and then merges any registered components
  # from the provider container into the target container.
  #
  # @api public
  # @return [self]
  #
  # source://dry-system//lib/dry/system/provider.rb#166
  def start; end

  # Returns true if the provider's `start` lifecycle step has run
  #
  # @api public
  # @return [Boolean]
  #
  # source://dry-system//lib/dry/system/provider.rb#194
  def started?; end

  # Returns an array of lifecycle steps that have been run.
  #
  # @api public
  # @example
  #   provider.statuses # => [:prepare, :start]
  # @return [Array<Symbol>]
  #
  # source://dry-system//lib/dry/system/provider.rb#77
  def statuses; end

  # Runs the `stop` lifecycle step.
  #
  # Also runs any callbacks for the step.
  #
  # @api public
  # @return [self]
  #
  # source://dry-system//lib/dry/system/provider.rb#178
  def stop; end

  # Returns true if the provider's `stop` lifecycle step has run
  #
  # @api public
  # @return [Boolean]
  #
  # source://dry-system//lib/dry/system/provider.rb#201
  def stopped?; end

  # Returns the target container for the provider.
  #
  # This is the container with which the provider is registered (via
  # {Dry::System::Container.register_provider}).
  #
  # Registered components from the provider's container will be merged into this
  # container after the `prepare` and `start` lifecycle steps.
  #
  # @api public
  # @return [Dry::System::Container]
  #
  # source://dry-system//lib/dry/system/provider.rb#110
  def target; end

  # Returns the target container for the provider.
  #
  # This is the container with which the provider is registered (via
  # {Dry::System::Container.register_provider}).
  #
  # Registered components from the provider's container will be merged into this
  # container after the `prepare` and `start` lifecycle steps.
  #
  # @api public
  # @return [Dry::System::Container]
  #
  # source://dry-system//lib/dry/system/provider.rb#110
  def target_container; end

  private

  # Registers any components from the provider's container in the main container.
  #
  # Called after each lifecycle step runs.
  #
  # @api private
  # @return [self]
  #
  # source://dry-system//lib/dry/system/provider.rb#266
  def apply; end

  # @api private
  #
  # source://dry-system//lib/dry/system/provider.rb#208
  def build_provider_container; end

  # @api private
  #
  # source://dry-system//lib/dry/system/provider.rb#225
  def run_step(step_name); end

  # Returns the name of the currently running step, if any.
  #
  # @api private
  # @return [Symbol, nil]
  #
  # source://dry-system//lib/dry/system/provider.rb#84
  def step_running; end

  # Returns true if a step is currenly running.
  #
  # This is important for short-circuiting the invocation of {#run_step} and avoiding
  # infinite loops if a provider step happens to result in resolution of a component
  # with the same root key as the provider's own name (which ordinarily results in
  # that provider being started).
  #
  # @api private
  # @return [Boolean]
  # @see {#run_step}
  #
  # source://dry-system//lib/dry/system/provider.rb#255
  def step_running?; end
end

# A provider's source provides the specific behavior for a given provider to serve
# its purpose.
#
# Sources should be subclasses of `Dry::System::Source::Provider`, with instance
# methods for each lifecycle step providing their behavior: {#prepare}, {#start},
# and {#stop}.
#
# Inside each of these methods, you should create and configure your provider's
# objects as required, and then {#register} them with the {#provider_container}.
# When the provider's lifecycle steps are run (via {Dry::System::Provider}), these
# registered components will be merged into the target container.
#
# You can prepare a provider's source in two ways:
#
# 1. Passing a bock when registering the provider, which is then evaluated via
#    {Dry::System::Provider::SourceDSL} to prepare the provider subclass. This
#    approach is easiest for simple providers.
# 2. Manually creare your own subclass of {Dry::System::Provider} and implement your
#    own instance methods for the lifecycle steps (you should not implement your own
#    `#initialize`). This approach may be useful for more complex providers.
#
# @api public
# @see Dry::System::Container.register_provider
# @see Dry::System.register_provider_source
# @see Dry::System::Source::ProviderDSL
#
# source://dry-system//lib/dry/system/provider/source.rb#32
class Dry::System::Provider::Source
  extend ::Dry::Core::Constants
  extend ::Dry::Core::ClassAttributes

  # @api private
  # @return [Source] a new instance of Source
  #
  # source://dry-system//lib/dry/system/provider/source.rb#123
  def initialize(provider_container:, target_container:, &block); end

  # Registers an "after" callback for the given lifecycle step.
  #
  # The given block will be run after the lifecycle step method is run. The block
  # will be evaluated in the context of the instance of this source.
  #
  # @api public
  # @param step_name [Symbol]
  # @param block [Proc] the callback block
  # @return [self]
  # @see #before
  #
  # source://dry-system//lib/dry/system/provider/source.rb#243
  def after(step_name, &block); end

  # Registers a "before" callback for the given lifecycle step.
  #
  # The given block will be run before the lifecycle step method is run. The block
  # will be evaluated in the context of the instance of this source.
  #
  # @api public
  # @param step_name [Symbol]
  # @param block [Proc] the callback block
  # @return [self]
  # @see #after
  #
  # source://dry-system//lib/dry/system/provider/source.rb#214
  def before(step_name, &block); end

  # @api private
  #
  # source://dry-system//lib/dry/system/provider/source.rb#87
  def callbacks; end

  # Returns the provider's own container for the provider.
  #
  # This container is namespaced based on the provider's `namespace:` configuration.
  #
  # Registered components in this container will be merged into the target container
  # after the `prepare` and `start` lifecycle steps.
  #
  # @api public
  # @return [Dry::Container]
  # @see #target_container
  # @see Dry::System::Provider
  #
  # source://dry-system//lib/dry/system/provider/source.rb#102
  def container; end

  # Returns a string containing a human-readable representation of the provider.
  #
  # @api private
  # @return [String]
  #
  # source://dry-system//lib/dry/system/provider/source.rb#136
  def inspect; end

  # Runs the behavior for the "prepare" lifecycle step.
  #
  # This should be implemented by your source subclass or specified by
  # `SourceDSL#prepare` when registering a provider using a block.
  #
  # @api public
  # @return [void]
  # @see SourceDSL#prepare
  #
  # source://dry-system//lib/dry/system/provider/source.rb#154
  def prepare; end

  # Returns the provider's own container for the provider.
  #
  # This container is namespaced based on the provider's `namespace:` configuration.
  #
  # Registered components in this container will be merged into the target container
  # after the `prepare` and `start` lifecycle steps.
  #
  # @api public
  # @return [Dry::Container]
  # @see #target_container
  # @see Dry::System::Provider
  #
  # source://dry-system//lib/dry/system/provider/source.rb#102
  def provider_container; end

  # @api private
  #
  # source://dry-system//lib/dry/system/provider/source.rb#260
  def run_callback(hook, step); end

  # Runs the behavior for the "start" lifecycle step.
  #
  # This should be implemented by your source subclass or specified by
  # `SourceDSL#start` when registering a provider using a block.
  #
  # You can presume that {#prepare} has already run by the time this method is
  # called.
  #
  # @api public
  # @return [void]
  # @see SourceDSL#start
  #
  # source://dry-system//lib/dry/system/provider/source.rb#169
  def start; end

  # Runs the behavior for the "stop" lifecycle step.
  #
  # This should be implemented by your source subclass or specified by
  # `SourceDSL#stop` when registering a provider using a block.
  #
  # You can presume that {#prepare} and {#start} have already run by the time this
  # method is called.
  #
  # @api public
  # @return [void]
  # @see SourceDSL#stop
  #
  # source://dry-system//lib/dry/system/provider/source.rb#184
  def stop; end

  # Returns the target container for the provider.
  #
  # This is the container with which the provider is registered (via
  # {Dry::System::Container.register_provider}).
  #
  # Registered components from the provider's container will be merged into this
  # container after the `prepare` and `start` lifecycle steps.
  #
  # @api public
  # @return [Dry::System::Container]
  # @see #provider_container
  # @see Dry::System::Provider
  #
  # source://dry-system//lib/dry/system/provider/source.rb#119
  def target; end

  # Returns the target container for the provider.
  #
  # This is the container with which the provider is registered (via
  # {Dry::System::Container.register_provider}).
  #
  # Registered components from the provider's container will be merged into this
  # container after the `prepare` and `start` lifecycle steps.
  #
  # @api public
  # @return [Dry::System::Container]
  # @see #provider_container
  # @see Dry::System::Provider
  #
  # source://dry-system//lib/dry/system/provider/source.rb#119
  def target_container; end

  # @api public
  #
  # source://dry-system//lib/dry/system/provider/source.rb#186
  def use(*provider_names); end

  private

  # @api private
  #
  # source://dry-system//lib/dry/system/provider/source.rb#309
  def method_missing(name, *args, &block); end

  # Registers a component in the provider container.
  #
  # When the provider's lifecycle steps are run (via {Dry::System::Provider}), these
  # registered components will be merged into the target container.
  #
  # @api public
  # @return [Dry::Container] the provider container
  #
  # source://dry-system//lib/dry/system/provider/source.rb#287
  def register(*_arg0, **_arg1, &_arg2); end

  # Resolves a previously registered component from the provider container.
  #
  # @api public
  # @param key [String] the key for the component to resolve
  # @return [Object] the previously registered component
  #
  # source://dry-system//lib/dry/system/provider/source.rb#298
  def resolve(key); end

  # @api private
  # @return [Boolean]
  #
  # source://dry-system//lib/dry/system/provider/source.rb#318
  def respond_to_missing?(name, include_all = T.unsafe(nil)); end

  # @api private
  #
  # source://dry-system//lib/dry/system/provider/source.rb#303
  def run_step_block(step_name); end

  class << self
    # Returns a new Dry::System::Provider::Source subclass with its behavior supplied by the
    # given block, which is evaluated using Dry::System::Provider::SourceDSL.
    #
    # @api private
    # @see Dry::System::Provider::SourceDSL
    #
    # source://dry-system//lib/dry/system/provider/source.rb#40
    def for(name:, target_container:, group: T.unsafe(nil), &block); end

    # @api public
    # @private
    #
    # source://dry-system//lib/dry/system/provider/source.rb#48
    def inherited(subclass); end

    # @api private
    #
    # source://dry-system//lib/dry/system/provider/source.rb#75
    def inspect; end

    # @api private
    #
    # source://dry-system//lib/dry/system/provider/source.rb#62
    def name; end

    # @api private
    #
    # source://dry-system//lib/dry/system/provider/source.rb#70
    def to_s; end
  end
end

# @api public
#
# source://dry-system//lib/dry/system/provider/source.rb#80
Dry::System::Provider::Source::CALLBACK_MAP = T.let(T.unsafe(nil), Hash)

# Configures a Dry::System::Provider::Source subclass using a DSL that makes it
# nicer to define source behaviour via a single block.
#
# @api private
# @see Dry::System::Container.register_provider
#
# source://dry-system//lib/dry/system/provider/source_dsl.rb#12
class Dry::System::Provider::SourceDSL
  extend ::Dry::Core::Deprecations::Interface

  # @api private
  # @return [SourceDSL] a new instance of SourceDSL
  #
  # source://dry-system//lib/dry/system/provider/source_dsl.rb#30
  def initialize(source_class); end

  # source://dry-core/0.9.1/lib/dry/core/deprecations.rb#168
  def init(*args, &block); end

  # @api private
  #
  # source://dry-system//lib/dry/system/provider/source_dsl.rb#63
  def prepare(&block); end

  # @api private
  #
  # source://dry-system//lib/dry/system/provider/source_dsl.rb#34
  def setting(*_arg0, **_arg1, &_arg2); end

  # @api private
  #
  # source://dry-system//lib/dry/system/provider/source_dsl.rb#40
  def settings(&block); end

  # @api private
  #
  # source://dry-system//lib/dry/system/provider/source_dsl.rb#28
  def source_class; end

  # @api private
  #
  # source://dry-system//lib/dry/system/provider/source_dsl.rb#68
  def start(&block); end

  # @api private
  #
  # source://dry-system//lib/dry/system/provider/source_dsl.rb#72
  def stop(&block); end

  private

  # @api private
  #
  # source://dry-system//lib/dry/system/provider/source_dsl.rb#78
  def method_missing(name, *args, &block); end

  # @api private
  # @return [Boolean]
  #
  # source://dry-system//lib/dry/system/provider/source_dsl.rb#86
  def respond_to_missing?(name, include_all = T.unsafe(nil)); end

  class << self
    # @api private
    #
    # source://dry-system//lib/dry/system/provider/source_dsl.rb#15
    def evaluate(source_class, target_container, &block); end
  end
end

# @api private
#
# source://dry-system//lib/dry/system/provider/source_dsl.rb#53
class Dry::System::Provider::SourceDSL::DeprecatedSettingsDSL
  # @api private
  # @return [DeprecatedSettingsDSL] a new instance of DeprecatedSettingsDSL
  #
  # source://dry-system//lib/dry/system/provider/source_dsl.rb#54
  def initialize(base_dsl); end

  # @api private
  #
  # source://dry-system//lib/dry/system/provider/source_dsl.rb#58
  def key(name, type); end
end

# Error raised when attempting to register provider using a name that has already been
# registered
#
# @api public
#
# source://dry-system//lib/dry/system/errors.rb#41
class Dry::System::ProviderAlreadyRegisteredError < ::ArgumentError
  # source://dry-system//lib/dry/system/errors.rb#42
  def initialize(provider_name); end
end

# Error raised when a named provider could not be found
#
# @api public
#
# source://dry-system//lib/dry/system/errors.rb#52
class Dry::System::ProviderNotFoundError < ::ArgumentError
  # source://dry-system//lib/dry/system/errors.rb#53
  def initialize(name); end
end

# Default provider registrar implementation
#
# This is currently configured by default for every Dry::System::Container. The
# provider registrar is responsible for loading provider files and exposing an API for
# running the provider lifecycle steps.
#
# @api private
#
# source://dry-system//lib/dry/system/provider_registrar.rb#17
class Dry::System::ProviderRegistrar
  extend ::Dry::Core::Deprecations::Interface

  # @api private
  # @return [ProviderRegistrar] a new instance of ProviderRegistrar
  #
  # source://dry-system//lib/dry/system/provider_registrar.rb#27
  def initialize(container); end

  # Returns a provider for the given name, if it has already been loaded
  #
  # @api public
  #
  # source://dry-system//lib/dry/system/provider_registrar.rb#78
  def [](provider_name); end

  # source://dry-core/0.9.1/lib/dry/core/deprecations.rb#168
  def boot_files(*args, &block); end

  # @api private
  #
  # source://dry-system//lib/dry/system/provider_registrar.rb#24
  def container; end

  # @api private
  #
  # source://dry-system//lib/dry/system/provider_registrar.rb#144
  def finalize!; end

  # @api private
  def finalized?; end

  # Returns a provider if it can be found or loaded, otherwise nil
  #
  # @api private
  # @return [Dry::System::Provider, nil]
  #
  # source://dry-system//lib/dry/system/provider_registrar.rb#93
  def find_and_load_provider(name); end

  # @api private
  #
  # source://dry-system//lib/dry/system/provider_registrar.rb#33
  def freeze; end

  # @api private
  # @return [Boolean]
  #
  # source://dry-system//lib/dry/system/provider_registrar.rb#84
  def key?(provider_name); end

  # @api private
  #
  # source://dry-system//lib/dry/system/provider_registrar.rb#168
  def prepare(provider_name); end

  # Returns a provider for the given name, if it has already been loaded
  #
  # @api public
  #
  # source://dry-system//lib/dry/system/provider_registrar.rb#78
  def provider(provider_name); end

  # Returns all provider files within the configured provider_paths.
  #
  # Searches for files in the order of the configured provider_paths. In the case of multiple
  # identically-named boot files within different provider_paths, the file found first will be
  # returned, and other matching files will be discarded.
  #
  # This method is public to allow other tools extending dry-system (like dry-rails)
  # to access a canonical list of real, in-use provider files.
  #
  # @api public
  # @return [Array<Pathname>]
  # @see Container.provider_paths
  #
  # source://dry-system//lib/dry/system/provider_registrar.rb#127
  def provider_files; end

  # @api private
  #
  # source://dry-system//lib/dry/system/provider_registrar.rb#21
  def providers; end

  # @api private
  # @raise [ProviderAlreadyRegisteredError]
  # @see Container.register_provider
  #
  # source://dry-system//lib/dry/system/provider_registrar.rb#42
  def register_provider(name, namespace: T.unsafe(nil), from: T.unsafe(nil), source: T.unsafe(nil), if: T.unsafe(nil), &block); end

  # @api private
  #
  # source://dry-system//lib/dry/system/provider_registrar.rb#162
  def shutdown; end

  # @api private
  #
  # source://dry-system//lib/dry/system/provider_registrar.rb#174
  def start(provider_name); end

  # @api private
  #
  # source://dry-system//lib/dry/system/provider_registrar.rb#108
  def start_provider_dependency(component); end

  # @api private
  #
  # source://dry-system//lib/dry/system/provider_registrar.rb#180
  def stop(provider_name); end

  private

  # @api private
  #
  # source://dry-system//lib/dry/system/provider_registrar.rb#218
  def build_provider(name, namespace:, source: T.unsafe(nil), &block); end

  # @api private
  #
  # source://dry-system//lib/dry/system/provider_registrar.rb#233
  def build_provider_from_source(name, source:, group:, namespace:, &block); end

  # @api private
  #
  # source://dry-system//lib/dry/system/provider_registrar.rb#269
  def find_provider_file(name); end

  # @api private
  #
  # source://dry-system//lib/dry/system/provider_registrar.rb#255
  def load_provider(path); end

  # @api private
  #
  # source://dry-system//lib/dry/system/provider_registrar.rb#189
  def provider_paths; end

  # @api private
  #
  # source://dry-system//lib/dry/system/provider_registrar.rb#263
  def require_provider_file(name); end

  # @api private
  # @raise [ProviderNotFoundError]
  # @yield [provider]
  #
  # source://dry-system//lib/dry/system/provider_registrar.rb#245
  def with_provider(provider_name); end
end

# Error raised when a named provider source could not be found
#
# @api public
#
# source://dry-system//lib/dry/system/errors.rb#63
class Dry::System::ProviderSourceNotFoundError < ::StandardError
  # source://dry-system//lib/dry/system/errors.rb#64
  def initialize(name:, group:, keys:); end
end

# @api private
#
# source://dry-system//lib/dry/system/provider_source_registry.rb#8
class Dry::System::ProviderSourceRegistry
  # @api private
  # @return [ProviderSourceRegistry] a new instance of ProviderSourceRegistry
  #
  # source://dry-system//lib/dry/system/provider_source_registry.rb#11
  def initialize; end

  # @api private
  #
  # source://dry-system//lib/dry/system/provider_source_registry.rb#15
  def load_sources(path); end

  # @api private
  #
  # source://dry-system//lib/dry/system/provider_source_registry.rb#21
  def register(name:, group:, source:); end

  # @api private
  #
  # source://dry-system//lib/dry/system/provider_source_registry.rb#25
  def register_from_block(name:, group:, target_container:, &block); end

  # @api private
  #
  # source://dry-system//lib/dry/system/provider_source_registry.rb#38
  def resolve(name:, group:); end

  # @api private
  #
  # source://dry-system//lib/dry/system/provider_source_registry.rb#9
  def sources; end

  private

  # @api private
  #
  # source://dry-system//lib/dry/system/provider_source_registry.rb#63
  def key(name, group); end
end

# source://dry-system//lib/dry/system/provider_sources/settings.rb#5
module Dry::System::ProviderSources; end

# @api private
#
# source://dry-system//lib/dry/system/provider_sources/settings.rb#6
module Dry::System::ProviderSources::Settings; end

# @api private
#
# source://dry-system//lib/dry/system/provider_sources/settings/config.rb#28
class Dry::System::ProviderSources::Settings::Config
  include ::Dry::Configurable::Initializer
  include ::Dry::Core::Constants
  include ::Dry::Configurable
  include ::Dry::Configurable::Methods
  include ::Dry::Configurable::InstanceMethods
  extend ::Dry::Configurable::Methods
  extend ::Dry::Configurable::ClassMethods

  private

  # @api private
  #
  # source://dry-system//lib/dry/system/provider_sources/settings/config.rb#67
  def method_missing(name, *args, &block); end

  # @api private
  # @return [Boolean]
  #
  # source://dry-system//lib/dry/system/provider_sources/settings/config.rb#75
  def respond_to_missing?(name, include_all = T.unsafe(nil)); end

  class << self
    # @api private
    #
    # source://dry-system//lib/dry/system/provider_sources/settings/config.rb#51
    def key(name, type); end

    # @api private
    #
    # source://dry-system//lib/dry/system/provider_sources/settings/config.rb#30
    def load(root:, env:, loader: T.unsafe(nil)); end
  end
end

# @api private
#
# source://dry-system//lib/dry/system/provider_sources/settings/config.rb#8
class Dry::System::ProviderSources::Settings::InvalidSettingsError < ::ArgumentError
  # source://dry-system//lib/dry/system/provider_sources/settings/config.rb#10
  def initialize(errors); end

  private

  # source://dry-system//lib/dry/system/provider_sources/settings/config.rb#22
  def setting_errors(errors); end
end

# @api private
#
# source://dry-system//lib/dry/system/provider_sources/settings/loader.rb#8
class Dry::System::ProviderSources::Settings::Loader
  # @api private
  # @return [Loader] a new instance of Loader
  #
  # source://dry-system//lib/dry/system/provider_sources/settings/loader.rb#13
  def initialize(root:, env:, store: T.unsafe(nil)); end

  # @api private
  #
  # source://dry-system//lib/dry/system/provider_sources/settings/loader.rb#19
  def [](key); end

  # @api private
  #
  # source://dry-system//lib/dry/system/provider_sources/settings/loader.rb#10
  def store; end

  private

  # @api private
  #
  # source://dry-system//lib/dry/system/provider_sources/settings/loader.rb#38
  def dotenv_files(root, env); end

  # @api private
  #
  # source://dry-system//lib/dry/system/provider_sources/settings/loader.rb#25
  def load_dotenv(root, env); end
end

# @api private
#
# source://dry-system//lib/dry/system/provider_sources/settings.rb#7
class Dry::System::ProviderSources::Settings::Source < ::Dry::System::Provider::Source
  include ::Dry::Configurable::Initializer
  include ::Dry::Core::Constants
  include ::Dry::Configurable
  include ::Dry::Configurable::Methods
  include ::Dry::Configurable::InstanceMethods
  extend ::Dry::Configurable::Methods
  extend ::Dry::Configurable::ClassMethods

  # @api private
  #
  # source://dry-system//lib/dry/system/provider_sources/settings.rb#10
  def prepare; end

  # @api private
  #
  # source://dry-system//lib/dry/system/provider_sources/settings.rb#18
  def settings(&block); end

  # @api private
  #
  # source://dry-system//lib/dry/system/provider_sources/settings.rb#14
  def start; end
end

# source://dry-system//lib/dry/system/constants.rb#7
Dry::System::RB_EXT = T.let(T.unsafe(nil), String)

# source://dry-system//lib/dry/system/constants.rb#8
Dry::System::RB_GLOB = T.let(T.unsafe(nil), String)

# source://dry-core/0.9.1/lib/dry/core/constants.rb#112
Dry::System::Self = T.let(T.unsafe(nil), Proc)

# source://dry-core/0.9.1/lib/dry/core/constants.rb#112
Dry::System::Undefined = T.let(T.unsafe(nil), Object)

# source://dry-system//lib/dry/system/constants.rb#11
Dry::System::WORD_REGEX = T.let(T.unsafe(nil), Regexp)
