# typed: true

# DO NOT EDIT MANUALLY
# This is an autogenerated file for types exported from the `googleauth` gem.
# Please instead update this file by running `bin/tapioca gem googleauth`.

module Google; end

# Module Auth provides classes that provide Google-specific authorization
# used to access Google APIs.
module Google::Auth
  private

  # Obtains the default credentials implementation to use in this
  # environment.
  #
  # Use this to obtain the Application Default Credentials for accessing
  # Google APIs.  Application Default Credentials are described in detail
  # at https://cloud.google.com/docs/authentication/production.
  #
  # If supplied, scope is used to create the credentials instance, when it can
  # be applied.  E.g, on google compute engine and for user credentials the
  # scope is ignored.
  #
  # @param scope [string|array|nil] the scope(s) to access
  # @param options [Hash] Connection options. These may be used to configure
  #   the `Faraday::Connection` used for outgoing HTTP requests. For
  #   example, if a connection proxy must be used in the current network,
  #   you may provide a connection with with the needed proxy options.
  #   The following keys are recognized:
  #   * `:default_connection` The connection object to use for token
  #   refresh requests.
  #   * `:connection_builder` A `Proc` that creates and returns a
  #   connection to use for token refresh requests.
  #   * `:connection` The connection to use to determine whether GCE
  #   metadata credentials are available.
  def get_application_default(scope = T.unsafe(nil), options = T.unsafe(nil)); end

  class << self
    # Obtains the default credentials implementation to use in this
    # environment.
    #
    # Use this to obtain the Application Default Credentials for accessing
    # Google APIs.  Application Default Credentials are described in detail
    # at https://cloud.google.com/docs/authentication/production.
    #
    # If supplied, scope is used to create the credentials instance, when it can
    # be applied.  E.g, on google compute engine and for user credentials the
    # scope is ignored.
    #
    # @param scope [string|array|nil] the scope(s) to access
    # @param options [Hash] Connection options. These may be used to configure
    #   the `Faraday::Connection` used for outgoing HTTP requests. For
    #   example, if a connection proxy must be used in the current network,
    #   you may provide a connection with with the needed proxy options.
    #   The following keys are recognized:
    #   * `:default_connection` The connection object to use for token
    #   refresh requests.
    #   * `:connection_builder` A `Proc` that creates and returns a
    #   connection to use for token refresh requests.
    #   * `:connection` The connection to use to determine whether GCE
    #   metadata credentials are available.
    def get_application_default(scope = T.unsafe(nil), options = T.unsafe(nil)); end
  end
end

# Representation of an application's identity for user authorization
# flows.
class Google::Auth::ClientId
  # Initialize the Client ID
  #
  # @note Direction instantion is discouraged to avoid embedding IDs
  #   & secrets in source. See {#from_file} to load from
  #   `client_secrets.json` files.
  # @param id [String] Text identifier of the client ID
  # @param secret [String] Secret associated with the client ID
  # @return [ClientId] a new instance of ClientId
  def initialize(id, secret); end

  # Text identifier of the client ID
  #
  # @return [String]
  def id; end

  # Secret associated with the client ID
  #
  # @return [String]
  def secret; end

  class << self
    # Returns the value of attribute default.
    def default; end

    # Sets the attribute default
    #
    # @param value the value to set the attribute default to.
    def default=(_arg0); end

    # Constructs a Client ID from a JSON file downloaded from the
    # Google Developers Console.
    #
    # @param file [String, File] Path of file to read from
    # @return [Google::Auth::ClientID]
    def from_file(file); end

    # Constructs a Client ID from a previously loaded JSON file. The hash
    # structure should
    # match the expected JSON format.
    #
    # @param config [hash] Parsed contents of the JSON file
    # @raise [MISSING_TOP_LEVEL_ELEMENT_ERROR]
    # @return [Google::Auth::ClientID]
    def from_hash(config); end
  end
end

Google::Auth::ClientId::CLIENT_ID = T.let(T.unsafe(nil), String)
Google::Auth::ClientId::CLIENT_SECRET = T.let(T.unsafe(nil), String)
Google::Auth::ClientId::INSTALLED_APP = T.let(T.unsafe(nil), String)
Google::Auth::ClientId::MISSING_TOP_LEVEL_ELEMENT_ERROR = T.let(T.unsafe(nil), String)
Google::Auth::ClientId::WEB_APP = T.let(T.unsafe(nil), String)

# Credentials is a high-level base class used by Google's API client
# libraries to represent the authentication when connecting to an API.
# In most cases, it is subclassed by API-specific credential classes that
# can be instantiated by clients.
#
# ## Options
#
# Credentials classes are configured with options that dictate default
# values for parameters such as scope and audience. These defaults are
# expressed as class attributes, and may differ from endpoint to endpoint.
# Normally, an API client will provide subclasses specific to each
# endpoint, configured with appropriate values.
#
# Note that these options inherit up the class hierarchy. If a particular
# options is not set for a subclass, its superclass is queried.
#
# Some older users of this class set options via constants. This usage is
# deprecated. For example, instead of setting the `AUDIENCE` constant on
# your subclass, call the `audience=` method.
#
# ## Example
#
#     class MyCredentials < Google::Auth::Credentials
#       # Set the default scope for these credentials
#       self.scope = "http://example.com/my_scope"
#     end
#
#     # creds is a credentials object suitable for Google API clients
#     creds = MyCredentials.default
#     creds.scope  # => ["http://example.com/my_scope"]
#
#     class SubCredentials < MyCredentials
#       # Override the default scope for this subclass
#       self.scope = "http://example.com/sub_scope"
#     end
#
#     creds2 = SubCredentials.default
#     creds2.scope  # => ["http://example.com/sub_scope"]
class Google::Auth::Credentials
  extend ::Forwardable

  # Creates a new Credentials instance with the provided auth credentials, and with the default
  # values configured on the class.
  #
  # @param keyfile [String, Hash, Signet::OAuth2::Client] The keyfile can be provided as one of the following:
  #
  #   * The path to a JSON keyfile (as a +String+)
  #   * The contents of a JSON keyfile (as a +Hash+)
  #   * A +Signet::OAuth2::Client+ object
  # @param options [Hash] The options for configuring the credentials instance. The following is supported:
  #
  #   * +:scope+ - the scope for the client
  #   * +"project_id"+ (and optionally +"project"+) - the project identifier for the client
  #   * +:connection_builder+ - the connection builder to use for the client
  #   * +:default_connection+ - the default connection to use for the client
  # @return [Credentials] a new instance of Credentials
  def initialize(keyfile, options = T.unsafe(nil)); end

  # @return [String] The target audience ID when issuing assertions. Used only by the
  #   assertion grant type.
  def audience(*args, &block); end

  # The Signet::OAuth2::Client object the Credentials instance is using.
  #
  # @return [Signet::OAuth2::Client]
  def client; end

  # The Signet::OAuth2::Client object the Credentials instance is using.
  #
  # @return [Signet::OAuth2::Client]
  def client=(_arg0); end

  # @return [String] The issuer ID associated with this client.
  def issuer(*args, &block); end

  # Identifier for the project the client is authenticating with.
  #
  # @return [String]
  def project_id; end

  # Identifier for a separate project used for billing/quota, if any.
  #
  # @return [String, nil]
  def quota_project_id; end

  # @return [String, Array<String>] The scope for this client. A scope is an access range
  #   defined by the authorization server. The scope can be a single value or a list of values.
  def scope(*args, &block); end

  # @return [String, OpenSSL::PKey] The signing key associated with this client.
  def signing_key(*args, &block); end

  # @return [String] The final target audience for ID tokens returned by this credential.
  def target_audience(*args, &block); end

  # @return [String] The token credential URI. The URI is the authorization server's HTTP
  #   endpoint capable of issuing tokens and refreshing expired tokens.
  def token_credential_uri(*args, &block); end

  # @return [Proc] Returns a reference to the {Signet::OAuth2::Client#apply} method,
  #   suitable for passing as a closure.
  def updater_proc(*args, &block); end

  protected

  def client_options(options); end

  # Initializes the Signet client.
  def init_client(keyfile, connection_options = T.unsafe(nil)); end

  # returns a new Hash with string keys instead of symbol keys.
  def stringify_hash_keys(hash); end

  def update_from_filepath(path, options); end
  def update_from_hash(hash, options); end
  def update_from_signet(client); end

  # Verify that the keyfile argument is a file.
  def verify_keyfile_exists!(keyfile); end

  # Verify that the keyfile argument is provided.
  def verify_keyfile_provided!(keyfile); end

  class << self
    # The default target audience ID to be used when none is provided during initialization.
    # Used only by the assertion grant type.
    #
    # @return [String]
    def audience; end

    # Sets the default target audience ID to be used when none is provided during initialization.
    #
    # @param new_audience [String]
    def audience=(new_audience); end

    # Creates a new Credentials instance with auth credentials acquired by searching the
    # environment variables and paths configured on the class, and with the default values
    # configured on the class.
    #
    # The auth credentials are searched for in the following order:
    #
    # 1. configured environment variables (see {Credentials.env_vars})
    # 2. configured default file paths (see {Credentials.paths})
    # 3. application default (see {Google::Auth.get_application_default})
    #
    # @param options [Hash] The options for configuring the credentials instance. The following is supported:
    #
    #   * +:scope+ - the scope for the client
    #   * +"project_id"+ (and optionally +"project"+) - the project identifier for the client
    #   * +:connection_builder+ - the connection builder to use for the client
    #   * +:default_connection+ - the default connection to use for the client
    # @return [Credentials]
    def default(options = T.unsafe(nil)); end

    # The environment variables to search for credentials. Values can either be a file path to the
    # credentials file, or the JSON contents of the credentials file.
    # The env_vars will never be nil. If there are no vars, the empty array is returned.
    #
    # @return [Array<String>]
    def env_vars; end

    # Sets the environment variables to search for credentials.
    # Setting to `nil` "unsets" the value, and defaults to the superclass
    # (or to the empty array if there is no superclass).
    #
    # @param new_env_vars [String, Array<String>, nil]
    def env_vars=(new_env_vars); end

    # Internal recursive lookup for env_vars.
    #
    # @private
    def env_vars_internal; end

    # Return the given parameter value, defaulting up the class hierarchy.
    #
    # First returns the value of the instance variable, if set.
    # Next, calls the given block if provided. (This is generally used to
    # look up legacy constant-based values.)
    # Otherwise, calls the superclass method if present.
    # Returns nil if all steps fail.
    #
    # @param name [Symbol] The parameter name
    # @param method_name [Symbol] The lookup method name, if different
    # @private
    # @return [Object] The value
    def lookup_auth_param(name, method_name = T.unsafe(nil)); end

    # Return the value of the given constant if it is defined directly in
    # this class, or nil if not.
    #
    # @param Name [Symbol] of the constant
    # @private
    # @return [Object] The value
    def lookup_local_constant(name); end

    # The file paths to search for credentials files.
    # The paths will never be nil. If there are no paths, the empty array is returned.
    #
    # @return [Array<String>]
    def paths; end

    # Set the file paths to search for credentials files.
    # Setting to `nil` "unsets" the value, and defaults to the superclass
    # (or to the empty array if there is no superclass).
    #
    # @param new_paths [String, Array<String>, nil]
    def paths=(new_paths); end

    # Internal recursive lookup for paths.
    #
    # @private
    def paths_internal; end

    # The default scope to be used when none is provided during initialization.
    # A scope is an access range defined by the authorization server.
    # The scope can be a single value or a list of values.
    #
    # Either {#scope} or {#target_audience}, but not both, should be non-nil.
    # If {#scope} is set, this credential will produce access tokens.
    # If {#target_audience} is set, this credential will produce ID tokens.
    #
    # @return [String, Array<String>, nil]
    def scope; end

    # Sets the default scope to be used when none is provided during initialization.
    #
    # Either {#scope} or {#target_audience}, but not both, should be non-nil.
    # If {#scope} is set, this credential will produce access tokens.
    # If {#target_audience} is set, this credential will produce ID tokens.
    #
    # @param new_scope [String, Array<String>, nil]
    def scope=(new_scope); end

    # The default final target audience for ID tokens, to be used when none
    # is provided during initialization.
    #
    # Either {#scope} or {#target_audience}, but not both, should be non-nil.
    # If {#scope} is set, this credential will produce access tokens.
    # If {#target_audience} is set, this credential will produce ID tokens.
    #
    # @return [String, nil]
    def target_audience; end

    # Sets the default final target audience for ID tokens, to be used when none
    # is provided during initialization.
    #
    # Either {#scope} or {#target_audience}, but not both, should be non-nil.
    # If {#scope} is set, this credential will produce access tokens.
    # If {#target_audience} is set, this credential will produce ID tokens.
    #
    # @param new_target_audience [String, nil]
    def target_audience=(new_target_audience); end

    # The default token credential URI to be used when none is provided during initialization.
    # The URI is the authorization server's HTTP endpoint capable of issuing tokens and
    # refreshing expired tokens.
    #
    # @return [String]
    def token_credential_uri; end

    # Set the default token credential URI to be used when none is provided during initialization.
    #
    # @param new_token_credential_uri [String]
    def token_credential_uri=(new_token_credential_uri); end

    private

    # @private Lookup Credentials using Google::Auth.get_application_default.
    def from_application_default(options); end

    # @private Lookup Credentials from default file paths.
    def from_default_paths(options); end

    # @private Lookup Credentials from environment variables.
    def from_env_vars(options); end

    # @private Read credentials from a JSON stream.
    def from_io(io, options); end
  end
end

# The default target audience ID to be used when none is provided during initialization.
Google::Auth::Credentials::AUDIENCE = T.let(T.unsafe(nil), String)

# The default token credential URI to be used when none is provided during initialization.
Google::Auth::Credentials::TOKEN_CREDENTIAL_URI = T.let(T.unsafe(nil), String)

# CredentialsLoader contains the behaviour used to locate and find default
# credentials files on the file system.
module Google::Auth::CredentialsLoader
  # Creates an instance from the path specified in an environment
  # variable.
  #
  # @param scope [string|array|nil] the scope(s) to access
  # @param options [Hash] Connection options. These may be used to configure
  #   how OAuth tokens are retrieved, by providing a suitable
  #   `Faraday::Connection`. For example, if a connection proxy must be
  #   used in the current network, you may provide a connection with
  #   with the needed proxy options.
  #   The following keys are recognized:
  #   * `:default_connection` The connection object to use.
  #   * `:connection_builder` A `Proc` that returns a connection.
  def from_env(scope = T.unsafe(nil), options = T.unsafe(nil)); end

  # Creates an instance from the system default path
  #
  # @param scope [string|array|nil] the scope(s) to access
  # @param options [Hash] Connection options. These may be used to configure
  #   how OAuth tokens are retrieved, by providing a suitable
  #   `Faraday::Connection`. For example, if a connection proxy must be
  #   used in the current network, you may provide a connection with
  #   with the needed proxy options.
  #   The following keys are recognized:
  #   * `:default_connection` The connection object to use.
  #   * `:connection_builder` A `Proc` that returns a connection.
  def from_system_default_path(scope = T.unsafe(nil), options = T.unsafe(nil)); end

  # Creates an instance from a well known path.
  #
  # @param scope [string|array|nil] the scope(s) to access
  # @param options [Hash] Connection options. These may be used to configure
  #   how OAuth tokens are retrieved, by providing a suitable
  #   `Faraday::Connection`. For example, if a connection proxy must be
  #   used in the current network, you may provide a connection with
  #   with the needed proxy options.
  #   The following keys are recognized:
  #   * `:default_connection` The connection object to use.
  #   * `:connection_builder` A `Proc` that returns a connection.
  def from_well_known_path(scope = T.unsafe(nil), options = T.unsafe(nil)); end

  # make_creds proxies the construction of a credentials instance
  #
  # By default, it calls #new on the current class, but this behaviour can
  # be modified, allowing different instances to be created.
  def make_creds(*args); end

  private

  def authorized_user_env_vars?; end
  def interpret_options(scope, options); end

  # Finds project_id from gcloud CLI configuration
  def load_gcloud_project_id; end

  def service_account_env_vars?; end

  # Issues warning if cloud sdk client id is used
  def warn_if_cloud_sdk_credentials(client_id); end

  class << self
    # Finds project_id from gcloud CLI configuration
    def load_gcloud_project_id; end

    # Issues warning if cloud sdk client id is used
    def warn_if_cloud_sdk_credentials(client_id); end
  end
end

Google::Auth::CredentialsLoader::ACCOUNT_TYPE_VAR = T.let(T.unsafe(nil), String)
Google::Auth::CredentialsLoader::CLIENT_EMAIL_VAR = T.let(T.unsafe(nil), String)
Google::Auth::CredentialsLoader::CLIENT_ID_VAR = T.let(T.unsafe(nil), String)
Google::Auth::CredentialsLoader::CLIENT_SECRET_VAR = T.let(T.unsafe(nil), String)
Google::Auth::CredentialsLoader::CLOUD_SDK_CLIENT_ID = T.let(T.unsafe(nil), String)
Google::Auth::CredentialsLoader::CLOUD_SDK_CREDENTIALS_WARNING = T.let(T.unsafe(nil), String)
Google::Auth::CredentialsLoader::CREDENTIALS_FILE_NAME = T.let(T.unsafe(nil), String)
Google::Auth::CredentialsLoader::ENV_VAR = T.let(T.unsafe(nil), String)
Google::Auth::CredentialsLoader::GCLOUD_CONFIG_COMMAND = T.let(T.unsafe(nil), String)
Google::Auth::CredentialsLoader::GCLOUD_POSIX_COMMAND = T.let(T.unsafe(nil), String)
Google::Auth::CredentialsLoader::GCLOUD_WINDOWS_COMMAND = T.let(T.unsafe(nil), String)
Google::Auth::CredentialsLoader::NOT_FOUND_ERROR = T.let(T.unsafe(nil), String)
Google::Auth::CredentialsLoader::PRIVATE_KEY_VAR = T.let(T.unsafe(nil), String)
Google::Auth::CredentialsLoader::PROJECT_ID_VAR = T.let(T.unsafe(nil), String)
Google::Auth::CredentialsLoader::REFRESH_TOKEN_VAR = T.let(T.unsafe(nil), String)
Google::Auth::CredentialsLoader::SYSTEM_DEFAULT_ERROR = T.let(T.unsafe(nil), String)
Google::Auth::CredentialsLoader::WELL_KNOWN_ERROR = T.let(T.unsafe(nil), String)
Google::Auth::CredentialsLoader::WELL_KNOWN_PATH = T.let(T.unsafe(nil), String)

# DefaultCredentials is used to preload the credentials file, to determine
# which type of credentials should be loaded.
class Google::Auth::DefaultCredentials
  extend ::Google::Auth::CredentialsLoader

  class << self
    # Reads the input json and determines which creds class to use.
    def determine_creds_class(json_key_io); end

    # override CredentialsLoader#make_creds to use the class determined by
    # loading the json.
    def make_creds(options = T.unsafe(nil)); end

    def read_creds; end
  end
end

# Extends Signet::OAuth2::Client so that the auth token is obtained from
# the GCE metadata server.
class Google::Auth::GCECredentials < ::Signet::OAuth2::Client
  extend ::Memoist::InstanceMethods

  # Overrides the super class method to change how access tokens are
  # fetched.
  def fetch_access_token(options = T.unsafe(nil)); end

  class << self
    def _unmemoized_on_gce?(options = T.unsafe(nil)); end
    def compute_auth_token_uri; end
    def compute_check_uri; end
    def compute_id_token_uri; end
    def metadata_host; end

    # Detect if this appear to be a GCE instance, by checking if metadata
    # is available.
    #
    # @return [Boolean]
    def on_gce?(*args); end
  end
end

# @private Unused and deprecated
Google::Auth::GCECredentials::COMPUTE_AUTH_TOKEN_URI = T.let(T.unsafe(nil), String)

# @private Unused and deprecated
Google::Auth::GCECredentials::COMPUTE_CHECK_URI = T.let(T.unsafe(nil), String)

# @private Unused and deprecated
Google::Auth::GCECredentials::COMPUTE_ID_TOKEN_URI = T.let(T.unsafe(nil), String)

# The IP Address is used in the URIs to speed up failures on non-GCE
# systems.
Google::Auth::GCECredentials::DEFAULT_METADATA_HOST = T.let(T.unsafe(nil), String)

# ## Verifying Google ID tokens
#
# This module verifies ID tokens issued by Google. This can be used to
# authenticate signed-in users using OpenID Connect. See
# https://developers.google.com/identity/sign-in/web/backend-auth for more
# information.
#
# ### Basic usage
#
# To verify an ID token issued by Google accounts:
#
#     payload = Google::Auth::IDTokens.verify_oidc the_token,
#                                                  aud: "my-app-client-id"
#
# If verification succeeds, you will receive the token's payload as a hash.
# If verification fails, an exception (normally a subclass of
# {Google::Auth::IDTokens::VerificationError}) will be raised.
#
# To verify an ID token issued by the Google identity-aware proxy (IAP):
#
#     payload = Google::Auth::IDTokens.verify_iap the_token,
#                                                 aud: "my-app-client-id"
#
# These methods will automatically download and cache the Google public
# keys necessary to verify these tokens. They will also automatically
# verify the issuer (`iss`) field for their respective types of ID tokens.
#
# ### Advanced usage
#
# If you want to provide your own public keys, either by pointing at a
# custom URI or by providing the key data directly, use the Verifier class
# and pass in a key source.
#
# To point to a custom URI that returns a JWK set:
#
#     source = Google::Auth::IDTokens::JwkHttpKeySource.new "https://example.com/jwk"
#     verifier = Google::Auth::IDTokens::Verifier.new key_source: source
#     payload = verifier.verify the_token, aud: "my-app-client-id"
#
# To provide key data directly:
#
#     jwk_data = {
#       keys: [
#         {
#           alg: "ES256",
#           crv: "P-256",
#           kid: "LYyP2g",
#           kty: "EC",
#           use: "sig",
#           x: "SlXFFkJ3JxMsXyXNrqzE3ozl_0913PmNbccLLWfeQFU",
#           y: "GLSahrZfBErmMUcHP0MGaeVnJdBwquhrhQ8eP05NfCI"
#         }
#       ]
#     }
#     source = Google::Auth::IDTokens::StaticKeySource.from_jwk_set jwk_data
#     verifier = Google::Auth::IDTokens::Verifier key_source: source
#     payload = verifier.verify the_token, aud: "my-app-client-id"
module Google::Auth::IDTokens
  class << self
    # Reset all convenience key sources. Used for testing.
    #
    # @private
    def forget_sources!; end

    # The key source providing public keys that can be used to verify
    # ID tokens issued by Google IAP.
    #
    # @return [Google::Auth::IDTokens::JwkHttpKeySource]
    def iap_key_source; end

    # The key source providing public keys that can be used to verify
    # ID tokens issued by Google OIDC.
    #
    # @return [Google::Auth::IDTokens::JwkHttpKeySource]
    def oidc_key_source; end

    # A convenience method that verifies a token allegedly issued by Google
    # IAP.
    #
    # @param token [String] The ID token to verify
    # @param aud [String, Array<String>, nil] The expected audience. At least
    #   one `aud` field in the token must match at least one of the
    #   provided audiences, or the verification will fail with
    #   {Google::Auth::IDToken::AudienceMismatchError}. If `nil` (the
    #   default), no audience checking is performed.
    # @param azp [String, Array<String>, nil] The expected authorized party
    #   (azp). At least one `azp` field in the token must match at least
    #   one of the provided values, or the verification will fail with
    #   {Google::Auth::IDToken::AuthorizedPartyMismatchError}. If `nil`
    #   (the default), no azp checking is performed.
    # @param aud [String, Array<String>, nil] The expected audience. At least
    #   one `iss` field in the token must match at least one of the
    #   provided issuers, or the verification will fail with
    #   {Google::Auth::IDToken::IssuerMismatchError}. If `nil`, no issuer
    #   checking is performed. Default is to check against {IAP_ISSUERS}.
    # @raise [KeySourceError] if the key source failed to obtain public keys
    # @raise [VerificationError] if the token verification failed.
    #   Additional data may be available in the error subclass and message.
    # @return [Hash] The decoded token payload.
    def verify_iap(token, aud: T.unsafe(nil), azp: T.unsafe(nil), iss: T.unsafe(nil)); end

    # A convenience method that verifies a token allegedly issued by Google
    # OIDC.
    #
    # @param token [String] The ID token to verify
    # @param aud [String, Array<String>, nil] The expected audience. At least
    #   one `aud` field in the token must match at least one of the
    #   provided audiences, or the verification will fail with
    #   {Google::Auth::IDToken::AudienceMismatchError}. If `nil` (the
    #   default), no audience checking is performed.
    # @param azp [String, Array<String>, nil] The expected authorized party
    #   (azp). At least one `azp` field in the token must match at least
    #   one of the provided values, or the verification will fail with
    #   {Google::Auth::IDToken::AuthorizedPartyMismatchError}. If `nil`
    #   (the default), no azp checking is performed.
    # @param aud [String, Array<String>, nil] The expected audience. At least
    #   one `iss` field in the token must match at least one of the
    #   provided issuers, or the verification will fail with
    #   {Google::Auth::IDToken::IssuerMismatchError}. If `nil`, no issuer
    #   checking is performed. Default is to check against {OIDC_ISSUERS}.
    # @raise [KeySourceError] if the key source failed to obtain public keys
    # @raise [VerificationError] if the token verification failed.
    #   Additional data may be available in the error subclass and message.
    # @return [Hash] The decoded token payload.
    def verify_oidc(token, aud: T.unsafe(nil), azp: T.unsafe(nil), iss: T.unsafe(nil)); end
  end
end

# A key source that aggregates other key sources. This means it will
# aggregate the keys provided by its constituent sources. Additionally,
# when asked to refresh, it will refresh all its constituent sources.
class Google::Auth::IDTokens::AggregateKeySource
  # Create a key source that aggregates other key sources.
  #
  # @param sources [Array<key source>] The key sources to aggregate.
  # @return [AggregateKeySource] a new instance of AggregateKeySource
  def initialize(sources); end

  # Return the current keys, without attempting to refresh.
  #
  # @return [Array<KeyInfo>]
  def current_keys; end

  # Attempt to refresh keys and return the new keys.
  #
  # @raise [KeySourceError] if key retrieval failed.
  # @return [Array<KeyInfo>]
  def refresh_keys; end
end

# Failed to verify a token because its audience did not match.
class Google::Auth::IDTokens::AudienceMismatchError < ::Google::Auth::IDTokens::VerificationError; end

# Failed to verify a token because its authorized party did not match.
class Google::Auth::IDTokens::AuthorizedPartyMismatchError < ::Google::Auth::IDTokens::VerificationError; end

# Failed to verify a token because it is expired.
class Google::Auth::IDTokens::ExpiredTokenError < ::Google::Auth::IDTokens::VerificationError; end

# A base key source that downloads keys from a URI. Subclasses should
# override {HttpKeySource#interpret_json} to parse the response.
class Google::Auth::IDTokens::HttpKeySource
  # Create an HTTP key source.
  #
  # @param uri [String, URI] The URI from which to download keys.
  # @param retry_interval [Integer, nil] Override the retry interval in
  #   seconds. This is the minimum time between retries of failed key
  #   downloads.
  # @return [HttpKeySource] a new instance of HttpKeySource
  def initialize(uri, retry_interval: T.unsafe(nil)); end

  # Return the current keys, without attempting to re-download.
  #
  # @return [Array<KeyInfo>]
  def current_keys; end

  # Attempt to re-download keys (if the retry interval has expired) and
  # return the new keys.
  #
  # @raise [KeySourceError] if key retrieval failed.
  # @return [Array<KeyInfo>]
  def refresh_keys; end

  # The URI from which to download keys.
  #
  # @return [Array<KeyInfo>]
  def uri; end

  protected

  def interpret_json(_data); end
end

# The default interval between retries in seconds (3600s = 1hr).
#
# @return [Integer]
Google::Auth::IDTokens::HttpKeySource::DEFAULT_RETRY_INTERVAL = T.let(T.unsafe(nil), Integer)

# A list of issuers expected for Google IAP-issued tokens.
#
# @return [Array<String>]
Google::Auth::IDTokens::IAP_ISSUERS = T.let(T.unsafe(nil), Array)

# The URL for Google IAP public keys
#
# @return [String]
Google::Auth::IDTokens::IAP_JWK_URL = T.let(T.unsafe(nil), String)

# Failed to verify a token because its issuer did not match.
class Google::Auth::IDTokens::IssuerMismatchError < ::Google::Auth::IDTokens::VerificationError; end

# A key source that downloads a JWK set.
class Google::Auth::IDTokens::JwkHttpKeySource < ::Google::Auth::IDTokens::HttpKeySource
  # Create a key source that downloads a JWT Set.
  #
  # @param uri [String, URI] The URI from which to download keys.
  # @param retry_interval [Integer, nil] Override the retry interval in
  #   seconds. This is the minimum time between retries of failed key
  #   downloads.
  # @return [JwkHttpKeySource] a new instance of JwkHttpKeySource
  def initialize(uri, retry_interval: T.unsafe(nil)); end

  protected

  def interpret_json(data); end
end

# A public key used for verifying ID tokens.
#
# This includes the public key data, ID, and the algorithm used for
# signature verification. RSA and Elliptical Curve (EC) keys are
# supported.
class Google::Auth::IDTokens::KeyInfo
  # Create a public key info structure.
  #
  # @param id [String] The key ID.
  # @param key [OpenSSL::PKey::RSA, OpenSSL::PKey::EC] The key itself.
  # @param algorithm [String] The algorithm (normally `RS256` or `ES256`)
  # @return [KeyInfo] a new instance of KeyInfo
  def initialize(id: T.unsafe(nil), key: T.unsafe(nil), algorithm: T.unsafe(nil)); end

  # The signature algorithm. (normally `RS256` or `ES256`)
  #
  # @return [String]
  def algorithm; end

  # The key ID.
  #
  # @return [String]
  def id; end

  # The key itself.
  #
  # @return [OpenSSL::PKey::RSA, OpenSSL::PKey::EC]
  def key; end

  class << self
    # Create a KeyInfo from a single JWK, which may be given as either a
    # hash or an unparsed JSON string.
    #
    # @param jwk [Hash, String] The JWK specification.
    # @raise [KeySourceError] If the key could not be extracted from the
    #   JWK.
    # @return [KeyInfo]
    def from_jwk(jwk); end

    # Create an array of KeyInfo from a JWK Set, which may be given as
    # either a hash or an unparsed JSON string.
    #
    # @param jwk [Hash, String] The JWK Set specification.
    # @raise [KeySourceError] If a key could not be extracted from the
    #   JWK Set.
    # @return [Array<KeyInfo>]
    def from_jwk_set(jwk_set); end

    private

    def ensure_json_parsed(input); end

    # @raise [KeySourceError]
    def extract_ec_key(jwk); end

    def extract_rsa_key(jwk); end
    def symbolize_keys(hash); end
  end
end

# Failed to obtain keys from the key source.
class Google::Auth::IDTokens::KeySourceError < ::StandardError; end

# The URL for Google OAuth2 V3 public certs
#
# @return [String]
Google::Auth::IDTokens::OAUTH2_V3_CERTS_URL = T.let(T.unsafe(nil), String)

# A list of issuers expected for Google OIDC-issued tokens.
#
# @return [Array<String>]
Google::Auth::IDTokens::OIDC_ISSUERS = T.let(T.unsafe(nil), Array)

# Failed to verify a token because its signature did not match.
class Google::Auth::IDTokens::SignatureError < ::Google::Auth::IDTokens::VerificationError; end

# A key source that contains a static set of keys.
class Google::Auth::IDTokens::StaticKeySource
  # Create a static key source with the given keys.
  #
  # @param keys [Array<KeyInfo>] The keys
  # @return [StaticKeySource] a new instance of StaticKeySource
  def initialize(keys); end

  # Return the current keys. Does not perform any refresh.
  #
  # @return [Array<KeyInfo>]
  def current_keys; end

  # Return the current keys. Does not perform any refresh.
  #
  # @return [Array<KeyInfo>]
  def refresh_keys; end

  class << self
    # Create a static key source containing a single key parsed from a
    # single JWK, which may be given as either a hash or an unparsed
    # JSON string.
    #
    # @param jwk [Hash, String] The JWK specification.
    # @return [StaticKeySource]
    def from_jwk(jwk); end

    # Create a static key source containing multiple keys parsed from a
    # JWK Set, which may be given as either a hash or an unparsed JSON
    # string.
    #
    # @param jwk_set [Hash, String] The JWK Set specification.
    # @return [StaticKeySource]
    def from_jwk_set(jwk_set); end
  end
end

# Failed to verify a token.
class Google::Auth::IDTokens::VerificationError < ::StandardError; end

# An object that can verify ID tokens.
#
# A verifier maintains a set of default settings, including the key
# source and fields to verify. However, individual verification calls can
# override any of these settings.
class Google::Auth::IDTokens::Verifier
  # Create a verifier.
  #
  # @param key_source [key source] The default key source to use. All
  #   verification calls must have a key source, so if no default key
  #   source is provided here, then calls to {#verify} _must_ provide
  #   a key source.
  # @param aud [String, nil] The default audience (`aud`) check, or `nil`
  #   for no check.
  # @param azp [String, nil] The default authorized party (`azp`) check,
  #   or `nil` for no check.
  # @param iss [String, nil] The default issuer (`iss`) check, or `nil`
  #   for no check.
  # @return [Verifier] a new instance of Verifier
  def initialize(key_source: T.unsafe(nil), aud: T.unsafe(nil), azp: T.unsafe(nil), iss: T.unsafe(nil)); end

  # Verify the given token.
  #
  # @param token [String] the ID token to verify.
  # @param key_source [key source] If given, override the key source.
  # @param aud [String, nil] If given, override the `aud` check.
  # @param azp [String, nil] If given, override the `azp` check.
  # @param iss [String, nil] If given, override the `iss` check.
  # @raise [KeySourceError] if the key source failed to obtain public keys
  # @raise [VerificationError] if the token verification failed.
  #   Additional data may be available in the error subclass and message.
  # @return [Hash] the decoded payload, if verification succeeded.
  def verify(token, key_source: T.unsafe(nil), aud: T.unsafe(nil), azp: T.unsafe(nil), iss: T.unsafe(nil)); end

  private

  def decode_token(token, keys, aud, azp, iss); end
  def normalize_and_verify_payload(payload, aud, azp, iss); end
end

# A key source that downloads X509 certificates.
# Used by the legacy OAuth V1 public certs endpoint.
class Google::Auth::IDTokens::X509CertHttpKeySource < ::Google::Auth::IDTokens::HttpKeySource
  # Create a key source that downloads X509 certificates.
  #
  # @param uri [String, URI] The URI from which to download keys.
  # @param algorithm [String] The algorithm to use for signature
  #   verification. Defaults to "`RS256`".
  # @param retry_interval [Integer, nil] Override the retry interval in
  #   seconds. This is the minimum time between retries of failed key
  #   downloads.
  # @return [X509CertHttpKeySource] a new instance of X509CertHttpKeySource
  def initialize(uri, algorithm: T.unsafe(nil), retry_interval: T.unsafe(nil)); end

  protected

  def interpret_json(data); end
end

# JsonKeyReader contains the behaviour used to read private key and
# client email fields from the service account
module Google::Auth::JsonKeyReader
  def read_json_key(json_key_io); end
end

Google::Auth::NOT_FOUND_ERROR = T.let(T.unsafe(nil), String)
Google::Auth::NO_METADATA_SERVER_ERROR = T.let(T.unsafe(nil), String)

# Small utility for normalizing scopes into canonical form
module Google::Auth::ScopeUtil
  class << self
    def as_array(scope); end
    def normalize(scope); end
  end
end

Google::Auth::ScopeUtil::ALIASES = T.let(T.unsafe(nil), Hash)

# Authenticates requests using Google's Service Account credentials via an
# OAuth access token.
#
# This class allows authorizing requests for service accounts directly
# from credentials from a json key file downloaded from the developer
# console (via 'Generate new Json Key').
#
# cf [Application Default Credentials](https://cloud.google.com/docs/authentication/production)
class Google::Auth::ServiceAccountCredentials < ::Signet::OAuth2::Client
  extend ::Google::Auth::CredentialsLoader
  extend ::Google::Auth::JsonKeyReader

  # @return [ServiceAccountCredentials] a new instance of ServiceAccountCredentials
  def initialize(options = T.unsafe(nil)); end

  # Extends the base class to use a transient
  # ServiceAccountJwtHeaderCredentials for certain cases.
  def apply!(a_hash, opts = T.unsafe(nil)); end

  # @return [Boolean]
  def enable_self_signed_jwt?; end

  # Returns the value of attribute project_id.
  def project_id; end

  # Returns the value of attribute quota_project_id.
  def quota_project_id; end

  private

  def apply_self_signed_jwt!(a_hash); end

  class << self
    # Creates a ServiceAccountCredentials.
    #
    # @param json_key_io [IO] an IO from which the JSON key can be read
    # @param scope [string|array|nil] the scope(s) to access
    # @raise [ArgumentError]
    def make_creds(options = T.unsafe(nil)); end

    # Handles certain escape sequences that sometimes appear in input.
    # Specifically, interprets the "\n" sequence for newline, and removes
    # enclosing quotes.
    def unescape(str); end
  end
end

Google::Auth::ServiceAccountCredentials::TOKEN_CRED_URI = T.let(T.unsafe(nil), String)

# Authenticates requests using Google's Service Account credentials via
# JWT Header.
#
# This class allows authorizing requests for service accounts directly
# from credentials from a json key file downloaded from the developer
# console (via 'Generate new Json Key').  It is not part of any OAuth2
# flow, rather it creates a JWT and sends that as a credential.
#
# cf [Application Default Credentials](https://cloud.google.com/docs/authentication/production)
class Google::Auth::ServiceAccountJwtHeaderCredentials
  extend ::Google::Auth::CredentialsLoader
  extend ::Google::Auth::JsonKeyReader

  # Initializes a ServiceAccountJwtHeaderCredentials.
  #
  # @param json_key_io [IO] an IO from which the JSON key can be read
  # @return [ServiceAccountJwtHeaderCredentials] a new instance of ServiceAccountJwtHeaderCredentials
  def initialize(options = T.unsafe(nil)); end

  # Returns a clone of a_hash updated with the authoriation header
  def apply(a_hash, opts = T.unsafe(nil)); end

  # Construct a jwt token if the JWT_AUD_URI key is present in the input
  # hash.
  #
  # The jwt token is used as the value of a 'Bearer '.
  def apply!(a_hash, opts = T.unsafe(nil)); end

  # Returns the value of attribute project_id.
  def project_id; end

  # Returns the value of attribute quota_project_id.
  def quota_project_id; end

  # Returns a reference to the #apply method, suitable for passing as
  # a closure
  def updater_proc; end

  protected

  # Creates a jwt uri token.
  def new_jwt_token(jwt_aud_uri = T.unsafe(nil), options = T.unsafe(nil)); end

  class << self
    # Create a ServiceAccountJwtHeaderCredentials.
    #
    # @param json_key_io [IO] an IO from which the JSON key can be read
    # @param scope [string|array|nil] the scope(s) to access
    def make_creds(options = T.unsafe(nil)); end
  end
end

Google::Auth::ServiceAccountJwtHeaderCredentials::AUTH_METADATA_KEY = T.let(T.unsafe(nil), Symbol)
Google::Auth::ServiceAccountJwtHeaderCredentials::EXPIRY = T.let(T.unsafe(nil), Integer)
Google::Auth::ServiceAccountJwtHeaderCredentials::JWT_AUD_URI_KEY = T.let(T.unsafe(nil), Symbol)
Google::Auth::ServiceAccountJwtHeaderCredentials::SIGNING_ALGORITHM = T.let(T.unsafe(nil), String)
Google::Auth::ServiceAccountJwtHeaderCredentials::TOKEN_CRED_URI = T.let(T.unsafe(nil), String)
Google::Auth::UNEXPECTED_ERROR_SUFFIX = T.let(T.unsafe(nil), String)

# Handles an interactive 3-Legged-OAuth2 (3LO) user consent authorization.
#
# Example usage for a simple command line app:
#
#     credentials = authorizer.get_credentials(user_id)
#     if credentials.nil?
#       url = authorizer.get_authorization_url(
#         base_url: OOB_URI)
#       puts "Open the following URL in the browser and enter the " +
#            "resulting code after authorization"
#       puts url
#       code = gets
#       credentials = authorizer.get_and_store_credentials_from_code(
#         user_id: user_id, code: code, base_url: OOB_URI)
#     end
#     # Credentials ready to use, call APIs
#     ...
class Google::Auth::UserAuthorizer
  # Initialize the authorizer
  #
  # @param client_id [Google::Auth::ClientID] Configured ID & secret for this application
  # @param scope [String, Array<String>] Authorization scope to request
  # @param token_store [Google::Auth::Stores::TokenStore] Backing storage for persisting user credentials
  # @param callback_uri [String] URL (either absolute or relative) of the auth callback.
  #   Defaults to '/oauth2callback'
  # @raise [NIL_CLIENT_ID_ERROR]
  # @return [UserAuthorizer] a new instance of UserAuthorizer
  def initialize(client_id, scope, token_store, callback_uri = T.unsafe(nil)); end

  # Exchanges an authorization code returned in the oauth callback.
  # Additionally, stores the resulting credentials in the token store if
  # the exchange is successful.
  #
  # @param user_id [String] Unique ID of the user for loading/storing credentials.
  # @param code [String] The authorization code from the OAuth callback
  # @param scope [String, Array<String>] Authorization scope requested. Overrides the instance
  #   scopes if not nil.
  # @param base_url [String] Absolute URL to resolve the configured callback uri against.
  #   Required if the configured
  #   callback uri is a relative.
  # @return [Google::Auth::UserRefreshCredentials] Credentials if exchange is successful
  def get_and_store_credentials_from_code(options = T.unsafe(nil)); end

  # Build the URL for requesting authorization.
  #
  # @param login_hint [String] Login hint if need to authorize a specific account. Should be a
  #   user's email address or unique profile ID.
  # @param state [String] Opaque state value to be returned to the oauth callback.
  # @param base_url [String] Absolute URL to resolve the configured callback uri against. Required
  #   if the configured callback uri is a relative.
  # @param scope [String, Array<String>] Authorization scope to request. Overrides the instance scopes if not
  #   nil.
  # @return [String] Authorization url
  def get_authorization_url(options = T.unsafe(nil)); end

  # Fetch stored credentials for the user.
  #
  # @param user_id [String] Unique ID of the user for loading/storing credentials.
  # @param scope [Array<String>, String] If specified, only returns credentials that have all
  #   the requested scopes
  # @return [Google::Auth::UserRefreshCredentials] Stored credentials, nil if none present
  def get_credentials(user_id, scope = T.unsafe(nil)); end

  # Exchanges an authorization code returned in the oauth callback
  #
  # @param user_id [String] Unique ID of the user for loading/storing credentials.
  # @param code [String] The authorization code from the OAuth callback
  # @param scope [String, Array<String>] Authorization scope requested. Overrides the instance
  #   scopes if not nil.
  # @param base_url [String] Absolute URL to resolve the configured callback uri against.
  #   Required if the configured
  #   callback uri is a relative.
  # @return [Google::Auth::UserRefreshCredentials] Credentials if exchange is successful
  def get_credentials_from_code(options = T.unsafe(nil)); end

  # Revokes a user's credentials. This both revokes the actual
  # grant as well as removes the token from the token store.
  #
  # @param user_id [String] Unique ID of the user for loading/storing credentials.
  def revoke_authorization(user_id); end

  # Store credentials for a user. Generally not required to be
  # called directly, but may be used to migrate tokens from one
  # store to another.
  #
  # @param user_id [String] Unique ID of the user for loading/storing credentials.
  # @param credentials [Google::Auth::UserRefreshCredentials] Credentials to store.
  def store_credentials(user_id, credentials); end

  private

  # Begin watching a credential for refreshes so the access token can be
  # saved.
  #
  # @param user_id [String] Unique ID of the user for loading/storing credentials.
  # @param credentials [Google::Auth::UserRefreshCredentials] Credentials to store.
  def monitor_credentials(user_id, credentials); end

  # Resolve the redirect uri against a base.
  #
  # @param base_url [String] Absolute URL to resolve the callback against if necessary.
  # @return [String] Redirect URI
  def redirect_uri_for(base_url); end

  # @param user_id [String] Unique ID of the user for loading/storing credentials.
  # @private Fetch stored token with given user_id
  # @raise [NIL_USER_ID_ERROR]
  # @return [String] The saved token from @token_store
  def stored_token(user_id); end

  # Check if URI is Google's postmessage flow (not a valid redirect_uri by spec, but allowed)
  #
  # @return [Boolean]
  def uri_is_postmessage?(uri); end
end

Google::Auth::UserAuthorizer::MISMATCHED_CLIENT_ID_ERROR = T.let(T.unsafe(nil), String)
Google::Auth::UserAuthorizer::MISSING_ABSOLUTE_URL_ERROR = T.let(T.unsafe(nil), String)
Google::Auth::UserAuthorizer::NIL_CLIENT_ID_ERROR = T.let(T.unsafe(nil), String)
Google::Auth::UserAuthorizer::NIL_SCOPE_ERROR = T.let(T.unsafe(nil), String)
Google::Auth::UserAuthorizer::NIL_TOKEN_STORE_ERROR = T.let(T.unsafe(nil), String)
Google::Auth::UserAuthorizer::NIL_USER_ID_ERROR = T.let(T.unsafe(nil), String)

# Authenticates requests using User Refresh credentials.
#
# This class allows authorizing requests from user refresh tokens.
#
# This the end of the result of a 3LO flow.  E.g, the end result of
# 'gcloud auth login' saves a file with these contents in well known
# location
#
# cf [Application Default Credentials](https://cloud.google.com/docs/authentication/production)
class Google::Auth::UserRefreshCredentials < ::Signet::OAuth2::Client
  extend ::Google::Auth::CredentialsLoader

  # @return [UserRefreshCredentials] a new instance of UserRefreshCredentials
  def initialize(options = T.unsafe(nil)); end

  # Verifies that a credential grants the requested scope
  #
  # @param required_scope [Array<String>, String] Scope to verify
  # @return [Boolean] True if scope is granted
  def includes_scope?(required_scope); end

  # Returns the value of attribute project_id.
  def project_id; end

  # Returns the value of attribute quota_project_id.
  def quota_project_id; end

  # Revokes the credential
  def revoke!(options = T.unsafe(nil)); end

  class << self
    # Create a UserRefreshCredentials.
    #
    # @param json_key_io [IO] an IO from which the JSON key can be read
    # @param scope [string|array|nil] the scope(s) to access
    def make_creds(options = T.unsafe(nil)); end

    # Reads the client_id, client_secret and refresh_token fields from the
    # JSON key.
    def read_json_key(json_key_io); end
  end
end

Google::Auth::UserRefreshCredentials::AUTHORIZATION_URI = T.let(T.unsafe(nil), String)
Google::Auth::UserRefreshCredentials::REVOKE_TOKEN_URI = T.let(T.unsafe(nil), String)
Google::Auth::UserRefreshCredentials::TOKEN_CRED_URI = T.let(T.unsafe(nil), String)

# Varation on {Google::Auth::UserAuthorizer} adapted for Rack based
# web applications.
#
# Example usage:
#
#     get('/') do
#       user_id = request.session['user_email']
#       credentials = authorizer.get_credentials(user_id, request)
#       if credentials.nil?
#         redirect authorizer.get_authorization_url(user_id: user_id,
#                                                   request: request)
#       end
#       # Credentials are valid, can call APIs
#       ...
#    end
#
#    get('/oauth2callback') do
#      url = Google::Auth::WebUserAuthorizer.handle_auth_callback_deferred(
#        request)
#      redirect url
#    end
#
# Instead of implementing the callback directly, applications are
# encouraged to use {Google::Auth::WebUserAuthorizer::CallbackApp} instead.
#
# @note Requires sessions are enabled
# @see CallbackApp
class Google::Auth::WebUserAuthorizer < ::Google::Auth::UserAuthorizer
  # Initialize the authorizer
  #
  # @param client_id [Google::Auth::ClientID] Configured ID & secret for this application
  # @param scope [String, Array<String>] Authorization scope to request
  # @param token_store [Google::Auth::Stores::TokenStore] Backing storage for persisting user credentials
  # @param callback_uri [String] URL (either absolute or relative) of the auth callback. Defaults
  #   to '/oauth2callback'
  # @return [WebUserAuthorizer] a new instance of WebUserAuthorizer
  def initialize(client_id, scope, token_store, callback_uri = T.unsafe(nil)); end

  # Build the URL for requesting authorization.
  #
  # @param login_hint [String] Login hint if need to authorize a specific account. Should be a
  #   user's email address or unique profile ID.
  # @param request [Rack::Request] Current request
  # @param redirect_to [String] Optional URL to proceed to after authorization complete. Defaults to
  #   the current URL.
  # @param scope [String, Array<String>] Authorization scope to request. Overrides the instance scopes if
  #   not nil.
  # @param state [Hash] Optional key-values to be returned to the oauth callback.
  # @raise [NIL_REQUEST_ERROR]
  # @return [String] Authorization url
  def get_authorization_url(options = T.unsafe(nil)); end

  # Fetch stored credentials for the user from the given request session.
  #
  # @param user_id [String] Unique ID of the user for loading/storing credentials.
  # @param request [Rack::Request] Current request. Optional. If omitted, this will attempt to fall back
  #   on the base class behavior of reading from the token store.
  # @param scope [Array<String>, String] If specified, only returns credentials that have all the \
  #   requested scopes
  # @raise [Signet::AuthorizationError] May raise an error if an authorization code is present in the session
  #   and exchange of the code fails
  # @return [Google::Auth::UserRefreshCredentials] Stored credentials, nil if none present
  def get_credentials(user_id, request = T.unsafe(nil), scope = T.unsafe(nil)); end

  # Handle the result of the oauth callback. Exchanges the authorization
  # code from the request and persists to storage.
  #
  # @param user_id [String] Unique ID of the user for loading/storing credentials.
  # @param request [Rack::Request] Current request
  # @return [Google::Auth::UserRefreshCredentials, String] credentials & next URL to redirect to
  def handle_auth_callback(user_id, request); end

  class << self
    # Returns the value of attribute default.
    def default; end

    # Sets the attribute default
    #
    # @param value the value to set the attribute default to.
    def default=(_arg0); end

    def extract_callback_state(request); end

    # Handle the result of the oauth callback. This version defers the
    # exchange of the code by temporarily stashing the results in the user's
    # session. This allows apps to use the generic
    # {Google::Auth::WebUserAuthorizer::CallbackApp} handler for the callback
    # without any additional customization.
    #
    # Apps that wish to handle the callback directly should use
    # {#handle_auth_callback} instead.
    #
    # @param request [Rack::Request] Current request
    def handle_auth_callback_deferred(request); end

    # Verifies the results of an authorization callback
    #
    # @option state
    # @option state
    # @param state [Hash] Callback state
    # @param request [Rack::Request] Current request
    # @raise [Signet::AuthorizationError]
    def validate_callback_state(state, request); end
  end
end

Google::Auth::WebUserAuthorizer::AUTHORIZATION_ERROR = T.let(T.unsafe(nil), String)
Google::Auth::WebUserAuthorizer::AUTH_CODE_KEY = T.let(T.unsafe(nil), String)
Google::Auth::WebUserAuthorizer::CALLBACK_STATE_KEY = T.let(T.unsafe(nil), String)
Google::Auth::WebUserAuthorizer::CURRENT_URI_KEY = T.let(T.unsafe(nil), String)

# Small Rack app which acts as the default callback handler for the app.
#
# To configure in Rails, add to routes.rb:
#
#     match '/oauth2callback',
#           to: Google::Auth::WebUserAuthorizer::CallbackApp,
#           via: :all
#
# With Rackup, add to config.ru:
#
#     map '/oauth2callback' do
#       run Google::Auth::WebUserAuthorizer::CallbackApp
#     end
#
# Or in a classic Sinatra app:
#
#     get('/oauth2callback') do
#       Google::Auth::WebUserAuthorizer::CallbackApp.call(env)
#     end
#
# @see Google::Auth::WebUserAuthorizer
class Google::Auth::WebUserAuthorizer::CallbackApp
  def call(env); end

  class << self
    # Handle a rack request. Simply stores the results the authorization
    # in the session temporarily and redirects back to to the previously
    # saved redirect URL. Credentials can be later retrieved by calling.
    # {Google::Auth::Web::WebUserAuthorizer#get_credentials}
    #
    # See {Google::Auth::Web::WebUserAuthorizer#get_authorization_uri}
    # for how to initiate authorization requests.
    #
    # @param env [Hash] Rack environment
    # @return [Array] HTTP response
    def call(env); end
  end
end

Google::Auth::WebUserAuthorizer::CallbackApp::ERROR_STATUS = T.let(T.unsafe(nil), Integer)
Google::Auth::WebUserAuthorizer::CallbackApp::LOCATION_HEADER = T.let(T.unsafe(nil), String)
Google::Auth::WebUserAuthorizer::CallbackApp::REDIR_STATUS = T.let(T.unsafe(nil), Integer)
Google::Auth::WebUserAuthorizer::ERROR_CODE_KEY = T.let(T.unsafe(nil), String)
Google::Auth::WebUserAuthorizer::INVALID_STATE_TOKEN_ERROR = T.let(T.unsafe(nil), String)
Google::Auth::WebUserAuthorizer::MISSING_AUTH_CODE_ERROR = T.let(T.unsafe(nil), String)
Google::Auth::WebUserAuthorizer::NIL_REQUEST_ERROR = T.let(T.unsafe(nil), String)
Google::Auth::WebUserAuthorizer::NIL_SESSION_ERROR = T.let(T.unsafe(nil), String)
Google::Auth::WebUserAuthorizer::SCOPE_KEY = T.let(T.unsafe(nil), String)
Google::Auth::WebUserAuthorizer::SESSION_ID_KEY = T.let(T.unsafe(nil), String)
Google::Auth::WebUserAuthorizer::STATE_PARAM = T.let(T.unsafe(nil), String)
Google::Auth::WebUserAuthorizer::XSRF_KEY = T.let(T.unsafe(nil), String)

module Signet
  class << self
    def parse_auth_param_list(auth_param_string); end
  end
end

# OAuth2 supports OAuth2 authentication.
module Signet::OAuth2
  class << self
    def generate_authorization_uri(authorization_uri, parameters = T.unsafe(nil)); end
    def generate_basic_authorization_header(client_id, client_password); end
    def generate_bearer_authorization_header(access_token, auth_params = T.unsafe(nil)); end
    def parse_authorization_header(field_value); end
    def parse_basic_credentials(credential_string); end
    def parse_bearer_credentials(credential_string); end
    def parse_credentials(body, content_type); end
    def parse_oauth_challenge(challenge_string); end
    def parse_www_authenticate_header(field_value); end
  end
end

Signet::OAuth2::AUTH_METADATA_KEY = T.let(T.unsafe(nil), Symbol)

# Signet::OAuth2::Client creates an OAuth2 client
#
# This reopens Client to add #apply and #apply! methods which update a
# hash with the fetched authentication token.
class Signet::OAuth2::Client
  def initialize(options = T.unsafe(nil)); end

  def access_token; end
  def access_token=(new_access_token); end
  def access_type; end
  def access_type=(new_access_type); end
  def additional_parameters; end
  def additional_parameters=(new_additional_parameters); end

  # Returns a clone of a_hash updated with the authentication token
  def apply(a_hash, opts = T.unsafe(nil)); end

  # Updates a_hash updated with the authentication token
  def apply!(a_hash, opts = T.unsafe(nil)); end

  def audience; end
  def audience=(new_audience); end
  def authorization_uri(options = T.unsafe(nil)); end
  def authorization_uri=(new_authorization_uri); end
  def build_default_connection; end
  def clear_credentials!; end
  def client_id; end
  def client_id=(new_client_id); end
  def client_secret; end
  def client_secret=(new_client_secret); end
  def code; end
  def code=(new_code); end
  def coerce_uri(incoming_uri); end
  def configure_connection(options); end
  def decoded_id_token(public_key = T.unsafe(nil), options = T.unsafe(nil), &keyfinder); end
  def expired?; end
  def expires_at; end
  def expires_at=(new_expires_at); end
  def expires_in; end
  def expires_in=(new_expires_in); end
  def expires_within?(sec); end
  def expiry; end
  def expiry=(new_expiry); end
  def extension_parameters; end
  def extension_parameters=(new_extension_parameters); end
  def fetch_access_token(options = T.unsafe(nil)); end
  def fetch_access_token!(options = T.unsafe(nil)); end
  def fetch_protected_resource(options = T.unsafe(nil)); end
  def generate_access_token_request(options = T.unsafe(nil)); end
  def generate_authenticated_request(options = T.unsafe(nil)); end
  def grant_type; end
  def grant_type=(new_grant_type); end
  def id_token; end
  def id_token=(new_id_token); end
  def issued_at; end
  def issued_at=(new_issued_at); end
  def issuer; end
  def issuer=(new_issuer); end

  # Whether the id_token or access_token is missing or about to expire.
  #
  # @return [Boolean]
  def needs_access_token?; end

  def notify_refresh_listeners; end
  def on_refresh(&block); end
  def orig_fetch_access_token!(options = T.unsafe(nil)); end
  def password; end
  def password=(new_password); end
  def person; end
  def person=(new_person); end
  def principal; end
  def principal=(new_person); end
  def redirect_uri; end
  def redirect_uri=(new_redirect_uri); end
  def refresh!(options = T.unsafe(nil)); end
  def refresh_token; end
  def refresh_token=(new_refresh_token); end
  def retry_with_error(max_retry_count = T.unsafe(nil)); end
  def scope; end
  def scope=(new_scope); end
  def signing_algorithm; end
  def signing_key; end
  def signing_key=(new_key); end
  def state; end
  def state=(new_state); end
  def sub; end
  def sub=(_arg0); end
  def target_audience; end
  def target_audience=(new_target_audience); end
  def to_json(*_args); end
  def to_jwt(options = T.unsafe(nil)); end
  def token_credential_uri; end
  def token_credential_uri=(new_token_credential_uri); end

  # The token type as symbol, either :id_token or :access_token
  def token_type; end

  def update!(options = T.unsafe(nil)); end
  def update_token!(options = T.unsafe(nil)); end

  # Returns a reference to the #apply method, suitable for passing as
  # a closure
  def updater_proc; end

  def username; end
  def username=(new_username); end

  private

  def deep_hash_normalize(old_hash); end
  def normalize_timestamp(time); end
  def recursive_hash_normalize_keys(val); end
  def set_relative_expires_at(issued_at, expires_in); end
  def uri_is_oob?(uri); end
  def uri_is_postmessage?(uri); end
end

Signet::OAuth2::Client::OOB_MODES = T.let(T.unsafe(nil), Array)
Signet::VERSION = T.let(T.unsafe(nil), String)
