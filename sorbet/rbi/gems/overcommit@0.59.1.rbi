# typed: true

# DO NOT EDIT MANUALLY
# This is an autogenerated file for types exported from the `overcommit` gem.
# Please instead update this file by running `bin/tapioca gem overcommit`.

# Provides a handler for interrupt signals (SIGINT), allowing the application to
# finish what it's currently working on.
class InterruptHandler
  include ::Singleton
  extend ::Singleton::SingletonClassMethods

  # Initialize safe interrupt signal handling.
  #
  # @return [InterruptHandler] a new instance of InterruptHandler
  def initialize; end

  # Returns the value of attribute isolate_signals.
  def isolate_signals; end

  # Sets the attribute isolate_signals
  #
  # @param value the value to set the attribute isolate_signals to.
  def isolate_signals=(_arg0); end

  # Returns the value of attribute reenable_on_interrupt.
  def reenable_on_interrupt; end

  # Sets the attribute reenable_on_interrupt
  #
  # @param value the value to set the attribute reenable_on_interrupt to.
  def reenable_on_interrupt=(_arg0); end

  # Returns the value of attribute signal_received.
  def signal_received; end

  # Sets the attribute signal_received
  #
  # @param value the value to set the attribute signal_received to.
  def signal_received=(_arg0); end

  class << self
    # Disable interrupt isolation.
    def disable!; end

    # Provide a way to allow a single Ctrl-C interrupt to happen and atomically
    # re-enable interrupt protections once that interrupt is propagated.
    #
    # This prevents a race condition where code like the following:
    #
    #  begin
    #    InterruptHandler.disable!
    #    ... do stuff ...
    #  rescue Interrupt
    #    ... handle it ...
    #  ensure
    #    InterruptHandler.enable!
    #  end
    #
    # ...could have the `enable!` call to the interrupt handler not called in
    # the event another interrupt was received in between the interrupt being
    # handled and the `ensure` block being entered.
    #
    # Thus you should always write:
    #
    #  begin
    #    InterruptHandler.disable_until_finished_or_interrupted do
    #      ... do stuff ...
    #    end
    #  rescue Interrupt
    #    ... handle it ...
    #  rescue
    #    ... handle any other exceptions ...
    #  end
    def disable_until_finished_or_interrupted; end

    # Enable interrupt isolation.
    def enable!; end

    # Enable interrupt isolation while executing the provided block.
    #
    # @yield block to execute with interrupt isolation
    def isolate_from_interrupts; end
  end
end

# Defines the gem version.
module Overcommit; end

Overcommit::BUG_REPORT_URL = T.let(T.unsafe(nil), String)
Overcommit::CONFIG_FILE_NAME = T.let(T.unsafe(nil), String)

# Distributes a list of arguments over multiple invocations of a command.
#
# This accomplishes the same functionality provided by `xargs` but in a
# cross-platform way that does not require any pre-existing tools.
#
# One of the tradeoffs with this approach is that we no longer deal with a
# single exit status from a command, but multiple (one for each invocation).
#
# This will return a struct similar to `Subprocess::Result` but with
# additional `statuses`, `stdouts`, and `stderrs` fields so hook authors can
# actually see the results of each invocation. If they don't care, the
# standard `status`, `stdout`, and `stderr` will still work but be a
# aggregation/concatenation of all statuses/outputs.
class Overcommit::CommandSplitter
  class << self
    def execute(initial_args, options); end

    private

    # @return [Array<Array<String>, Integer>] tuple of arguments and new index
    def arguments_under_limit(splittable_args, start_index, byte_limit); end

    # Given a list of prefix arguments and suffix arguments that can be split,
    # returns a list of argument lists that are executable on the current OS
    # without exceeding command line limitations.
    def extract_argument_lists(args, splittable_args); end

    # Returns the maximum number of arguments allowed in a single command on
    # this system.
    #
    # @return [Integer]
    def max_command_length; end
  end
end

# Encapsulates the result of a split argument run.
#
# @attr_reader statuses [Array<Integer>] status codes for invocations
# @attr_reader stdouts [Array<String>] standard outputs from invocations
# @attr_reader stderrs [Array<String>] standard error outputs from invocations
class Overcommit::CommandSplitter::Result < ::Struct
  # Returns `0` if all invocations returned `0`; `1` otherwise.
  #
  # @return [true, false]
  def status; end

  # status codes for invocations
  #
  # @return [Array<Integer>] the current value of statuses
  def statuses; end

  def statuses=(_); end

  # Returns concatenated standard error streams of all invocations in the
  # order they were executed.
  #
  # @return [String]
  def stderr; end

  # standard error outputs from invocations
  #
  # @return [Array<String>] the current value of stderrs
  def stderrs; end

  def stderrs=(_); end

  # Returns concatenated standard output streams of all invocations in the
  # order they were executed.
  #
  # @return [String]
  def stdout; end

  # standard outputs from invocations
  #
  # @return [Array<String>] the current value of stdouts
  def stdouts; end

  def stdouts=(_); end

  # Returns whether all invocations were successful.
  #
  # @return [true, false]
  def success?; end

  class << self
    def [](*_arg0); end
    def inspect; end
    def members; end
    def new(*_arg0); end
  end
end

# Stores configuration for Overcommit and the hooks it runs.
class Overcommit::Configuration
  # Creates a configuration from the given hash.
  #
  # @option default
  # @option logger
  # @param hash [Hash] loaded YAML config file as a hash
  # @param options [Hash]
  # @param default [Hash] a customizable set of options
  # @param logger [Hash] a customizable set of options
  # @return [Configuration] a new instance of Configuration
  def initialize(hash, options = T.unsafe(nil)); end

  def ==(other); end

  # Access the configuration as if it were a hash.
  #
  # @param key [String]
  # @return [Array, Hash, Number, String]
  def [](key); end

  # Returns configuration for all built-in hooks in each hook type.
  #
  # @return [Hash]
  def all_builtin_hook_configs; end

  # Returns configuration for all hooks in each hook type.
  #
  # @return [Hash]
  def all_hook_configs; end

  # Returns configuration for all plugin hooks in each hook type.
  #
  # @return [Hash]
  def all_plugin_hook_configs; end

  # Applies additional configuration settings based on the provided
  # environment variables.
  def apply_environment!(hook_context, env); end

  def concurrency; end

  # Returns the ad hoc hooks that have been enabled for a hook type.
  def enabled_ad_hoc_hooks(hook_context); end

  # Returns the built-in hooks that have been enabled for a hook type.
  def enabled_builtin_hooks(hook_context); end

  # Returns a non-modifiable configuration for a hook.
  def for_hook(hook, hook_type = T.unsafe(nil)); end

  # Merges the given configuration with this one, returning a new
  # {Configuration}. The provided configuration will either add to or replace
  # any options defined in this configuration.
  def merge(config); end

  # Returns absolute path to the directory that external hook plugins should
  # be loaded from.
  def plugin_directory; end

  # @return [Boolean]
  def plugin_hook?(hook_context_or_type, hook_name); end

  # Return whether a previous signature has been recorded for this
  # configuration.
  #
  # @return [true, false]
  def previous_signature?; end

  # Return whether the signature for this configuration has changed since it
  # was last calculated.
  #
  # @return [true, false]
  def signature_changed?; end

  # Update the currently stored signature for this hook.
  def update_signature!; end

  # Returns whether this configuration should verify itself by checking the
  # stored configuration for the repo.
  #
  # @return [true, false]
  def verify_signatures?; end

  protected

  # Returns the value of attribute hash.
  def hash; end

  private

  # @return [Boolean]
  def ad_hoc_hook?(hook_context, hook_name); end

  # @return [Boolean]
  def built_in_hook?(hook_context, hook_name); end

  # @return [Boolean]
  def hook_enabled?(hook_context_or_type, hook_name); end

  # @return [Boolean]
  def hook_exists?(hook_context, hook_name); end

  # Returns the unique signature of this configuration.
  #
  # @return [String]
  def signature; end

  def signature_config_key; end
  def smart_merge(parent, child); end

  # Returns the stored signature of this repo's Overcommit configuration.
  #
  # This is intended to be compared against the current signature of this
  # configuration object.
  #
  # @return [String]
  def stored_signature; end

  def verify_signature_config_key; end
end

# Manages configuration file loading.
class Overcommit::ConfigurationLoader
  # Create a configuration loader which writes warnings/errors to the given
  # {Overcommit::Logger} instance.
  #
  # @option verify
  # @param logger [Overcommit::Logger]
  # @param options [Hash]
  # @param verify [Hash] a customizable set of options
  # @return [ConfigurationLoader] a new instance of ConfigurationLoader
  def initialize(logger, options = T.unsafe(nil)); end

  # Loads a configuration, ensuring it extends the default configuration.
  def load_file(file); end

  # Loads and returns the configuration for the repository we're running in.
  #
  # @return [Overcommit::Configuration]
  def load_repo_config; end

  private

  def verify_signatures(config); end

  class << self
    # Loads and returns the default configuration.
    #
    # @return [Overcommit::Configuration]
    def default_configuration; end

    # Loads configuration from file.
    #
    # @option logger
    # @option verify
    # @option default
    # @param verify [Hash] a customizable set of options
    # @param logger [Hash] a customizable set of options
    # @param options [Hash]
    # @param file [String] path to file
    # @param default [Hash] a customizable set of options
    # @return [Overcommit::Configuration]
    def load_from_file(file, options = T.unsafe(nil)); end
  end
end

Overcommit::ConfigurationLoader::DEFAULT_CONFIG_PATH = T.let(T.unsafe(nil), String)

# Validates and normalizes a configuration.
class Overcommit::ConfigurationValidator
  # Validates hash for any invalid options, normalizing where possible.
  #
  # @option logger
  # @option default
  # @param hash [Hash] hash representation of YAML config
  # @param default [Hash] a customizable set of options
  # @param logger [Hash] a customizable set of options
  # @param options [Hash]
  # @param config [Overcommit::Configuration]
  # @return [Hash] validated hash (potentially modified)
  def validate(config, hash, options); end

  private

  # Prints a warning if there are any hooks listed in the configuration
  # without `enabled` explicitly set.
  def check_for_missing_enabled_option(hash); end

  # Prints a warning if any hook has a number of processors larger than the
  # global `concurrency` setting.
  def check_for_too_many_processors(config, hash); end

  # Prints a warning if the `verify_plugin_signatures` option is used instead
  # of the new `verify_signatures` option.
  def check_for_verify_plugin_signatures_option(hash); end

  def check_hook_env(hash); end

  # Prints an error message and raises an exception if a hook has an
  # invalid name, since this can result in strange errors elsewhere.
  def check_hook_name_format(hash); end

  # Normalizes `nil` values to empty hashes.
  #
  # This is useful for when we want to merge two configuration hashes
  # together, since it's easier to merge two hashes than to have to check if
  # one of the values is nil.
  def convert_nils_to_empty_hashes(hash); end

  # Ensures that keys for all supported hook types exist (PreCommit,
  # CommitMsg, etc.)
  def ensure_hook_type_sections_exist(hash); end
end

module Overcommit::Exceptions; end

# Raised when a {Configuration} could not be loaded from a file.
class Overcommit::Exceptions::ConfigurationError < ::Overcommit::Exceptions::Error; end

# Raised when the Overcommit configuration file signature has changed.
class Overcommit::Exceptions::ConfigurationSignatureChanged < ::Overcommit::Exceptions::Error; end

# Base error class.
class Overcommit::Exceptions::Error < ::StandardError; end

# Raised when trying to read/write to/from the local repo git config fails.
class Overcommit::Exceptions::GitConfigError < ::Overcommit::Exceptions::Error; end

# Raised when there was a problem reading git revision information with `rev-list`.
class Overcommit::Exceptions::GitRevListError < ::Overcommit::Exceptions::Error; end

# Raised when there was a problem reading submodule information for a repo.
class Overcommit::Exceptions::GitSubmoduleError < ::Overcommit::Exceptions::Error; end

# Raised when a hook run was cancelled by the user.
class Overcommit::Exceptions::HookCancelled < ::Overcommit::Exceptions::Error; end

# Raised when a {HookContext} is unable to clean the environment after a run.
class Overcommit::Exceptions::HookCleanupFailed < ::Overcommit::Exceptions::Error; end

# Raised when a {HookRunner} could not be loaded.
class Overcommit::Exceptions::HookContextLoadError < ::Overcommit::Exceptions::Error; end

# Raised when a hook could not be loaded by a {HookRunner}.
class Overcommit::Exceptions::HookLoadError < ::Overcommit::Exceptions::Error; end

# Raised when a {HookContext} is unable to setup the environment before a run.
class Overcommit::Exceptions::HookSetupFailed < ::Overcommit::Exceptions::Error; end

# Raised when a pipe character is used in the `execute` helper, as this was
# likely used in error.
class Overcommit::Exceptions::InvalidCommandArgs < ::Overcommit::Exceptions::Error; end

# Raised when an installation target is not a valid git repository.
class Overcommit::Exceptions::InvalidGitRepo < ::Overcommit::Exceptions::Error; end

# Raised when a hook was defined incorrectly.
class Overcommit::Exceptions::InvalidHookDefinition < ::Overcommit::Exceptions::Error; end

# Raised when one or more hook plugin signatures have changed.
class Overcommit::Exceptions::InvalidHookSignature < ::Overcommit::Exceptions::Error; end

# Raised when there is a problem processing output into {Hook::Messages}s.
class Overcommit::Exceptions::MessageProcessingError < ::Overcommit::Exceptions::Error; end

# Raised when an installation target already contains non-Overcommit hooks.
class Overcommit::Exceptions::PreExistingHooks < ::Overcommit::Exceptions::Error; end

Overcommit::GIT_VERSION = T.let(T.unsafe(nil), Overcommit::Utils::Version)

# Get configuration options from git
module Overcommit::GitConfig
  private

  def comment_character; end
  def hooks_path; end

  class << self
    def comment_character; end
    def hooks_path; end
  end
end

# Provide a set of utilities for certain interactions with `git`.
module Overcommit::GitRepo
  private

  # Returns the names of all files that are tracked by git.
  #
  # @return [Array<String>] list of absolute file paths
  def all_files; end

  # Returns the names of all branches containing the given commit.
  #
  # @param commit_ref [String] git tree ref that resolves to a commit
  # @return [Array<String>] list of branches containing the given commit
  def branches_containing_commit(commit_ref); end

  # Returns the name of the currently checked out branch.
  #
  # @return [String]
  def current_branch; end

  # Extract the set of modified lines from a given file.
  #
  # @param file_path [String]
  # @param options [Hash]
  # @return [Set] line numbers that have been modified in file
  def extract_modified_lines(file_path, options); end

  # Returns whether the current git branch is empty (has no commits).
  #
  # @return [true, false]
  def initial_commit?; end

  # Returns the names of files in the given paths that are tracked by git.
  #
  # @option options
  # @param paths [Array<String>] list of paths to check
  # @return [Array<String>] list of absolute file paths
  def list_files(paths = T.unsafe(nil), options = T.unsafe(nil)); end

  # Returns the names of all files that have been modified compared to HEAD.
  #
  # @param options [Hash]
  # @return [Array<String>] list of absolute file paths
  def modified_files(options); end

  # Restore any relevant files that were present when repo was in the middle
  # of a cherry-pick.
  def restore_cherry_pick_state; end

  # Restore any relevant files that were present when repo was in the middle
  # of a merge.
  def restore_merge_state; end

  # Returns the submodules that have been staged for removal.
  #
  # `git` has an unexpected behavior where removing a submodule without
  # committing (i.e. such that the submodule directory is removed and the
  # changes to the index are staged) and then doing a hard reset results in
  # the index being wiped but the empty directory of the once existent
  # submodule being restored (but with no content).
  #
  # This prevents restoration of the stash of the submodule index changes,
  # which breaks pre-commit hook restorations of the working index.
  #
  # Thus we expose this helper so the restoration code can manually delete the
  # directory.
  #
  # @raise [Overcommit::Exceptions::GitSubmoduleError] when
  def staged_submodule_removals; end

  # Store any relevant files that are present when repo is in the middle of a
  # cherry-pick.
  #
  # Restored via [#restore_cherry_pick_state].
  def store_cherry_pick_state; end

  # Store any relevant files that are present when repo is in the middle of a
  # merge.
  #
  # Restored via [#restore_merge_state].
  def store_merge_state; end

  # Returns a list of SubmoduleStatus objects, one for each submodule in the
  # parent repository.
  #
  # @option options
  # @return [Array<SubmoduleStatus>]
  def submodule_statuses(options = T.unsafe(nil)); end

  # Returns the current set of registered submodules.
  #
  # @param options [Hash]
  # @return [Array<Overcommit::GitRepo::Submodule>]
  def submodules(options = T.unsafe(nil)); end

  # Returns whether the specified file/path is tracked by this repository.
  #
  # @param path [String]
  # @return [true, false]
  def tracked?(path); end

  class << self
    # Returns the names of all files that are tracked by git.
    #
    # @return [Array<String>] list of absolute file paths
    def all_files; end

    # Returns the names of all branches containing the given commit.
    #
    # @param commit_ref [String] git tree ref that resolves to a commit
    # @return [Array<String>] list of branches containing the given commit
    def branches_containing_commit(commit_ref); end

    # Returns the name of the currently checked out branch.
    #
    # @return [String]
    def current_branch; end

    # Extract the set of modified lines from a given file.
    #
    # @param file_path [String]
    # @param options [Hash]
    # @return [Set] line numbers that have been modified in file
    def extract_modified_lines(file_path, options); end

    # Returns whether the current git branch is empty (has no commits).
    #
    # @return [true, false]
    def initial_commit?; end

    # Returns the names of files in the given paths that are tracked by git.
    #
    # @option options
    # @param paths [Array<String>] list of paths to check
    # @param options [Hash] a customizable set of options
    # @return [Array<String>] list of absolute file paths
    def list_files(paths = T.unsafe(nil), options = T.unsafe(nil)); end

    # Returns the names of all files that have been modified compared to HEAD.
    #
    # @param options [Hash]
    # @return [Array<String>] list of absolute file paths
    def modified_files(options); end

    # Restore any relevant files that were present when repo was in the middle
    # of a cherry-pick.
    def restore_cherry_pick_state; end

    # Restore any relevant files that were present when repo was in the middle
    # of a merge.
    def restore_merge_state; end

    # Returns the submodules that have been staged for removal.
    #
    # `git` has an unexpected behavior where removing a submodule without
    # committing (i.e. such that the submodule directory is removed and the
    # changes to the index are staged) and then doing a hard reset results in
    # the index being wiped but the empty directory of the once existent
    # submodule being restored (but with no content).
    #
    # This prevents restoration of the stash of the submodule index changes,
    # which breaks pre-commit hook restorations of the working index.
    #
    # Thus we expose this helper so the restoration code can manually delete the
    # directory.
    #
    # @raise [Overcommit::Exceptions::GitSubmoduleError] when
    def staged_submodule_removals; end

    # Store any relevant files that are present when repo is in the middle of a
    # cherry-pick.
    #
    # Restored via [#restore_cherry_pick_state].
    def store_cherry_pick_state; end

    # Store any relevant files that are present when repo is in the middle of a
    # merge.
    #
    # Restored via [#restore_merge_state].
    def store_merge_state; end

    # Returns a list of SubmoduleStatus objects, one for each submodule in the
    # parent repository.
    #
    # @option options
    # @param options [Hash] a customizable set of options
    # @return [Array<SubmoduleStatus>]
    def submodule_statuses(options = T.unsafe(nil)); end

    # Returns the current set of registered submodules.
    #
    # @param options [Hash]
    # @return [Array<Overcommit::GitRepo::Submodule>]
    def submodules(options = T.unsafe(nil)); end

    # Returns whether the specified file/path is tracked by this repository.
    #
    # @param path [String]
    # @return [true, false]
    def tracked?(path); end
  end
end

# Regular expression used to extract diff ranges from hunks of diff output.
Overcommit::GitRepo::DIFF_HUNK_REGEX = T.let(T.unsafe(nil), Regexp)

# Regular expression used to extract information from lines of
# `git submodule status` output
Overcommit::GitRepo::SUBMODULE_STATUS_REGEX = T.let(T.unsafe(nil), Regexp)

# Contains information about a registered submodule.
class Overcommit::GitRepo::Submodule < ::Struct
  # Returns the value of attribute path
  #
  # @return [Object] the current value of path
  def path; end

  # Sets the attribute path
  #
  # @param value [Object] the value to set the attribute path to.
  # @return [Object] the newly set value
  def path=(_); end

  # Returns the value of attribute url
  #
  # @return [Object] the current value of url
  def url; end

  # Sets the attribute url
  #
  # @param value [Object] the value to set the attribute url to.
  # @return [Object] the newly set value
  def url=(_); end

  class << self
    def [](*_arg0); end
    def inspect; end
    def members; end
    def new(*_arg0); end
  end
end

# Struct encapsulating submodule information extracted from the
# output of `git submodule status`
class Overcommit::GitRepo::SubmoduleStatus < ::Struct
  # Returns the value of attribute describe
  #
  # @return [Object] the current value of describe
  def describe; end

  # Sets the attribute describe
  #
  # @param value [Object] the value to set the attribute describe to.
  # @return [Object] the newly set value
  def describe=(_); end

  # Returns whether the submodule reference has a merge conflict
  #
  # @return [Boolean]
  def merge_conflict?; end

  # Returns whether the submodule is out of date with the current
  # index, i.e. its checked-out commit differs from that stored in
  # the index of the parent repo
  #
  # @return [Boolean]
  def outdated?; end

  # Returns the value of attribute path
  #
  # @return [Object] the current value of path
  def path; end

  # Sets the attribute path
  #
  # @param value [Object] the value to set the attribute path to.
  # @return [Object] the newly set value
  def path=(_); end

  # Returns the value of attribute prefix
  #
  # @return [Object] the current value of prefix
  def prefix; end

  # Sets the attribute prefix
  #
  # @param value [Object] the value to set the attribute prefix to.
  # @return [Object] the newly set value
  def prefix=(_); end

  # Returns the value of attribute sha1
  #
  # @return [Object] the current value of sha1
  def sha1; end

  # Sets the attribute sha1
  #
  # @param value [Object] the value to set the attribute sha1 to.
  # @return [Object] the newly set value
  def sha1=(_); end

  # Returns whether the submodule has not been initialized
  #
  # @return [Boolean]
  def uninitialized?; end

  class << self
    def [](*_arg0); end
    def inspect; end
    def members; end
    def new(*_arg0); end
  end
end

Overcommit::HOME = T.let(T.unsafe(nil), String)
Overcommit::HOOK_DIRECTORY = T.let(T.unsafe(nil), String)

# Container for top-level hook-related classes and constants.
module Overcommit::Hook; end

# Functionality common to all hooks.
class Overcommit::Hook::Base
  extend ::Forwardable

  # @param config [Overcommit::Configuration]
  # @param context [Overcommit::HookContext]
  # @return [Base] a new instance of Base
  def initialize(config, context); end

  def all_files(*args, &block); end

  # Gets a list of staged files that apply to this hook based on its
  # configured `include` and `exclude` lists.
  def applicable_files; end

  # Return command to execute for this hook.
  #
  # This is intended to be configurable so hooks can prefix their commands
  # with `bundle exec` or similar. It will appends the command line flags
  # specified by the `flags` option after.
  #
  # Note that any files intended to be passed must be handled by the hook
  # itself.
  #
  # @return [Array<String>]
  def command; end

  # Returns the value of attribute config.
  def config; end

  def description; end

  # @return [Boolean]
  def enabled?; end

  # @return [Boolean]
  def excluded?; end

  # Execute a command in a separate process.
  #
  # If `splittable_args` is specified, ensures that those arguments are
  # concatenated onto the end of the `cmd` arguments, but split up so that the
  # operating system's maximum command length is not exceeded. This is useful
  # for splitting up long file lists.
  #
  # @option options
  # @option options
  # @param cmd [Array<String>] command arguments
  # @param options [Hash]
  # @return [#status, #stdout, #stderr] struct containing result of invocation
  def execute(cmd, options = T.unsafe(nil)); end

  def execute_in_background(cmd); end

  # Return command line flags to be passed to the command.
  #
  # This excludes the list of files, as that must be handled by the hook
  # itself.
  #
  # The intention here is to provide flexibility for when a tool
  # removes/renames its flags. Rather than wait for Overcommit to update the
  # flags it uses, you can update your configuration to use the new flags
  # right away without being blocked.
  #
  # Also note that any flags containing dynamic content must be passed in the
  # hook's {#run} method.
  #
  # @return [Array<String>]
  def flags; end

  # @return [Boolean]
  def in_path?(cmd); end

  # Gets a list of all files that apply to this hook based on its
  # configured `include` and `exclude` lists.
  def included_files; end

  def modified_files(*args, &block); end
  def name; end

  # @return [Boolean]
  def parallelize?; end

  def processors; end

  # @return [Boolean]
  def quiet?; end

  # @return [Boolean]
  def required?; end

  def required_executable; end
  def required_libraries; end

  # Runs the hook.
  #
  # @raise [NotImplementedError]
  def run; end

  # @return [Boolean]
  def run?; end

  # Runs the hook and transforms the status returned based on the hook's
  # configuration.
  #
  # Poorly named because we already have a bunch of hooks in the wild that
  # implement `#run`, and we needed a wrapper step to transform the status
  # based on any custom configuration.
  def run_and_transform; end

  # @return [Boolean]
  def skip?; end

  private

  # @return [Boolean]
  def applicable_file?(file); end

  # If the hook defines a required executable, check if it's in the path and
  # display the install command if one exists.
  def check_for_executable; end

  # If the hook defines required library paths that it wants to load, attempt
  # to load them.
  def check_for_libraries; end

  # Check for any required executables or libraries.
  #
  # Returns output if any requirements are not met.
  def check_for_requirements; end

  def current_branch; end
  def exclude_branches; end
  def install_command_prompt; end

  # Converts the hook's return value into a canonical form of a tuple
  # containing status (pass/warn/fail) and output.
  #
  # This is intended to support various shortcuts for writing hooks so that
  # hook authors don't need to work with {Overcommit::Hook::Message} objects
  # for simple pass/fail hooks. It also saves you from needing to manually
  # encode logic like "if there are errors, fail; if there are warnings, warn,
  # otherwise pass." by simply returning an array of
  # {Overcommit::Hook::Message} objects.
  #
  # @param hook_return_value [Symbol, Array<Symbol,String>, Array<Message>]
  # @return [Array<Symbol,String>] tuple of status and output
  def process_hook_return_value(hook_return_value); end

  def select_applicable(list); end

  # Transforms the hook's status based on custom configuration.
  #
  # This allows users to change failures into warnings, or vice versa.
  def transform_status(status); end
end

# Possible types of messages.
Overcommit::Hook::MESSAGE_TYPES = T.let(T.unsafe(nil), Array)

# Helper containing metadata about error/warning messages returned by hooks.
class Overcommit::Hook::Message < ::Struct
  # Returns the value of attribute content
  #
  # @return [Object] the current value of content
  def content; end

  # Sets the attribute content
  #
  # @param value [Object] the value to set the attribute content to.
  # @return [Object] the newly set value
  def content=(_); end

  # Returns the value of attribute file
  #
  # @return [Object] the current value of file
  def file; end

  # Sets the attribute file
  #
  # @param value [Object] the value to set the attribute file to.
  # @return [Object] the newly set value
  def file=(_); end

  # Returns the value of attribute line
  #
  # @return [Object] the current value of line
  def line; end

  # Sets the attribute line
  #
  # @param value [Object] the value to set the attribute line to.
  # @return [Object] the newly set value
  def line=(_); end

  def to_s; end

  # Returns the value of attribute type
  #
  # @return [Object] the current value of type
  def type; end

  # Sets the attribute type
  #
  # @param value [Object] the value to set the attribute type to.
  # @return [Object] the newly set value
  def type=(_); end

  class << self
    def [](*_arg0); end
    def inspect; end
    def members; end
    def new(*_arg0); end
  end
end

# Utility module which manages the creation of {HookContext}s.
module Overcommit::HookContext
  class << self
    def create(hook_type, config, args, input); end
  end
end

# Contains helpers related to the context with which a hook is being run.
#
# It acts as an adapter to the arguments passed to the hook, as well as
# context-specific information such as staged files, providing a single source
# of truth for this context.
#
# This is also important to house in a separate object so that any
# calculations can be memoized across all hooks in a single object, which
# helps with performance.
#
# @abstract
class Overcommit::HookContext::Base
  # Creates a hook context from the given configuration and input options.
  #
  # @param config [Overcommit::Configuration]
  # @param args [Array<String>]
  # @param input [IO] standard input stream
  # @return [Base] a new instance of Base
  def initialize(config, args, input); end

  # Returns the full list of files tracked by git
  #
  # @return [Array<String>]
  def all_files; end

  # Resets the environment to an appropriate state.
  #
  # This is called after the hooks have been run by the [HookRunner].
  # Different hook types can perform different cleanup operations, which are
  # intended to "undo" the results of the call to {#setup_environment}.
  def cleanup_environment; end

  # Executes a command as if it were a regular git hook, passing all
  # command-line arguments and the standard input stream.
  #
  # This is intended to be used by ad hoc hooks so developers can link up
  # their existing git hooks with Overcommit.
  def execute_hook(command); end

  # Returns the camel-cased type of this hook (e.g. PreCommit)
  #
  # @return [String]
  def hook_class_name; end

  # Returns the actual name of the hook script being run (e.g. pre-commit).
  #
  # @return [String]
  def hook_script_name; end

  # Returns the snake-cased type of this hook (e.g. pre_commit)
  #
  # @return [String]
  def hook_type_name; end

  # Returns an array of lines passed to the hook via the standard input
  # stream.
  #
  # @return [Array<String>]
  def input_lines; end

  # Returns the contents of the entire standard input stream that were passed
  # to the hook.
  #
  # @return [String]
  def input_string; end

  # Returns a list of files that have been modified.
  #
  # By default, this returns an empty list. Subclasses should implement if
  # there is a concept of files changing for the type of hook being run.
  #
  # @return [Array<String>]
  def modified_files; end

  # Returns a message to display on failure.
  #
  # @return [String]
  def post_fail_message; end

  # Initializes anything related to the environment.
  #
  # This is called before the hooks are run by the [HookRunner]. Different
  # hook types can perform different setup.
  def setup_environment; end

  private

  # Filter out directories. This could happen when changing a symlink to a
  # directory as part of an amendment, since the symlink will still appear as
  # a file, but the actual working tree will have a directory.
  def filter_directories(modified_files); end

  def filter_modified_files(modified_files); end

  # Filter out non-existent files (unless it's a broken symlink, in which case
  # it's a file that points to a non-existent file). This could happen if a
  # file was renamed as part of an amendment, leading to the old file no
  # longer existing.
  def filter_nonexistent(modified_files); end
end

module Overcommit::HookLoader; end

# Responsible for loading hooks from a file.
class Overcommit::HookLoader::Base
  # @param config [Overcommit::Configuration]
  # @param context [Overcommit::HookContext]
  # @param logger [Overcommit::Logger]
  # @return [Base] a new instance of Base
  def initialize(config, context, logger); end

  # When implemented in subclasses, loads the hooks for which that subclass is
  # responsible.
  #
  # @raise [NotImplementedError]
  # @return [Array<Hook>]
  def load_hooks; end

  private

  # Load and return a {Hook} from a CamelCase hook name.
  def create_hook(hook_name); end

  # Returns the value of attribute log.
  def log; end
end

# Responsible for loading hooks that ship with Overcommit.
class Overcommit::HookLoader::BuiltInHookLoader < ::Overcommit::HookLoader::Base
  def load_hooks; end
end

# Responsible for loading hooks that are specific to the repository Overcommit
# is running in.
class Overcommit::HookLoader::PluginHookLoader < ::Overcommit::HookLoader::Base
  def load_hooks; end
  def update_signatures; end

  private

  def ad_hoc_hook_names; end

  # @raise [Overcommit::Exceptions::InvalidHookSignature]
  def check_for_modified_plugins; end

  def create_ad_hoc_hook(hook_name); end
  def modified_plugins; end
  def plugin_hook_names; end
  def plugin_paths; end
end

# Responsible for loading the hooks the repository has configured and running
# them, collecting and displaying the results.
class Overcommit::HookRunner
  # @param config [Overcommit::Configuration]
  # @param logger [Overcommit::Logger]
  # @param context [Overcommit::HookContext]
  # @param printer [Overcommit::Printer]
  # @return [HookRunner] a new instance of HookRunner
  def initialize(config, logger, context, printer); end

  # Loads and runs the hooks registered for this {HookRunner}.
  def run; end

  private

  def consume; end
  def load_hooks; end

  # Returns the value of attribute log.
  def log; end

  def print_results; end
  def processors_for_hook(hook); end
  def release_slot(hook); end
  def run_hook(hook); end
  def run_hooks; end

  # @return [Boolean]
  def should_skip?(hook); end

  def wait_for_slot(hook); end
end

# Calculates, stores, and retrieves stored signatures of hook plugins.
class Overcommit::HookSigner
  # @param hook_name [String] name of the hook
  # @param config [Overcommit::Configuration]
  # @param context [Overcommit::HookContext]
  # @return [HookSigner] a new instance of HookSigner
  def initialize(hook_name, config, context); end

  # Returns the value of attribute hook_name.
  def hook_name; end

  # Returns the path of the file that should be incorporated into this hooks
  # signature.
  #
  # @return [String]
  def hook_path; end

  # @return [Boolean]
  def signable_file?(file); end

  # Return whether the signature for this hook has changed since it was last
  # calculated.
  #
  # @return [true, false]
  def signature_changed?; end

  # Update the current stored signature for this hook.
  def update_signature!; end

  private

  def hook_contents; end

  # Calculates a hash of a hook using a combination of its configuration and
  # file contents.
  #
  # This way, if either the plugin code changes or its configuration changes,
  # the hash will change and we can alert the user to this change.
  def signature; end

  def signature_config_key; end
  def stored_signature; end
end

# We don't want to include the skip setting as it is set by Overcommit
# itself
Overcommit::HookSigner::IGNORED_CONFIG_KEYS = T.let(T.unsafe(nil), Array)

# Manages the installation of Overcommit hooks in a git repository.
class Overcommit::Installer
  # @return [Installer] a new instance of Installer
  def initialize(logger); end

  def run(target, options); end

  private

  # @return [Boolean]
  def can_replace_file?(file); end

  # Returns the configuration for this repository.
  def config(options = T.unsafe(nil)); end

  def ensure_directory(path); end
  def hooks_path; end
  def install; end
  def install_hook_files; end
  def install_master_hook; end
  def install_starter_config; end

  # Returns the value of attribute log.
  def log; end

  def master_hook_install_path; end
  def old_hooks_path; end

  # @return [Boolean]
  def overcommit_hook?(file); end

  def preserve_old_hooks; end
  def restore_old_hooks; end
  def uninstall; end
  def uninstall_hook_files; end
  def uninstall_master_hook; end

  # @return [true, false] whether the hooks were updated
  def update; end

  def validate_target; end
end

Overcommit::Installer::MASTER_HOOK = T.let(T.unsafe(nil), String)
Overcommit::Installer::TEMPLATE_DIRECTORY = T.let(T.unsafe(nil), String)

# Encapsulates all communication to an output source.
class Overcommit::Logger
  # Creates a logger that will write to the given output stream.
  #
  # @param out [IO]
  # @return [Logger] a new instance of Logger
  def initialize(out); end

  # Write a line of output that is intended to be emphasized.
  def bold(*args); end

  # Write a line of output indicating a problem or error which is emphasized
  # over a regular problem or error.
  def bold_error(*args); end

  # Write a line of output indicating a potential cause for concern, but with
  # greater emphasize compared to other warnings.
  def bold_warning(*args); end

  # Write a line of output if debug mode is enabled.
  def debug(*args); end

  # Write a line of output indicating a problem or error.
  def error(*args); end

  # Flushes the [IO] object for partial lines
  def flush; end

  # Write a line of output.
  #
  # A newline character will always be appended.
  def log(*args); end

  # Prints a newline character (alias for readability).
  def newline; end

  # Write output without a trailing newline.
  def partial(*args); end

  # Write a line of output indicating a successful or noteworthy event.
  def success(*args); end

  # Write a line of output indicating a potential cause for concern, but not
  # an actual error.
  def warning(*args); end

  private

  # Outputs text wrapped in ANSI escape code necessary to produce a given
  # color/text display.
  #
  # @param code [String] ANSI escape code, e.g. '1;33' for "bold yellow"
  # @param str [String] string to wrap
  # @param partial [true, false] whether to omit a newline
  def color(code, str, partial = T.unsafe(nil)); end

  class << self
    # Helper for creating a logger which outputs nothing.
    def silent; end
  end
end

# Utility class that encapsulates the handling of hook messages and whether
# they affect lines the user has modified or not.
#
# This class exposes an endpoint that extracts an appropriate hook/status
# output tuple from an array of {Overcommit::Hook::Message}s, respecting the
# configuration settings for the given hook.
class Overcommit::MessageProcessor
  # @param hook [Overcommit::Hook::Base]
  # @param unmodified_lines_setting [String] how to treat messages on
  #   unmodified lines
  # @return [MessageProcessor] a new instance of MessageProcessor
  def initialize(hook, unmodified_lines_setting); end

  # Returns a hook status/output tuple from the messages this processor was
  # initialized with.
  #
  # @return [Array<Symbol,String>]
  def hook_result(messages); end

  private

  # Returns status and output for messages assuming no special treatment of
  # messages occurring on unmodified lines.
  def basic_status_and_output(messages); end

  # @return [Boolean]
  def can_upgrade_to_passing?(status, warning_messages); end

  # @return [Boolean]
  def can_upgrade_to_warning?(status, error_messages); end

  def handle_modified_lines(messages, status); end

  # @return [Boolean]
  def message_on_modified_line?(message); end

  def print_messages(messages, error_heading, warning_heading); end
  def remove_ignored_messages(messages); end
  def transform_status(status, messages_on_modified_lines); end
end

Overcommit::MessageProcessor::ERRORS_GENERIC_HEADER = T.let(T.unsafe(nil), String)
Overcommit::MessageProcessor::ERRORS_MODIFIED_HEADER = T.let(T.unsafe(nil), String)
Overcommit::MessageProcessor::ERRORS_UNMODIFIED_HEADER = T.let(T.unsafe(nil), String)
Overcommit::MessageProcessor::WARNINGS_GENERIC_HEADER = T.let(T.unsafe(nil), String)
Overcommit::MessageProcessor::WARNINGS_MODIFIED_HEADER = T.let(T.unsafe(nil), String)
Overcommit::MessageProcessor::WARNINGS_UNMODIFIED_HEADER = T.let(T.unsafe(nil), String)

# Methods relating to the current operating system
module Overcommit::OS
  class << self
    # @return [Boolean]
    def cygwin?; end

    # @return [Boolean]
    def linux?; end

    # @return [Boolean]
    def mac?; end

    # @return [Boolean]
    def unix?; end

    # @return [Boolean]
    def windows?; end

    private

    def host_os; end
  end
end

Overcommit::OS::SEPARATOR = T.let(T.unsafe(nil), String)

# Provide a set of callbacks which can be executed as events occur during the
# course of {HookRunner#run}.
class Overcommit::Printer
  # @return [Printer] a new instance of Printer
  def initialize(config, logger, context); end

  # Executed at the end of an individual hook run.
  def end_hook(hook, status, output); end

  def hook_run_failed(message); end
  def hook_skipped(hook); end
  def interrupt_triggered; end

  # Returns the value of attribute log.
  def log; end

  def nothing_to_run; end
  def required_hook_not_skipped(hook); end

  # Executed when one or more hooks by the end of the run.
  def run_failed; end

  # Executed when a hook run was interrupted/cancelled by user.
  def run_interrupted; end

  # Executed when no hooks failed by the end of the run.
  def run_succeeded; end

  # Executed when no hooks failed by the end of the run, but some warned.
  def run_warned; end

  # Executed at the very beginning of running the collection of hooks.
  def start_run; end

  private

  def hook_script_name; end
  def print_header(hook); end
  def print_report(output, format = T.unsafe(nil)); end
  def print_result(hook, status, output); end

  # Get all public methods that were defined on this class and wrap them with
  # synchronization locks so we ensure the output isn't interleaved amongst
  # the various threads.
  def synchronize_all_methods; end
end

Overcommit::REPO_URL = T.let(T.unsafe(nil), String)

# Manages execution of a child process, collecting the exit status and
# standard out/error output.
class Overcommit::Subprocess
  class << self
    # Spawns a new process using the given array of arguments (the first
    # element is the command).
    #
    # @option options
    # @param args [Array<String>]
    # @param options [Hash]
    # @return [Result]
    def spawn(args, options = T.unsafe(nil)); end

    # Spawns a new process in the background using the given array of
    # arguments (the first element is the command).
    def spawn_detached(args); end

    private

    # @param process [ChildProcess]
    # @return [Array<IO>]
    def assign_output_streams(process); end

    # Necessary to run commands in the cmd.exe context.
    # Args are joined to properly handle quotes and special characters.
    def win32_prepare_args(args); end
  end
end

# Encapsulates the result of a process.
#
# @attr_reader status [Integer] exit status code returned by process
# @attr_reader stdout [String] standard output stream output
# @attr_reader stderr [String] standard error stream output
class Overcommit::Subprocess::Result < ::Struct
  # exit status code returned by process
  #
  # @return [Integer] the current value of status
  def status; end

  def status=(_); end

  # standard error stream output
  #
  # @return [String] the current value of stderr
  def stderr; end

  def stderr=(_); end

  # standard output stream output
  #
  # @return [String] the current value of stdout
  def stdout; end

  def stdout=(_); end

  # @return [Boolean]
  def success?; end

  class << self
    def [](*_arg0); end
    def inspect; end
    def members; end
    def new(*_arg0); end
  end
end

# Utility functions for general use.
module Overcommit::Utils
  class << self
    # Returns whether a file is a broken symlink.
    #
    # @return [true, false]
    def broken_symlink?(file); end

    # Converts a string containing underscores/hyphens/spaces into CamelCase.
    def camel_case(str); end

    # Convert a glob pattern to an absolute path glob pattern rooted from the
    # repository root directory.
    #
    # @param glob [String]
    # @return [String]
    def convert_glob_to_absolute(glob); end

    # Execute a command in a subprocess, capturing exit status and output from
    # both standard and error streams.
    #
    # This is intended to provide a centralized place to perform any checks or
    # filtering of the command before executing it.
    #
    # The `args` option provides a convenient way of splitting up long
    # argument lists which would otherwise exceed the maximum command line
    # length of the OS. It will break up the list into chunks and run the
    # command with the same prefix `initial_args`, finally combining the
    # output together at the end.
    #
    # This requires that the external command you are running can have its
    # work split up in this way and still produce the same resultant output
    # when outputs of the individual commands are concatenated back together.
    #
    # @option options
    # @param initial_args [Array<String>]
    # @param options [Hash]
    # @return [Overcommit::Subprocess::Result] status, stdout, and stderr
    def execute(initial_args, options = T.unsafe(nil)); end

    # Execute a command in a subprocess, returning immediately.
    #
    # This provides a convenient way to execute long-running processes for
    # which we do not need to know the result.
    #
    # @param args [Array<String>]
    # @return [ChildProcess] detached process spawned in the background
    def execute_in_background(args); end

    # Returns an absolute path to the .git directory for a repo.
    #
    # @return [String]
    def git_dir; end

    # @param cmd [String]
    # @return [true, false] whether a command can be found given the current
    #   environment path.
    def in_path?(cmd); end

    # @return [Overcommit::Logger] logger with which to send debug output
    def log; end

    # @return [Overcommit::Logger] logger with which to send debug output
    def log=(_arg0); end

    # Return whether a pattern matches the given path.
    #
    # @param pattern [String]
    # @param path [String]
    # @return [Boolean]
    def matches_path?(pattern, path); end

    # Return the parent command that triggered this hook run
    #
    # @return [String, nil] the command as a string, if a parent exists.
    def parent_command; end

    # Return the number of processors used by the OS for process scheduling.
    #
    # @see https://github.com/grosser/parallel/blob/v1.6.1/lib/parallel/processor_count.rb#L17-L51
    def processor_count; end

    # Returns an absolute path to the root of the repository.
    #
    # We do this ourselves rather than call `git rev-parse --show-toplevel` to
    # solve an issue where the .git directory might not actually be valid in
    # tests.
    #
    # @return [String]
    def repo_root; end

    def script_path(script); end

    # Shamelessly stolen from:
    # stackoverflow.com/questions/1509915/converting-camel-case-to-underscore-case-in-ruby
    def snake_case(str); end

    # Remove ANSI escape sequences from a string.
    #
    # This is useful for stripping colorized output from external tools.
    #
    # @param text [String]
    # @return [String]
    def strip_color_codes(text); end

    # Returns a list of supported hook classes (PreCommit, CommitMsg, etc.)
    def supported_hook_type_classes; end

    # Returns a list of supported hook types (pre-commit, commit-msg, etc.)
    def supported_hook_types; end

    # Calls a block of code with a modified set of environment variables,
    # restoring them once the code has executed.
    def with_environment(env); end

    private

    # Log debug output.
    #
    # This is necessary since some specs indirectly call utility functions but
    # don't explicitly set the logger for the Utils class, so we do a quick
    # check here to see if it's set before we attempt to log.
    #
    # @param args [Array<String>]
    def debug(*args); end
  end
end

# Utility functions for file IO.
module Overcommit::Utils::FileUtils
  class << self
    # When the host OS is Windows, uses the `dir` command to check whether
    # `link_name` is an NTFS symbolic link. If so, it parses the target from
    # the command output. Otherwise raises an `ArgumentError`. Delegates to
    # `File.readlink` if the host OS is not Windows.
    def readlink(link_name); end

    # When the host OS is Windows, uses the `mklink` command to create an
    # NTFS symbolic link from `new_name` to `old_name`. Otherwise delegates
    # to `File.symlink`
    def symlink(old_name, new_name); end

    # When the host OS is Windows, uses the `dir` command to check whether
    # `file_name` is an NTFS symbolic link. Otherwise delegates to
    # `File.symlink`.
    #
    # @return [Boolean]
    def symlink?(file_name); end

    private

    def win32_dir_cmd(file_name); end
    def win32_fix_pathsep(path); end
    def win32_mklink_cmd(old_name, new_name); end

    # @return [Boolean]
    def win32_symlink?(dir_output); end
  end
end

# Helper class for doing quick constraint validations on version numbers.
#
# This allows us to execute code based on the git version.
class Overcommit::Utils::Version < ::Gem::Version
  def !=(version); end
  def <(version); end
  def <=(version); end
  def ==(version); end
  def >(version); end
  def >=(version); end
end

Overcommit::VERSION = T.let(T.unsafe(nil), String)
